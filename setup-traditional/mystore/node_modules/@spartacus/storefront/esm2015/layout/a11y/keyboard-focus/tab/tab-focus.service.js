import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { AutoFocusService } from '../autofocus/auto-focus.service';
import * as i0 from "@angular/core";
import * as i1 from "../services/select-focus.util";
let TabFocusService = class TabFocusService extends AutoFocusService {
    /**
     * Moves to the next (or previous) tab.
     */
    moveTab(host, config, increment, event) {
        if (config === null || config === void 0 ? void 0 : config.tab) {
            const next = config.tab === 'scroll'
                ? this.findNextScrollable(host, config, increment)
                : this.findNext(host, config, increment);
            next === null || next === void 0 ? void 0 : next.focus();
            event.preventDefault();
            event.stopPropagation();
        }
    }
    /**
     * builds out virtual slides out of the full scrollable area, to allow
     * for maximum flexibility for the underlying layout without using hardcoded
     * slide sizes.
     */
    findNextScrollable(host, config, increment) {
        var _a;
        const active = this.getActiveChild(host, config);
        if (!active) {
            return;
        }
        // slide count
        const virtualSlideCount = Math.round(host.scrollWidth / host.clientWidth);
        // find current virtual slide
        const currentVirtualSlide = Math.round(active.offsetLeft / (host.scrollWidth / virtualSlideCount));
        let nextVirtualSlide = currentVirtualSlide + increment;
        if (increment === 1 /* NEXT */ &&
            nextVirtualSlide >= virtualSlideCount) {
            nextVirtualSlide = 0;
        }
        if (increment === -1 /* PREV */ && nextVirtualSlide < 0) {
            nextVirtualSlide = virtualSlideCount - 1;
        }
        const firstItemOnNextSlide = (_a = this.getChildren(host, config)) === null || _a === void 0 ? void 0 : _a.find((tab) => tab.offsetLeft >=
            (host.scrollWidth / virtualSlideCount) * nextVirtualSlide);
        return firstItemOnNextSlide;
    }
    findNext(host, config, increment) {
        const childs = this.getChildren(host, config);
        let activeIndex = childs === null || childs === void 0 ? void 0 : childs.findIndex((c) => c === this.getActiveChild(host, config));
        if (!activeIndex || activeIndex === -1) {
            activeIndex = 0;
        }
        activeIndex += increment;
        if (increment === 1 /* NEXT */ && activeIndex >= (childs === null || childs === void 0 ? void 0 : childs.length)) {
            activeIndex = childs.length - 1;
        }
        if (increment === -1 /* PREV */ && activeIndex < 0) {
            activeIndex = 0;
        }
        return childs ? childs[activeIndex] : undefined;
    }
    /**
     * Returns the active focusable child element. If there's no active
     * focusable child element, the first focusable child is returned.
     */
    getActiveChild(host, config) {
        const persisted = this.getPersisted(host, config === null || config === void 0 ? void 0 : config.group);
        if (persisted) {
            return persisted;
        }
        const children = this.getChildren(host, config);
        let index = children.findIndex((tab) => this.isActive(tab));
        if (!index || index === -1) {
            index = 0;
        }
        return children[index];
    }
    getChildren(host, config) {
        if (typeof config.tab === 'string' && config.tab !== 'scroll') {
            return this.selectFocusUtil.query(host, config.tab);
        }
        else {
            return this.findFocusable(host, true);
        }
    }
    /**
     * Returns all focusable child elements of the host element.
     *
     * @param host The host element is used to query child focusable elements.
     * @param locked Indicates if locked elements (tabindex=-1) should be returned, defaults to false.
     * @param invisible Indicates if invisible child elements should be returned, defaults to false.
     */
    findFocusable(host, locked = false, invisible = false) {
        return this.selectFocusUtil.findFocusable(host, locked, invisible);
    }
    isActive(el) {
        const child = document.activeElement;
        const selector = child.tagName;
        return (el === child ||
            !!Array.from(el.querySelectorAll(selector)).find((e) => e === child));
    }
};
TabFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TabFocusService_Factory() { return new TabFocusService(i0.ɵɵinject(i1.SelectFocusUtility)); }, token: TabFocusService, providedIn: "root" });
TabFocusService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], TabFocusService);
export { TabFocusService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLWZvY3VzLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL3N0b3JlZnJvbnQvIiwic291cmNlcyI6WyJsYXlvdXQvYTExeS9rZXlib2FyZC1mb2N1cy90YWIvdGFiLWZvY3VzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUNBQWlDLENBQUM7OztBQU1uRSxJQUFhLGVBQWUsR0FBNUIsTUFBYSxlQUFnQixTQUFRLGdCQUFnQjtJQUNuRDs7T0FFRztJQUNILE9BQU8sQ0FDTCxJQUFpQixFQUNqQixNQUFzQixFQUN0QixTQUFxQixFQUNyQixLQUFvQjtRQUVwQixJQUFJLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxHQUFHLEVBQUU7WUFDZixNQUFNLElBQUksR0FDUixNQUFNLENBQUMsR0FBRyxLQUFLLFFBQVE7Z0JBQ3JCLENBQUMsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRSxTQUFTLENBQUM7Z0JBQ2xELENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFFN0MsSUFBSSxhQUFKLElBQUksdUJBQUosSUFBSSxDQUFFLEtBQUssR0FBRztZQUVkLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQztZQUN2QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDekI7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNPLGtCQUFrQixDQUMxQixJQUFpQixFQUNqQixNQUFzQixFQUN0QixTQUFxQjs7UUFFckIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFakQsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE9B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YXIvY29yZSc7XHJcbmltcG9ydCB7IEF1dG9Gb2N1c1NlcnZpY2UgfSBmcm9tICcuLi9hdXRvZm9jdXMvYXV0by1mb2N1cy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTU9WRV9GT0NVUywgVGFiRm9jdXNDb25maWcgfSBmcm9tICcuLi9rZXlib2FyZC1mb2N1cy5tb2RlbCc7XHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVGFiRm9jdXNTZXJ2aWNlIGV4dGVuZHMgQXV0b0ZvY3VzU2VydmljZSB7XHJcbiAgLyoqXHJcbiAgICogTW92ZXMgdG8gdGhlIG5leHQgKG9yIHByZXZpb3VzKSB0YWIuXHJcbiAgICovXHJcbiAgbW92ZVRhYihcclxuICAgIGhvc3Q6IEhUTUxFbGVtZW50LFxyXG4gICAgY29uZmlnOiBUYWJGb2N1c0NvbmZpZyxcclxuICAgIGluY3JlbWVudDogTU9WRV9GT0NVUyxcclxuICAgIGV2ZW50OiBLZXlib2FyZEV2ZW50XHJcbiAgKTogdm9pZCB7XHJcbiAgICBpZiAoY29uZmlnPy50YWIpIHtcclxuICAgICAgY29uc3QgbmV4dCA9XHJcbiAgICAgICAgY29uZmlnLnRhYiA9PT0gJ3Njcm9sbCdcclxuICAgICAgICAgID8gdGhpcy5maW5kTmV4dFNjcm9sbGFibGUoaG9zdCwgY29uZmlnLCBpbmNyZW1lbnQpXHJcbiAgICAgICAgICA6IHRoaXMuZmluZE5leHQoaG9zdCwgY29uZmlnLCBpbmNyZW1lbnQpO1xyXG5cclxuICAgICAgbmV4dD8uZm9jdXMoKTtcclxuXHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogYnVpbGRzIG91dCB2aXJ0dWFsIHNsaWRlcyBvdXQgb2YgdGhlIGZ1bGwgc2Nyb2xsYWJsZSBhcmVhLCB0byBhbGxvd1xyXG4gICAqIGZvciBtYXhpbXVtIGZsZXhpYmlsaXR5IGZvciB0aGUgdW5kZXJseWluZyBsYXlvdXQgd2l0aG91dCB1c2luZyBoYXJkY29kZWRcclxuICAgKiBzbGlkZSBzaXplcy5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZmluZE5leHRTY3JvbGxhYmxlKFxyXG4gICAgaG9zdDogSFRNTEVsZW1lbnQsXHJcbiAgICBjb25maWc6IFRhYkZvY3VzQ29uZmlnLFxyXG4gICAgaW5jcmVtZW50OiBNT1ZFX0ZPQ1VTXHJcbiAgKTogSFRNTEVsZW1lbnQge1xyXG4gICAgY29uc3QgYWN0aXZlID0gdGhpcy5nZXRBY3RpdmVDaGlsZChob3N0LCBjb25maWcpO1xyXG5cclxuICAgIGlmICghYWN0aXZlKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIC8vIHNsaWRlIGNvdW50XHJcbiAgICBjb25zdCB2aXJ0dWFsU2xpZGVDb3VudCA9IE1hdGgucm91bmQoaG9zdC5zY3JvbGxXaWR0aCAvIGhvc3QuY2xpZW50V2lkdGgpO1xyXG5cclxuICAgIC8vIGZpbmQgY3VycmVudCB2aXJ0dWFsIHNsaWRlXHJcbiAgICBjb25zdCBjdXJyZW50VmlydHVhbFNsaWRlID0gTWF0aC5yb3VuZChcclxuICAgICAgYWN0aXZlLm9mZnNldExlZnQgLyAoaG9zdC5zY3JvbGxXaWR0aCAvIHZpcnR1YWxTbGlkZUNvdW50KVxyXG4gICAgKTtcclxuXHJcbiAgICBsZXQgbmV4dFZpcnR1YWxTbGlkZSA9IGN1cnJlbnRWaXJ0dWFsU2xpZGUgKyBpbmNyZW1lbnQ7XHJcbiAgICBpZiAoXHJcbiAgICAgIGluY3JlbWVudCA9PT0gTU9WRV9GT0NVUy5ORVhUICYmXHJcbiAgICAgIG5leHRWaXJ0dWFsU2xpZGUgPj0gdmlydHVhbFNsaWRlQ291bnRcclxuICAgICkge1xyXG4gICAgICBuZXh0VmlydHVhbFNsaWRlID0gMDtcclxuICAgIH1cclxuICAgIGlmIChpbmNyZW1lbnQgPT09IE1PVkVfRk9DVVMuUFJFViAmJiBuZXh0VmlydHVhbFNsaWRlIDwgMCkge1xyXG4gICAgICBuZXh0VmlydHVhbFNsaWRlID0gdmlydHVhbFNsaWRlQ291bnQgLSAxO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGZpcnN0SXRlbU9uTmV4dFNsaWRlID0gdGhpcy5nZXRDaGlsZHJlbihob3N0LCBjb25maWcpPy5maW5kKFxyXG4gICAgICAodGFiKSA9PlxyXG4gICAgICAgIHRhYi5vZmZzZXRMZWZ0ID49XHJcbiAgICAgICAgKGhvc3Quc2Nyb2xsV2lkdGggLyB2aXJ0dWFsU2xpZGVDb3VudCkgKiBuZXh0VmlydHVhbFNsaWRlXHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiBmaXJzdEl0ZW1Pbk5leHRTbGlkZTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBmaW5kTmV4dChcclxuICAgIGhvc3Q6IEhUTUxFbGVtZW50LFxyXG4gICAgY29uZmlnOiBUYWJGb2N1c0NvbmZpZyxcclxuICAgIGluY3JlbWVudDogTU9WRV9GT0NVU1xyXG4gICk6IEhUTUxFbGVtZW50IHtcclxuICAgIGNvbnN0IGNoaWxkcyA9IHRoaXMuZ2V0Q2hpbGRyZW4oaG9zdCwgY29uZmlnKTtcclxuICAgIGxldCBhY3RpdmVJbmRleCA9IGNoaWxkcz8uZmluZEluZGV4KFxyXG4gICAgICAoYykgPT4gYyA9PT0gdGhpcy5nZXRBY3RpdmVDaGlsZChob3N0LCBjb25maWcpXHJcbiAgICApO1xyXG5cclxuICAgIGlmICghYWN0aXZlSW5kZXggfHwgYWN0aXZlSW5kZXggPT09IC0xKSB7XHJcbiAgICAgIGFjdGl2ZUluZGV4ID0gMDtcclxuICAgIH1cclxuICAgIGFjdGl2ZUluZGV4ICs9IGluY3JlbWVudDtcclxuXHJcbiAgICBpZiAoaW5jcmVtZW50ID09PSBNT1ZFX0ZPQ1VTLk5FWFQgJiYgYWN0aXZlSW5kZXggPj0gY2hpbGRzPy5sZW5ndGgpIHtcclxuICAgICAgYWN0aXZlSW5kZXggPSBjaGlsZHMubGVuZ3RoIC0gMTtcclxuICAgIH1cclxuICAgIGlmIChpbmNyZW1lbnQgPT09IE1PVkVfRk9DVVMuUFJFViAmJiBhY3RpdmVJbmRleCA8IDApIHtcclxuICAgICAgYWN0aXZlSW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkcyA/IGNoaWxkc1thY3RpdmVJbmRleF0gOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgZm9jdXNhYmxlIGNoaWxkIGVsZW1lbnQuIElmIHRoZXJlJ3Mgbm8gYWN0aXZlXHJcbiAgICogZm9jdXNhYmxlIGNoaWxkIGVsZW1lbnQsIHRoZSBmaXJzdCBmb2N1c2FibGUgY2hpbGQgaXMgcmV0dXJuZWQuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGdldEFjdGl2ZUNoaWxkKFxyXG4gICAgaG9zdDogSFRNTEVsZW1lbnQsXHJcbiAgICBjb25maWc6IFRhYkZvY3VzQ29uZmlnXHJcbiAgKTogSFRNTEVsZW1lbnQge1xyXG4gICAgY29uc3QgcGVyc2lzdGVkID0gdGhpcy5nZXRQZXJzaXN0ZWQoaG9zdCwgY29uZmlnPy5ncm91cCk7XHJcbiAgICBpZiAocGVyc2lzdGVkKSB7XHJcbiAgICAgIHJldHVybiBwZXJzaXN0ZWQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oaG9zdCwgY29uZmlnKTtcclxuICAgIGxldCBpbmRleCA9IGNoaWxkcmVuLmZpbmRJbmRleCgodGFiKSA9PiB0aGlzLmlzQWN0aXZlKHRhYikpO1xyXG4gICAgaWYgKCFpbmRleCB8fCBpbmRleCA9PT0gLTEpIHtcclxuICAgICAgaW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNoaWxkcmVuW2luZGV4XTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZXRDaGlsZHJlbihcclxuICAgIGhvc3Q6IEhUTUxFbGVtZW50LFxyXG4gICAgY29uZmlnOiBUYWJGb2N1c0NvbmZpZ1xyXG4gICk6IEhUTUxFbGVtZW50W10ge1xyXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGFiID09PSAnc3RyaW5nJyAmJiBjb25maWcudGFiICE9PSAnc2Nyb2xsJykge1xyXG4gICAgICByZXR1cm4gdGhpcy5zZWxlY3RGb2N1c1V0aWwucXVlcnkoaG9zdCwgY29uZmlnLnRhYik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gdGhpcy5maW5kRm9jdXNhYmxlKGhvc3QsIHRydWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgZm9jdXNhYmxlIGNoaWxkIGVsZW1lbnRzIG9mIHRoZSBob3N0IGVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaG9zdCBUaGUgaG9zdCBlbGVtZW50IGlzIHVzZWQgdG8gcXVlcnkgY2hpbGQgZm9jdXNhYmxlIGVsZW1lbnRzLlxyXG4gICAqIEBwYXJhbSBsb2NrZWQgSW5kaWNhdGVzIGlmIGxvY2tlZCBlbGVtZW50cyAodGFiaW5kZXg9LTEpIHNob3VsZCBiZSByZXR1cm5lZCwgZGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICogQHBhcmFtIGludmlzaWJsZSBJbmRpY2F0ZXMgaWYgaW52aXNpYmxlIGNoaWxkIGVsZW1lbnRzIHNob3VsZCBiZSByZXR1cm5lZCwgZGVmYXVsdHMgdG8gZmFsc2UuXHJcbiAgICovXHJcbiAgZmluZEZvY3VzYWJsZShcclxuICAgIGhvc3Q6IEhUTUxFbGVtZW50LFxyXG4gICAgbG9ja2VkID0gZmFsc2UsXHJcbiAgICBpbnZpc2libGUgPSBmYWxzZVxyXG4gICk6IEhUTUxFbGVtZW50W10ge1xyXG4gICAgcmV0dXJuIHRoaXMuc2VsZWN0Rm9jdXNVdGlsLmZpbmRGb2N1c2FibGUoaG9zdCwgbG9ja2VkLCBpbnZpc2libGUpO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGlzQWN0aXZlKGVsOiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xyXG4gICAgY29uc3QgY2hpbGQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgY29uc3Qgc2VsZWN0b3IgPSBjaGlsZC50YWdOYW1lO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgIGVsID09PSBjaGlsZCB8fFxyXG4gICAgICAhIUFycmF5LmZyb20oZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpLmZpbmQoKGUpID0+IGUgPT09IGNoaWxkKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19