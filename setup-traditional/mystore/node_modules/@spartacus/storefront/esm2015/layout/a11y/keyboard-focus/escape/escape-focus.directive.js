import { __decorate } from "tslib";
import { Directive, ElementRef, EventEmitter, HostListener, OnInit, Output, } from '@angular/core';
import { PersistFocusDirective } from '../persist/persist-focus.directive';
import { EscapeFocusService } from './escape-focus.service';
/**
 * Directive to focus the host element whenever the `escape` key is captured.
 * UiEvents bubble up by nature, which is why the `cxEscGroup` can be used
 * on a tree of elements. Each time the escape key is used, the focus will
 * move up in the DOM tree.
 *
 */
let EscapeFocusDirective = class EscapeFocusDirective extends PersistFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = { focusOnEscape: true };
        this.esc = new EventEmitter();
    }
    /**
     * Handles the escape key event.
     * @param event the native keyboard event which contains the escape keydown event
     */
    handleEscape(event) {
        if (this.service.shouldFocus(this.config)) {
            this.service.handleEscape(this.host, this.config, event);
        }
        this.esc.emit(this.service.shouldFocus(this.config));
    }
    ngOnInit() {
        if (this.service.shouldFocus(this.config)) {
            this.requiredTabindex = -1;
        }
        super.ngOnInit();
    }
};
EscapeFocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: EscapeFocusService }
];
__decorate([
    Output()
], EscapeFocusDirective.prototype, "esc", void 0);
__decorate([
    HostListener('keydown.escape', ['$event'])
], EscapeFocusDirective.prototype, "handleEscape", null);
EscapeFocusDirective = __decorate([
    Directive() // selector: '[cxEscFocus]',
], EscapeFocusDirective);
export { EscapeFocusDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNjYXBlLWZvY3VzLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbImxheW91dC9hMTF5L2tleWJvYXJkLWZvY3VzL2VzY2FwZS9lc2NhcGUtZm9jdXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osWUFBWSxFQUNaLE1BQU0sRUFDTixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sb0NBQW9DLENBQUM7QUFDM0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFNUQ7Ozs7OztHQU1HO0FBRUgsSUFBYSxvQkFBb0IsR0FBakMsTUFBYSxvQkFBcUIsU0FBUSxxQkFBcUI7SUFxQjdELFlBQ1ksVUFBc0IsRUFDdEIsT0FBMkI7UUFFckMsS0FBSyxDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUhqQixlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLFlBQU8sR0FBUCxPQUFPLENBQW9CO1FBckI3QixrQkFBYSxHQUFzQixFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUszRCxRQUFHLEdBQUcsSUFBSSxZQUFZLEVBQVcsQ0FBQztJQW1CNUMsQ0FBQztJQWpCRDs7O09BR0c7SUFFSCxZQUFZLENBQUMsS0FBb0I7UUFDL0IsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDekMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzFEO1FBQ0QsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQVNELFFBQVE7UUFDTixJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUN6QyxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDNUI7UUFDRCxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDbkIsQ0FBQztDQUNGLENBQUE7O1lBWnlCLFVBQVU7WUFDYixrQkFBa0I7O0FBaEI3QjtJQUFULE1BQU0sRUFBRTtpREFBbUM7QUFPNUM7SUFEQyxZQUFZLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQzt3REFNMUM7QUFuQlUsb0JBQW9CO0lBRGhDLFNBQVMsRUFBRSxDQUFDLDRCQUE0QjtHQUM1QixvQkFBb0IsQ0FrQ2hDO1NBbENZLG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgRGlyZWN0aXZlLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgRXZlbnRFbWl0dGVyLFxyXG4gIEhvc3RMaXN0ZW5lcixcclxuICBPbkluaXQsXHJcbiAgT3V0cHV0LFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBFc2NhcGVGb2N1c0NvbmZpZyB9IGZyb20gJy4uL2tleWJvYXJkLWZvY3VzLm1vZGVsJztcclxuaW1wb3J0IHsgUGVyc2lzdEZvY3VzRGlyZWN0aXZlIH0gZnJvbSAnLi4vcGVyc2lzdC9wZXJzaXN0LWZvY3VzLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IEVzY2FwZUZvY3VzU2VydmljZSB9IGZyb20gJy4vZXNjYXBlLWZvY3VzLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIERpcmVjdGl2ZSB0byBmb2N1cyB0aGUgaG9zdCBlbGVtZW50IHdoZW5ldmVyIHRoZSBgZXNjYXBlYCBrZXkgaXMgY2FwdHVyZWQuXHJcbiAqIFVpRXZlbnRzIGJ1YmJsZSB1cCBieSBuYXR1cmUsIHdoaWNoIGlzIHdoeSB0aGUgYGN4RXNjR3JvdXBgIGNhbiBiZSB1c2VkXHJcbiAqIG9uIGEgdHJlZSBvZiBlbGVtZW50cy4gRWFjaCB0aW1lIHRoZSBlc2NhcGUga2V5IGlzIHVzZWQsIHRoZSBmb2N1cyB3aWxsXHJcbiAqIG1vdmUgdXAgaW4gdGhlIERPTSB0cmVlLlxyXG4gKlxyXG4gKi9cclxuQERpcmVjdGl2ZSgpIC8vIHNlbGVjdG9yOiAnW2N4RXNjRm9jdXNdJyxcclxuZXhwb3J0IGNsYXNzIEVzY2FwZUZvY3VzRGlyZWN0aXZlIGV4dGVuZHMgUGVyc2lzdEZvY3VzRGlyZWN0aXZlXHJcbiAgaW1wbGVtZW50cyBPbkluaXQge1xyXG4gIHByb3RlY3RlZCBkZWZhdWx0Q29uZmlnOiBFc2NhcGVGb2N1c0NvbmZpZyA9IHsgZm9jdXNPbkVzY2FwZTogdHJ1ZSB9O1xyXG5cclxuICAvLyBASW5wdXQoJ2N4RXNjRm9jdXMnKVxyXG4gIHByb3RlY3RlZCBjb25maWc6IEVzY2FwZUZvY3VzQ29uZmlnO1xyXG5cclxuICBAT3V0cHV0KCkgZXNjID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xyXG5cclxuICAvKipcclxuICAgKiBIYW5kbGVzIHRoZSBlc2NhcGUga2V5IGV2ZW50LlxyXG4gICAqIEBwYXJhbSBldmVudCB0aGUgbmF0aXZlIGtleWJvYXJkIGV2ZW50IHdoaWNoIGNvbnRhaW5zIHRoZSBlc2NhcGUga2V5ZG93biBldmVudFxyXG4gICAqL1xyXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uZXNjYXBlJywgWyckZXZlbnQnXSlcclxuICBoYW5kbGVFc2NhcGUoZXZlbnQ6IEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcclxuICAgIGlmICh0aGlzLnNlcnZpY2Uuc2hvdWxkRm9jdXModGhpcy5jb25maWcpKSB7XHJcbiAgICAgIHRoaXMuc2VydmljZS5oYW5kbGVFc2NhcGUodGhpcy5ob3N0LCB0aGlzLmNvbmZpZywgZXZlbnQpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5lc2MuZW1pdCh0aGlzLnNlcnZpY2Uuc2hvdWxkRm9jdXModGhpcy5jb25maWcpKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICBwcm90ZWN0ZWQgc2VydmljZTogRXNjYXBlRm9jdXNTZXJ2aWNlXHJcbiAgKSB7XHJcbiAgICBzdXBlcihlbGVtZW50UmVmLCBzZXJ2aWNlKTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgaWYgKHRoaXMuc2VydmljZS5zaG91bGRGb2N1cyh0aGlzLmNvbmZpZykpIHtcclxuICAgICAgdGhpcy5yZXF1aXJlZFRhYmluZGV4ID0gLTE7XHJcbiAgICB9XHJcbiAgICBzdXBlci5uZ09uSW5pdCgpO1xyXG4gIH1cclxufVxyXG4iXX0=