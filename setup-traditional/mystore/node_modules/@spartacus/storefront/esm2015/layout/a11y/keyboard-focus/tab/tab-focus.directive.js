import { __decorate } from "tslib";
import { Directive, ElementRef, HostListener } from '@angular/core';
import { AutoFocusDirective } from '../autofocus/auto-focus.directive';
import { TabFocusService } from './tab-focus.service';
/**
 * Directive to move the focus of ("locked") child elements. This is useful
 * for a nested list of tabs, carousel slides or any group of elements that
 * requires horizontal navigation.
 */
let TabFocusDirective = class TabFocusDirective extends AutoFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        /** `tab` defaults to true if the directive `cxTabFocus` is used. */
        this.defaultConfig = { tab: true };
        // @Input('cxTabFocus')
        this.config = {};
    }
    handleNextTab(event) {
        var _a;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
            this.service.moveTab(this.host, this.config, 1 /* NEXT */, event);
        }
    }
    handlePreviousTab(event) {
        var _a;
        if ((_a = this.config) === null || _a === void 0 ? void 0 : _a.tab) {
            this.service.moveTab(this.host, this.config, -1 /* PREV */, event);
        }
    }
};
TabFocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: TabFocusService }
];
__decorate([
    HostListener('keydown.arrowRight', ['$event'])
], TabFocusDirective.prototype, "handleNextTab", null);
__decorate([
    HostListener('keydown.arrowLeft', ['$event'])
], TabFocusDirective.prototype, "handlePreviousTab", null);
TabFocusDirective = __decorate([
    Directive() // selector: '[cxTabFocus]'
], TabFocusDirective);
export { TabFocusDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFiLWZvY3VzLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbImxheW91dC9hMTF5L2tleWJvYXJkLWZvY3VzL3RhYi90YWItZm9jdXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDcEUsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFFdkUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBRXREOzs7O0dBSUc7QUFFSCxJQUFhLGlCQUFpQixHQUE5QixNQUFhLGlCQUFrQixTQUFRLGtCQUFrQjtJQXFCdkQsWUFDWSxVQUFzQixFQUN0QixPQUF3QjtRQUVsQyxLQUFLLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDO1FBSGpCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsWUFBTyxHQUFQLE9BQU8sQ0FBaUI7UUF0QnBDLG9FQUFvRTtRQUMxRCxrQkFBYSxHQUFtQixFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsQ0FBQztRQUV4RCx1QkFBdUI7UUFDYixXQUFNLEdBQW1CLEVBQUUsQ0FBQztJQXFCdEMsQ0FBQztJQWxCRCxhQUFhLENBQUMsS0FBb0I7O1FBQ2hDLFVBQUksSUFBSSxDQUFDLE1BQU0sMENBQUUsR0FBRyxFQUFFO1lBQ3BCLElBQUksQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sZ0JBQW1CLEtBQUssQ0FBQyxDQUFDO1NBQ3RFO0lBQ0gsQ0FBQztJQUdELGlCQUFpQixDQUFDLEtBQW9COztRQUNwQyxVQUFJLElBQUksQ0FBQyxNQUFNLDBDQUFFLEdBQUcsRUFBRTtZQUNwQixJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLGlCQUFtQixLQUFLLENBQUMsQ0FBQztTQUN0RTtJQUNILENBQUM7Q0FRRixDQUFBOztZQUx5QixVQUFVO1lBQ2IsZUFBZTs7QUFmcEM7SUFEQyxZQUFZLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztzREFLOUM7QUFHRDtJQURDLFlBQVksQ0FBQyxtQkFBbUIsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzBEQUs3QztBQW5CVSxpQkFBaUI7SUFEN0IsU0FBUyxFQUFFLENBQUMsMkJBQTJCO0dBQzNCLGlCQUFpQixDQTJCN0I7U0EzQlksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQXV0b0ZvY3VzRGlyZWN0aXZlIH0gZnJvbSAnLi4vYXV0b2ZvY3VzL2F1dG8tZm9jdXMuZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgTU9WRV9GT0NVUywgVGFiRm9jdXNDb25maWcgfSBmcm9tICcuLi9rZXlib2FyZC1mb2N1cy5tb2RlbCc7XHJcbmltcG9ydCB7IFRhYkZvY3VzU2VydmljZSB9IGZyb20gJy4vdGFiLWZvY3VzLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIERpcmVjdGl2ZSB0byBtb3ZlIHRoZSBmb2N1cyBvZiAoXCJsb2NrZWRcIikgY2hpbGQgZWxlbWVudHMuIFRoaXMgaXMgdXNlZnVsXHJcbiAqIGZvciBhIG5lc3RlZCBsaXN0IG9mIHRhYnMsIGNhcm91c2VsIHNsaWRlcyBvciBhbnkgZ3JvdXAgb2YgZWxlbWVudHMgdGhhdFxyXG4gKiByZXF1aXJlcyBob3Jpem9udGFsIG5hdmlnYXRpb24uXHJcbiAqL1xyXG5ARGlyZWN0aXZlKCkgLy8gc2VsZWN0b3I6ICdbY3hUYWJGb2N1c10nXHJcbmV4cG9ydCBjbGFzcyBUYWJGb2N1c0RpcmVjdGl2ZSBleHRlbmRzIEF1dG9Gb2N1c0RpcmVjdGl2ZSB7XHJcbiAgLyoqIGB0YWJgIGRlZmF1bHRzIHRvIHRydWUgaWYgdGhlIGRpcmVjdGl2ZSBgY3hUYWJGb2N1c2AgaXMgdXNlZC4gKi9cclxuICBwcm90ZWN0ZWQgZGVmYXVsdENvbmZpZzogVGFiRm9jdXNDb25maWcgPSB7IHRhYjogdHJ1ZSB9O1xyXG5cclxuICAvLyBASW5wdXQoJ2N4VGFiRm9jdXMnKVxyXG4gIHByb3RlY3RlZCBjb25maWc6IFRhYkZvY3VzQ29uZmlnID0ge307XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uYXJyb3dSaWdodCcsIFsnJGV2ZW50J10pXHJcbiAgaGFuZGxlTmV4dFRhYihldmVudDogS2V5Ym9hcmRFdmVudCkge1xyXG4gICAgaWYgKHRoaXMuY29uZmlnPy50YWIpIHtcclxuICAgICAgdGhpcy5zZXJ2aWNlLm1vdmVUYWIodGhpcy5ob3N0LCB0aGlzLmNvbmZpZywgTU9WRV9GT0NVUy5ORVhULCBldmVudCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBASG9zdExpc3RlbmVyKCdrZXlkb3duLmFycm93TGVmdCcsIFsnJGV2ZW50J10pXHJcbiAgaGFuZGxlUHJldmlvdXNUYWIoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcclxuICAgIGlmICh0aGlzLmNvbmZpZz8udGFiKSB7XHJcbiAgICAgIHRoaXMuc2VydmljZS5tb3ZlVGFiKHRoaXMuaG9zdCwgdGhpcy5jb25maWcsIE1PVkVfRk9DVVMuUFJFViwgZXZlbnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgIHByb3RlY3RlZCBzZXJ2aWNlOiBUYWJGb2N1c1NlcnZpY2VcclxuICApIHtcclxuICAgIHN1cGVyKGVsZW1lbnRSZWYsIHNlcnZpY2UpO1xyXG4gIH1cclxufVxyXG4iXX0=