import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { BaseFocusService } from '../base/base-focus.service';
import { FOCUS_GROUP_ATTR } from '../keyboard-focus.model';
import * as i0 from "@angular/core";
const GLOBAL_GROUP = '_g_';
/**
 * Shared service to persist the focus for an element or a group
 * of elements. The persisted element focus can be used to persist
 * the focus for a DOM tree, so that the focus remains after a repaint
 * or reoccurs when a DOM tree is "unlocked".
 */
let PersistFocusService = class PersistFocusService extends BaseFocusService {
    constructor() {
        super(...arguments);
        // this is going to fail as we have sub services. They will al have their own map.
        // We must bring this to a singleton map.
        this.focus = new Map();
    }
    get(group) {
        return this.focus.get(group || GLOBAL_GROUP);
    }
    /**
     * Persist the keyboard focus state for the given key. The focus is stored globally
     * or for the given group.
     */
    set(key, group) {
        if (key) {
            this.focus.set(group || GLOBAL_GROUP, key);
        }
    }
    /**
     * Clears the persisted keyboard focus state globally or for the given group.
     */
    clear(group) {
        this.focus.delete(group || GLOBAL_GROUP);
    }
    /**
     * Returns the group for the host element based on the configured group or
     * by the `data-cx-focus-group` attribute stored on the host.
     */
    getPersistenceGroup(host, config) {
        return (config === null || config === void 0 ? void 0 : config.group) ? config.group : host.getAttribute(FOCUS_GROUP_ATTR);
    }
};
PersistFocusService.ɵprov = i0.ɵɵdefineInjectable({ factory: function PersistFocusService_Factory() { return new PersistFocusService(); }, token: PersistFocusService, providedIn: "root" });
PersistFocusService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], PersistFocusService);
export { PersistFocusService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyc2lzdC1mb2N1cy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9zdG9yZWZyb250LyIsInNvdXJjZXMiOlsibGF5b3V0L2ExMXkva2V5Ym9hcmQtZm9jdXMvcGVyc2lzdC9wZXJzaXN0LWZvY3VzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFDOUQsT0FBTyxFQUFFLGdCQUFnQixFQUFzQixNQUFNLHlCQUF5QixDQUFDOztBQUUvRSxNQUFNLFlBQVksR0FBRyxLQUFLLENBQUM7QUFFM0I7Ozs7O0dBS0c7QUFJSCxJQUFhLG1CQUFtQixHQUFoQyxNQUFhLG1CQUFvQixTQUFRLGdCQUFnQjtJQUF6RDs7UUFDRSxrRkFBa0Y7UUFDbEYseUNBQXlDO1FBQy9CLFVBQUssR0FBRyxJQUFJLEdBQUcsRUFBa0IsQ0FBQztLQThCN0M7SUE1QkMsR0FBRyxDQUFDLEtBQWM7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxLQUFLLElBQUksWUFBWSxDQUFDLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7T0FHRztJQUNILEdBQUcsQ0FBQyxHQUFXLEVBQUUsS0FBYztRQUM3QixJQUFJLEdBQUcsRUFBRTtZQUNQLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxZQUFZLEVBQUUsR0FBRyxDQUFDLENBQUM7U0FDNUM7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsS0FBYztRQUNsQixJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksWUFBWSxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7T0FHRztJQUNILG1CQUFtQixDQUFDLElBQWlCLEVBQUUsTUFBMkI7UUFDaEUsT0FBTyxDQUFBLE1BQU0sYUFBTixNQUFNLHVCQUFOLE1BQU0sQ0FBRSxLQUFLLEVBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUM1RSxDQUFDO0NBQ0YsQ0FBQTs7QUFqQ1ksbUJBQW1CO0lBSC9CLFVBQVUsQ0FBQztRQUNWLFVBQVUsRUFBRSxNQUFNO0tBQ25CLENBQUM7R0FDVyxtQkFBbUIsQ0FpQy9CO1NBakNZLG1CQUFtQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmFzZUZvY3VzU2VydmljZSB9IGZyb20gJy4uL2Jhc2UvYmFzZS1mb2N1cy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgRk9DVVNfR1JPVVBfQVRUUiwgUGVyc2lzdEZvY3VzQ29uZmlnIH0gZnJvbSAnLi4va2V5Ym9hcmQtZm9jdXMubW9kZWwnO1xyXG5cclxuY29uc3QgR0xPQkFMX0dST1VQID0gJ19nXyc7XHJcblxyXG4vKipcclxuICogU2hhcmVkIHNlcnZpY2UgdG8gcGVyc2lzdCB0aGUgZm9jdXMgZm9yIGFuIGVsZW1lbnQgb3IgYSBncm91cFxyXG4gKiBvZiBlbGVtZW50cy4gVGhlIHBlcnNpc3RlZCBlbGVtZW50IGZvY3VzIGNhbiBiZSB1c2VkIHRvIHBlcnNpc3RcclxuICogdGhlIGZvY3VzIGZvciBhIERPTSB0cmVlLCBzbyB0aGF0IHRoZSBmb2N1cyByZW1haW5zIGFmdGVyIGEgcmVwYWludFxyXG4gKiBvciByZW9jY3VycyB3aGVuIGEgRE9NIHRyZWUgaXMgXCJ1bmxvY2tlZFwiLlxyXG4gKi9cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFBlcnNpc3RGb2N1c1NlcnZpY2UgZXh0ZW5kcyBCYXNlRm9jdXNTZXJ2aWNlIHtcclxuICAvLyB0aGlzIGlzIGdvaW5nIHRvIGZhaWwgYXMgd2UgaGF2ZSBzdWIgc2VydmljZXMuIFRoZXkgd2lsbCBhbCBoYXZlIHRoZWlyIG93biBtYXAuXHJcbiAgLy8gV2UgbXVzdCBicmluZyB0aGlzIHRvIGEgc2luZ2xldG9uIG1hcC5cclxuICBwcm90ZWN0ZWQgZm9jdXMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpO1xyXG5cclxuICBnZXQoZ3JvdXA/OiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuIHRoaXMuZm9jdXMuZ2V0KGdyb3VwIHx8IEdMT0JBTF9HUk9VUCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJzaXN0IHRoZSBrZXlib2FyZCBmb2N1cyBzdGF0ZSBmb3IgdGhlIGdpdmVuIGtleS4gVGhlIGZvY3VzIGlzIHN0b3JlZCBnbG9iYWxseVxyXG4gICAqIG9yIGZvciB0aGUgZ2l2ZW4gZ3JvdXAuXHJcbiAgICovXHJcbiAgc2V0KGtleTogc3RyaW5nLCBncm91cD86IHN0cmluZykge1xyXG4gICAgaWYgKGtleSkge1xyXG4gICAgICB0aGlzLmZvY3VzLnNldChncm91cCB8fCBHTE9CQUxfR1JPVVAsIGtleSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGVhcnMgdGhlIHBlcnNpc3RlZCBrZXlib2FyZCBmb2N1cyBzdGF0ZSBnbG9iYWxseSBvciBmb3IgdGhlIGdpdmVuIGdyb3VwLlxyXG4gICAqL1xyXG4gIGNsZWFyKGdyb3VwPzogc3RyaW5nKSB7XHJcbiAgICB0aGlzLmZvY3VzLmRlbGV0ZShncm91cCB8fCBHTE9CQUxfR1JPVVApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZ3JvdXAgZm9yIHRoZSBob3N0IGVsZW1lbnQgYmFzZWQgb24gdGhlIGNvbmZpZ3VyZWQgZ3JvdXAgb3JcclxuICAgKiBieSB0aGUgYGRhdGEtY3gtZm9jdXMtZ3JvdXBgIGF0dHJpYnV0ZSBzdG9yZWQgb24gdGhlIGhvc3QuXHJcbiAgICovXHJcbiAgZ2V0UGVyc2lzdGVuY2VHcm91cChob3N0OiBIVE1MRWxlbWVudCwgY29uZmlnPzogUGVyc2lzdEZvY3VzQ29uZmlnKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBjb25maWc/Lmdyb3VwID8gY29uZmlnLmdyb3VwIDogaG9zdC5nZXRBdHRyaWJ1dGUoRk9DVVNfR1JPVVBfQVRUUik7XHJcbiAgfVxyXG59XHJcbiJdfQ==