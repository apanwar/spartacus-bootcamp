import { __decorate } from "tslib";
import { AfterViewInit, Directive, ElementRef, HostBinding, HostListener, OnInit, } from '@angular/core';
import { BlockFocusDirective } from '../block/block-focus.directive';
import { FOCUS_ATTR } from '../keyboard-focus.model';
import { PersistFocusService } from './persist-focus.service';
/**
 * Directive that provides persistence of the focused state. This is useful
 * when a group of focusable elements got refocused or even recreated. That
 * happens often when the DOM is constructed with an `*ngIf` or `*ngFor`.
 *
 * The focus state is based on a configured _key_, which can be passed in the
 * config input, either by using a string primitive or `PersistFocusConfig.key`:
 *
 * ```html
 * <button cxPersistFocus="myKey"></button>
 * <button cxFocus="myKey"></button>
 * <button [cxFocus]="{{key:'myKey'}"></button>
 * ```
 *
 * The focus state can be part of a focus _group_, so that the state is shared
 * and remember for the given group. In order to detect the persistence for a
 * given element, we store the persistence key as a data attribute (`data-cx-focus`):
 *
 * ```html
 * <button data-cx-focus="myKey"></button>
 * ```
 *
 * Other keyboard focus directives can read the key to understand whether the element
 * should retrieve focus.
 *
 */
let PersistFocusDirective = class PersistFocusDirective extends BlockFocusDirective {
    constructor(elementRef, service) {
        super(elementRef, service);
        this.elementRef = elementRef;
        this.service = service;
        this.defaultConfig = {};
        /**
         * The persistence key can be passed directly or through the `FocusConfig.key`.
         * While this could be considered a global key, the likeliness of conflicts
         * is very small since the key is cleared when the focus is changed.
         */
        // @Input('cxPersistFocus')
        this.config = {};
    }
    handleFocus(event) {
        this.service.set(this.key, this.group);
        event === null || event === void 0 ? void 0 : event.preventDefault();
        event === null || event === void 0 ? void 0 : event.stopPropagation();
    }
    ngOnInit() {
        super.ngOnInit();
        this.attr = this.key ? this.key : undefined;
    }
    setDefaultConfiguration() {
        if (typeof this.config === 'string' && this.config !== '') {
            this.config = { key: this.config };
        }
        super.setDefaultConfiguration();
    }
    /**
     * Focus the element explicitly if it was focused before.
     */
    ngAfterViewInit() {
        if (this.isPersisted) {
            this.host.focus({ preventScroll: true });
        }
    }
    get isPersisted() {
        return !!this.key && this.service.get(this.group) === this.key;
    }
    /**
     * Returns the key for the host element, which is used to persist the
     * focus state. This is useful in cases where the DOM is rebuild.
     */
    get key() {
        var _a;
        return (_a = this.config) === null || _a === void 0 ? void 0 : _a.key;
    }
    /**
     * returns the persistence group (if any) for the focusable elements.
     */
    get group() {
        return this.service.getPersistenceGroup(this.host, this.config);
    }
};
PersistFocusDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: PersistFocusService }
];
__decorate([
    HostBinding(`attr.${FOCUS_ATTR}`)
], PersistFocusDirective.prototype, "attr", void 0);
__decorate([
    HostListener('focus', ['$event'])
], PersistFocusDirective.prototype, "handleFocus", null);
PersistFocusDirective = __decorate([
    Directive() // selector: '[cxPersistFocus]',
], PersistFocusDirective);
export { PersistFocusDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGVyc2lzdC1mb2N1cy5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL3N0b3JlZnJvbnQvIiwic291cmNlcyI6WyJsYXlvdXQvYTExeS9rZXlib2FyZC1mb2N1cy9wZXJzaXN0L3BlcnNpc3QtZm9jdXMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsYUFBYSxFQUNiLFNBQVMsRUFDVCxVQUFVLEVBQ1YsV0FBVyxFQUNYLFlBQVksRUFDWixNQUFNLEdBQ1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDckUsT0FBTyxFQUFFLFVBQVUsRUFBc0IsTUFBTSx5QkFBeUIsQ0FBQztBQUN6RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUU5RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCRztBQUVILElBQWEscUJBQXFCLEdBQWxDLE1BQWEscUJBQXNCLFNBQVEsbUJBQW1CO0lBMkI1RCxZQUNZLFVBQXNCLEVBQ3RCLE9BQTRCO1FBRXRDLEtBQUssQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFIakIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixZQUFPLEdBQVAsT0FBTyxDQUFxQjtRQTNCOUIsa0JBQWEsR0FBdUIsRUFBRSxDQUFDO1FBRWpEOzs7O1dBSUc7UUFDSCwyQkFBMkI7UUFDakIsV0FBTSxHQUF1QixFQUFFLENBQUM7SUFzQjFDLENBQUM7SUFaRCxXQUFXLENBQUMsS0FBcUI7UUFDL0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFdkMsS0FBSyxhQUFMLEtBQUssdUJBQUwsS0FBSyxDQUFFLGNBQWMsR0FBRztRQUN4QixLQUFLLGFBQUwsS0FBSyx1QkFBTCxLQUFLLENBQUUsZUFBZSxHQUFHO0lBQzNCLENBQUM7SUFTRCxRQUFRO1FBQ04sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2pCLElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQzlDLENBQUM7SUFFUyx1QkFBdUI7UUFDL0IsSUFBSSxPQUFPLElBQUksQ0FBQyxNQUFNLEtBQUssUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssRUFBRSxFQUFFO1lBQ3pELElBQUksQ0FBQyxNQUFNLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1NBQ3BDO1FBQ0QsS0FBSyxDQUFDLHVCQUF1QixFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsZUFBZTtRQUNiLElBQUksSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNwQixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1NBQzFDO0lBQ0gsQ0FBQztJQUVELElBQWMsV0FBVztRQUN2QixPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ2pFLENBQUM7SUFFRDs7O09BR0c7SUFDSCxJQUFjLEdBQUc7O1FBQ2YsYUFBUSxJQUFJLENBQUMsTUFBNkIsMENBQUUsR0FBRyxDQUFDO0lBQ2xELENBQUM7SUFFRDs7T0FFRztJQUNILElBQWMsS0FBSztRQUNqQixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsbUJBQW1CLENBQ3JDLElBQUksQ0FBQyxJQUFJLEVBQ1QsSUFBSSxDQUFDLE1BQTRCLENBQ2xDLENBQUM7SUFDSixDQUFDO0NBQ0YsQ0FBQTs7WUFoRHlCLFVBQVU7WUFDYixtQkFBbUI7O0FBWkw7SUFBbEMsV0FBVyxDQUFDLFFBQVEsVUFBVSxFQUFFLENBQUM7bURBQWM7QUFHaEQ7SUFEQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUM7d0RBTWpDO0FBekJVLHFCQUFxQjtJQURqQyxTQUFTLEVBQUUsQ0FBQyxnQ0FBZ0M7R0FDaEMscUJBQXFCLENBNEVqQztTQTVFWSxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIEFmdGVyVmlld0luaXQsXHJcbiAgRGlyZWN0aXZlLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgSG9zdEJpbmRpbmcsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIE9uSW5pdCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQmxvY2tGb2N1c0RpcmVjdGl2ZSB9IGZyb20gJy4uL2Jsb2NrL2Jsb2NrLWZvY3VzLmRpcmVjdGl2ZSc7XHJcbmltcG9ydCB7IEZPQ1VTX0FUVFIsIFBlcnNpc3RGb2N1c0NvbmZpZyB9IGZyb20gJy4uL2tleWJvYXJkLWZvY3VzLm1vZGVsJztcclxuaW1wb3J0IHsgUGVyc2lzdEZvY3VzU2VydmljZSB9IGZyb20gJy4vcGVyc2lzdC1mb2N1cy5zZXJ2aWNlJztcclxuXHJcbi8qKlxyXG4gKiBEaXJlY3RpdmUgdGhhdCBwcm92aWRlcyBwZXJzaXN0ZW5jZSBvZiB0aGUgZm9jdXNlZCBzdGF0ZS4gVGhpcyBpcyB1c2VmdWxcclxuICogd2hlbiBhIGdyb3VwIG9mIGZvY3VzYWJsZSBlbGVtZW50cyBnb3QgcmVmb2N1c2VkIG9yIGV2ZW4gcmVjcmVhdGVkLiBUaGF0XHJcbiAqIGhhcHBlbnMgb2Z0ZW4gd2hlbiB0aGUgRE9NIGlzIGNvbnN0cnVjdGVkIHdpdGggYW4gYCpuZ0lmYCBvciBgKm5nRm9yYC5cclxuICpcclxuICogVGhlIGZvY3VzIHN0YXRlIGlzIGJhc2VkIG9uIGEgY29uZmlndXJlZCBfa2V5Xywgd2hpY2ggY2FuIGJlIHBhc3NlZCBpbiB0aGVcclxuICogY29uZmlnIGlucHV0LCBlaXRoZXIgYnkgdXNpbmcgYSBzdHJpbmcgcHJpbWl0aXZlIG9yIGBQZXJzaXN0Rm9jdXNDb25maWcua2V5YDpcclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8YnV0dG9uIGN4UGVyc2lzdEZvY3VzPVwibXlLZXlcIj48L2J1dHRvbj5cclxuICogPGJ1dHRvbiBjeEZvY3VzPVwibXlLZXlcIj48L2J1dHRvbj5cclxuICogPGJ1dHRvbiBbY3hGb2N1c109XCJ7e2tleTonbXlLZXknfVwiPjwvYnV0dG9uPlxyXG4gKiBgYGBcclxuICpcclxuICogVGhlIGZvY3VzIHN0YXRlIGNhbiBiZSBwYXJ0IG9mIGEgZm9jdXMgX2dyb3VwXywgc28gdGhhdCB0aGUgc3RhdGUgaXMgc2hhcmVkXHJcbiAqIGFuZCByZW1lbWJlciBmb3IgdGhlIGdpdmVuIGdyb3VwLiBJbiBvcmRlciB0byBkZXRlY3QgdGhlIHBlcnNpc3RlbmNlIGZvciBhXHJcbiAqIGdpdmVuIGVsZW1lbnQsIHdlIHN0b3JlIHRoZSBwZXJzaXN0ZW5jZSBrZXkgYXMgYSBkYXRhIGF0dHJpYnV0ZSAoYGRhdGEtY3gtZm9jdXNgKTpcclxuICpcclxuICogYGBgaHRtbFxyXG4gKiA8YnV0dG9uIGRhdGEtY3gtZm9jdXM9XCJteUtleVwiPjwvYnV0dG9uPlxyXG4gKiBgYGBcclxuICpcclxuICogT3RoZXIga2V5Ym9hcmQgZm9jdXMgZGlyZWN0aXZlcyBjYW4gcmVhZCB0aGUga2V5IHRvIHVuZGVyc3RhbmQgd2hldGhlciB0aGUgZWxlbWVudFxyXG4gKiBzaG91bGQgcmV0cmlldmUgZm9jdXMuXHJcbiAqXHJcbiAqL1xyXG5ARGlyZWN0aXZlKCkgLy8gc2VsZWN0b3I6ICdbY3hQZXJzaXN0Rm9jdXNdJyxcclxuZXhwb3J0IGNsYXNzIFBlcnNpc3RGb2N1c0RpcmVjdGl2ZSBleHRlbmRzIEJsb2NrRm9jdXNEaXJlY3RpdmVcclxuICBpbXBsZW1lbnRzIE9uSW5pdCwgQWZ0ZXJWaWV3SW5pdCB7XHJcbiAgcHJvdGVjdGVkIGRlZmF1bHRDb25maWc6IFBlcnNpc3RGb2N1c0NvbmZpZyA9IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgcGVyc2lzdGVuY2Uga2V5IGNhbiBiZSBwYXNzZWQgZGlyZWN0bHkgb3IgdGhyb3VnaCB0aGUgYEZvY3VzQ29uZmlnLmtleWAuXHJcbiAgICogV2hpbGUgdGhpcyBjb3VsZCBiZSBjb25zaWRlcmVkIGEgZ2xvYmFsIGtleSwgdGhlIGxpa2VsaW5lc3Mgb2YgY29uZmxpY3RzXHJcbiAgICogaXMgdmVyeSBzbWFsbCBzaW5jZSB0aGUga2V5IGlzIGNsZWFyZWQgd2hlbiB0aGUgZm9jdXMgaXMgY2hhbmdlZC5cclxuICAgKi9cclxuICAvLyBASW5wdXQoJ2N4UGVyc2lzdEZvY3VzJylcclxuICBwcm90ZWN0ZWQgY29uZmlnOiBQZXJzaXN0Rm9jdXNDb25maWcgPSB7fTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHBlcnNpc3RlbmNlIGtleSBpcyBtYWludGFpbmVkIGluIGFuIGVsZW1lbnQgYXR0cmlidXRlIGZvciBvdGhlclxyXG4gICAqIGltcGxlbWVudGF0aW9ucy4gVGhpcyBpcyBuZWVkZWQgdG8gZW5zdXJlIHRoYXQgd2UgY2FuIHJlc29sdmUgdGhlIGZvY3VzXHJcbiAgICogc3RhdGUgaW4gY2FzZSBvZiBhIHJlcGFpbnQuXHJcbiAgICovXHJcbiAgQEhvc3RCaW5kaW5nKGBhdHRyLiR7Rk9DVVNfQVRUUn1gKSBhdHRyOiBzdHJpbmc7XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJywgWyckZXZlbnQnXSlcclxuICBoYW5kbGVGb2N1cyhldmVudD86IEtleWJvYXJkRXZlbnQpIHtcclxuICAgIHRoaXMuc2VydmljZS5zZXQodGhpcy5rZXksIHRoaXMuZ3JvdXApO1xyXG5cclxuICAgIGV2ZW50Py5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgZXZlbnQ/LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcm90ZWN0ZWQgZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgIHByb3RlY3RlZCBzZXJ2aWNlOiBQZXJzaXN0Rm9jdXNTZXJ2aWNlXHJcbiAgKSB7XHJcbiAgICBzdXBlcihlbGVtZW50UmVmLCBzZXJ2aWNlKTtcclxuICB9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgc3VwZXIubmdPbkluaXQoKTtcclxuICAgIHRoaXMuYXR0ciA9IHRoaXMua2V5ID8gdGhpcy5rZXkgOiB1bmRlZmluZWQ7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgc2V0RGVmYXVsdENvbmZpZ3VyYXRpb24oKSB7XHJcbiAgICBpZiAodHlwZW9mIHRoaXMuY29uZmlnID09PSAnc3RyaW5nJyAmJiB0aGlzLmNvbmZpZyAhPT0gJycpIHtcclxuICAgICAgdGhpcy5jb25maWcgPSB7IGtleTogdGhpcy5jb25maWcgfTtcclxuICAgIH1cclxuICAgIHN1cGVyLnNldERlZmF1bHRDb25maWd1cmF0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb2N1cyB0aGUgZWxlbWVudCBleHBsaWNpdGx5IGlmIGl0IHdhcyBmb2N1c2VkIGJlZm9yZS5cclxuICAgKi9cclxuICBuZ0FmdGVyVmlld0luaXQoKSB7XHJcbiAgICBpZiAodGhpcy5pc1BlcnNpc3RlZCkge1xyXG4gICAgICB0aGlzLmhvc3QuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldCBpc1BlcnNpc3RlZCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAhIXRoaXMua2V5ICYmIHRoaXMuc2VydmljZS5nZXQodGhpcy5ncm91cCkgPT09IHRoaXMua2V5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUga2V5IGZvciB0aGUgaG9zdCBlbGVtZW50LCB3aGljaCBpcyB1c2VkIHRvIHBlcnNpc3QgdGhlXHJcbiAgICogZm9jdXMgc3RhdGUuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VzIHdoZXJlIHRoZSBET00gaXMgcmVidWlsZC5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2V0IGtleSgpOiBzdHJpbmcge1xyXG4gICAgcmV0dXJuICh0aGlzLmNvbmZpZyBhcyBQZXJzaXN0Rm9jdXNDb25maWcpPy5rZXk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiByZXR1cm5zIHRoZSBwZXJzaXN0ZW5jZSBncm91cCAoaWYgYW55KSBmb3IgdGhlIGZvY3VzYWJsZSBlbGVtZW50cy5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2V0IGdyb3VwKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5zZXJ2aWNlLmdldFBlcnNpc3RlbmNlR3JvdXAoXHJcbiAgICAgIHRoaXMuaG9zdCxcclxuICAgICAgdGhpcy5jb25maWcgYXMgUGVyc2lzdEZvY3VzQ29uZmlnXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iXX0=