import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output, } from '@angular/core';
import { ICON_TYPE } from '../../../misc/icon/icon.model';
export var ViewModes;
(function (ViewModes) {
    ViewModes["Grid"] = "grid";
    ViewModes["List"] = "list";
})(ViewModes || (ViewModes = {}));
let ProductViewComponent = class ProductViewComponent {
    constructor() {
        this.iconTypes = ICON_TYPE;
        this.modeChange = new EventEmitter();
    }
    get buttonClass() {
        const viewName = this.viewMode.toLowerCase();
        return `cx-product-${viewName}`;
    }
    /**
     *   Display icons inversely to allow users
     *   to see the view they will navigate to
     */
    get viewMode() {
        if (this.mode === 'list') {
            return this.iconTypes.GRID;
        }
        else if (this.mode === 'grid') {
            return this.iconTypes.LIST;
        }
    }
    changeMode() {
        const newMode = this.mode === ViewModes.Grid ? ViewModes.List : ViewModes.Grid;
        this.modeChange.emit(newMode);
    }
};
__decorate([
    Input()
], ProductViewComponent.prototype, "mode", void 0);
__decorate([
    Output()
], ProductViewComponent.prototype, "modeChange", void 0);
ProductViewComponent = __decorate([
    Component({
        selector: 'cx-product-view',
        template: "<button\r\n  class=\"btn cx-product-layout\"\r\n  [ngClass]=\"buttonClass\"\r\n  (click)=\"changeMode()\"\r\n>\r\n  <cx-icon\r\n    *ngIf=\"viewMode === iconTypes.GRID\"\r\n    [type]=\"iconTypes.GRID\"\r\n  ></cx-icon>\r\n  <cx-icon\r\n    *ngIf=\"viewMode === iconTypes.LIST\"\r\n    [type]=\"iconTypes.LIST\"\r\n  ></cx-icon>\r\n</button>\r\n",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], ProductViewComponent);
export { ProductViewComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZHVjdC12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbImNtcy1jb21wb25lbnRzL3Byb2R1Y3QvcHJvZHVjdC1saXN0L3Byb2R1Y3Qtdmlldy9wcm9kdWN0LXZpZXcuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sR0FDUCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFFMUQsTUFBTSxDQUFOLElBQVksU0FHWDtBQUhELFdBQVksU0FBUztJQUNuQiwwQkFBYSxDQUFBO0lBQ2IsMEJBQWEsQ0FBQTtBQUNmLENBQUMsRUFIVyxTQUFTLEtBQVQsU0FBUyxRQUdwQjtBQU9ELElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQW9CO0lBQWpDO1FBQ0UsY0FBUyxHQUFHLFNBQVMsQ0FBQztRQUl0QixlQUFVLEdBQUcsSUFBSSxZQUFZLEVBQVUsQ0FBQztJQXdCMUMsQ0FBQztJQXRCQyxJQUFJLFdBQVc7UUFDYixNQUFNLFFBQVEsR0FBVyxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3JELE9BQU8sY0FBYyxRQUFRLEVBQUUsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsSUFBSSxRQUFRO1FBQ1YsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUN4QixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1NBQzVCO2FBQU0sSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLE1BQU0sRUFBRTtZQUMvQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDO1NBQzVCO0lBQ0gsQ0FBQztJQUVELFVBQVU7UUFDUixNQUFNLE9BQU8sR0FDWCxJQUFJLENBQUMsSUFBSSxLQUFLLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDakUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDaEMsQ0FBQztDQUNGLENBQUE7QUExQkM7SUFEQyxLQUFLLEVBQUU7a0RBQ1E7QUFFaEI7SUFEQyxNQUFNLEVBQUU7d0RBQytCO0FBTDdCLG9CQUFvQjtJQUxoQyxTQUFTLENBQUM7UUFDVCxRQUFRLEVBQUUsaUJBQWlCO1FBQzNCLHFXQUE0QztRQUM1QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtLQUNoRCxDQUFDO0dBQ1csb0JBQW9CLENBNkJoQztTQTdCWSxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBJQ09OX1RZUEUgfSBmcm9tICcuLi8uLi8uLi9taXNjL2ljb24vaWNvbi5tb2RlbCc7XHJcblxyXG5leHBvcnQgZW51bSBWaWV3TW9kZXMge1xyXG4gIEdyaWQgPSAnZ3JpZCcsXHJcbiAgTGlzdCA9ICdsaXN0JyxcclxufVxyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdjeC1wcm9kdWN0LXZpZXcnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi9wcm9kdWN0LXZpZXcuY29tcG9uZW50Lmh0bWwnLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgUHJvZHVjdFZpZXdDb21wb25lbnQge1xyXG4gIGljb25UeXBlcyA9IElDT05fVFlQRTtcclxuICBASW5wdXQoKVxyXG4gIG1vZGU6IFZpZXdNb2RlcztcclxuICBAT3V0cHV0KClcclxuICBtb2RlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxzdHJpbmc+KCk7XHJcblxyXG4gIGdldCBidXR0b25DbGFzcygpIHtcclxuICAgIGNvbnN0IHZpZXdOYW1lOiBzdHJpbmcgPSB0aGlzLnZpZXdNb2RlLnRvTG93ZXJDYXNlKCk7XHJcbiAgICByZXR1cm4gYGN4LXByb2R1Y3QtJHt2aWV3TmFtZX1gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogICBEaXNwbGF5IGljb25zIGludmVyc2VseSB0byBhbGxvdyB1c2Vyc1xyXG4gICAqICAgdG8gc2VlIHRoZSB2aWV3IHRoZXkgd2lsbCBuYXZpZ2F0ZSB0b1xyXG4gICAqL1xyXG4gIGdldCB2aWV3TW9kZSgpIHtcclxuICAgIGlmICh0aGlzLm1vZGUgPT09ICdsaXN0Jykge1xyXG4gICAgICByZXR1cm4gdGhpcy5pY29uVHlwZXMuR1JJRDtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5tb2RlID09PSAnZ3JpZCcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaWNvblR5cGVzLkxJU1Q7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjaGFuZ2VNb2RlKCkge1xyXG4gICAgY29uc3QgbmV3TW9kZSA9XHJcbiAgICAgIHRoaXMubW9kZSA9PT0gVmlld01vZGVzLkdyaWQgPyBWaWV3TW9kZXMuTGlzdCA6IFZpZXdNb2Rlcy5HcmlkO1xyXG4gICAgdGhpcy5tb2RlQ2hhbmdlLmVtaXQobmV3TW9kZSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==