import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostListener, Input, Output, Renderer2, } from '@angular/core';
import { map } from 'rxjs/operators';
import { ICON_TYPE } from '../../../../misc/icon/icon.model';
import { FacetGroupCollapsedState } from '../facet.model';
import { FacetService } from '../services/facet.service';
let FacetListComponent = class FacetListComponent {
    constructor(facetService, elementRef, renderer) {
        this.facetService = facetService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        /** Emits when the list must close */
        this.closeList = new EventEmitter();
        /** The list of all facet and values related to the products in the list */
        this.facetList$ = this.facetService.facetList$;
        this.iconTypes = ICON_TYPE;
        this.dialogFocusConfig = {
            trap: true,
            block: true,
            focusOnEscape: true,
            autofocus: 'cx-facet',
        };
    }
    /**
     * Indicates that the facet navigation is rendered in dialog.
     */
    set isDialog(value) {
        this._isDialog = value;
        if (value) {
            this.renderer.addClass(document.body, 'modal-open');
        }
    }
    get isDialog() {
        return this._isDialog;
    }
    handleClick() {
        this.close();
    }
    /**
     * Toggles the facet group in case it is not expanded.
     */
    expandFacetGroup(facet, ref) {
        if (!ref.isExpanded) {
            this.facetService.toggle(facet, ref.isExpanded);
        }
    }
    /**
     * Indicates that the facet group has been expanded.
     */
    isExpanded(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.EXPANDED));
    }
    /**
     * Indicates that the facet group has been collapsed.
     */
    isCollapsed(facet) {
        return this.facetService
            .getState(facet)
            .pipe(map((value) => value.toggled === FacetGroupCollapsedState.COLLAPSED));
    }
    close(event) {
        this.renderer.removeClass(document.body, 'modal-open');
        this.closeList.emit(event);
    }
    block(event) {
        event.stopPropagation();
    }
};
FacetListComponent.ctorParameters = () => [
    { type: FacetService },
    { type: ElementRef },
    { type: Renderer2 }
];
__decorate([
    Input()
], FacetListComponent.prototype, "isDialog", null);
__decorate([
    Output()
], FacetListComponent.prototype, "closeList", void 0);
__decorate([
    HostListener('click')
], FacetListComponent.prototype, "handleClick", null);
FacetListComponent = __decorate([
    Component({
        selector: 'cx-facet-list',
        template: "<div\r\n  class=\"inner\"\r\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\r\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\r\n  (esc)=\"close($event)\"\r\n  (click)=\"block($event)\"\r\n>\r\n  <h4>\r\n    {{ 'productList.filterBy.label' | cxTranslate }}\r\n    <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"close()\">\r\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\r\n    </button>\r\n  </h4>\r\n\r\n  <!-- \r\n      Here we'd like to introduce configurable facet components, \r\n      either by using specific configuration or generic sproutlets \r\n  -->\r\n  <cx-facet\r\n    *ngFor=\"let facet of facets\"\r\n    #facetRef\r\n    [facet]=\"facet\"\r\n    [cxFocus]=\"{ lock: true, trap: true, autofocus: 'a' }\"\r\n    (unlock)=\"expandFacetGroup(facet, facetRef)\"\r\n    [class.expanded]=\"isExpanded(facet) | async\"\r\n    [class.collapsed]=\"isCollapsed(facet) | async\"\r\n  ></cx-facet>\r\n</div>\r\n",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], FacetListComponent);
export { FacetListComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjZXQtbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL3N0b3JlZnJvbnQvIiwic291cmNlcyI6WyJjbXMtY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QtbGlzdC9wcm9kdWN0LWZhY2V0LW5hdmlnYXRpb24vZmFjZXQtbGlzdC9mYWNldC1saXN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXJDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUM3RCxPQUFPLEVBQUUsd0JBQXdCLEVBQWEsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFPekQsSUFBYSxrQkFBa0IsR0FBL0IsTUFBYSxrQkFBa0I7SUFvQzdCLFlBQ1ksWUFBMEIsRUFDMUIsVUFBc0IsRUFDdEIsUUFBbUI7UUFGbkIsaUJBQVksR0FBWixZQUFZLENBQWM7UUFDMUIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBdEIvQixxQ0FBcUM7UUFDM0IsY0FBUyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFFekMsMkVBQTJFO1FBQzNFLGVBQVUsR0FBMEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUM7UUFFakUsY0FBUyxHQUFHLFNBQVMsQ0FBQztRQUV0QixzQkFBaUIsR0FBZ0I7WUFDL0IsSUFBSSxFQUFFLElBQUk7WUFDVixLQUFLLEVBQUUsSUFBSTtZQUNYLGFBQWEsRUFBRSxJQUFJO1lBQ25CLFNBQVMsRUFBRSxVQUFVO1NBQ3RCLENBQUM7SUFVQyxDQUFDO0lBdENKOztPQUVHO0lBRUgsSUFBSSxRQUFRLENBQUMsS0FBYztRQUN6QixJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztRQUN2QixJQUFJLEtBQUssRUFBRTtZQUNULElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7U0FDckQ7SUFDSCxDQUFDO0lBRUQsSUFBSSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDO0lBQ3hCLENBQUM7SUFpQnNCLFdBQVc7UUFDaEMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2YsQ0FBQztJQVFEOztPQUVHO0lBQ0gsZ0JBQWdCLENBQUMsS0FBWSxFQUFFLEdBQW1CO1FBQ2hELElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFO1lBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDakQ7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxVQUFVLENBQUMsS0FBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxZQUFZO2FBQ3JCLFFBQVEsQ0FBQyxLQUFLLENBQUM7YUFDZixJQUFJLENBQ0gsR0FBRyxDQUFDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxLQUFLLHdCQUF3QixDQUFDLFFBQVEsQ0FBQyxDQUNwRSxDQUFDO0lBQ04sQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVyxDQUFDLEtBQVk7UUFDdEIsT0FBTyxJQUFJLENBQUMsWUFBWTthQUNyQixRQUFRLENBQUMsS0FBSyxDQUFDO2FBQ2YsSUFBSSxDQUNILEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sS0FBSyx3QkFBd0IsQ0FBQyxTQUFTLENBQUMsQ0FDckUsQ0FBQztJQUNOLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBZTtRQUNuQixJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxDQUFDO1FBQ3ZELElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzdCLENBQUM7SUFFRCxLQUFLLENBQUMsS0FBa0I7UUFDdEIsS0FBSyxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQzFCLENBQUM7Q0FDRixDQUFBOztZQTVDMkIsWUFBWTtZQUNkLFVBQVU7WUFDWixTQUFTOztBQWpDL0I7SUFEQyxLQUFLLEVBQUU7a0RBTVA7QUFPUztJQUFULE1BQU0sRUFBRTtxREFBZ0M7QUFjbEI7SUFBdEIsWUFBWSxDQUFDLE9BQU8sQ0FBQztxREFFckI7QUFsQ1Usa0JBQWtCO0lBTDlCLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxlQUFlO1FBQ3pCLDQ5QkFBMEM7UUFDMUMsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07S0FDaEQsQ0FBQztHQUNXLGtCQUFrQixDQWlGOUI7U0FqRlksa0JBQWtCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDb21wb25lbnQsXHJcbiAgRWxlbWVudFJlZixcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgSG9zdExpc3RlbmVyLFxyXG4gIElucHV0LFxyXG4gIE91dHB1dCxcclxuICBSZW5kZXJlcjIsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IEZvY3VzQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vbGF5b3V0L2ExMXkva2V5Ym9hcmQtZm9jdXMvaW5kZXgnO1xyXG5pbXBvcnQgeyBJQ09OX1RZUEUgfSBmcm9tICcuLi8uLi8uLi8uLi9taXNjL2ljb24vaWNvbi5tb2RlbCc7XHJcbmltcG9ydCB7IEZhY2V0R3JvdXBDb2xsYXBzZWRTdGF0ZSwgRmFjZXRMaXN0IH0gZnJvbSAnLi4vZmFjZXQubW9kZWwnO1xyXG5pbXBvcnQgeyBGYWNldENvbXBvbmVudCB9IGZyb20gJy4uL2ZhY2V0L2ZhY2V0LmNvbXBvbmVudCc7XHJcbmltcG9ydCB7IEZhY2V0U2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL2ZhY2V0LnNlcnZpY2UnO1xyXG5cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdjeC1mYWNldC1saXN0JyxcclxuICB0ZW1wbGF0ZVVybDogJy4vZmFjZXQtbGlzdC5jb21wb25lbnQuaHRtbCcsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBGYWNldExpc3RDb21wb25lbnQge1xyXG4gIHByaXZhdGUgX2lzRGlhbG9nOiBib29sZWFuO1xyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSBmYWNldCBuYXZpZ2F0aW9uIGlzIHJlbmRlcmVkIGluIGRpYWxvZy5cclxuICAgKi9cclxuICBASW5wdXQoKVxyXG4gIHNldCBpc0RpYWxvZyh2YWx1ZTogYm9vbGVhbikge1xyXG4gICAgdGhpcy5faXNEaWFsb2cgPSB2YWx1ZTtcclxuICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdtb2RhbC1vcGVuJyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBnZXQgaXNEaWFsb2coKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5faXNEaWFsb2c7XHJcbiAgfVxyXG5cclxuICAvKiogRW1pdHMgd2hlbiB0aGUgbGlzdCBtdXN0IGNsb3NlICovXHJcbiAgQE91dHB1dCgpIGNsb3NlTGlzdCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgLyoqIFRoZSBsaXN0IG9mIGFsbCBmYWNldCBhbmQgdmFsdWVzIHJlbGF0ZWQgdG8gdGhlIHByb2R1Y3RzIGluIHRoZSBsaXN0ICovXHJcbiAgZmFjZXRMaXN0JDogT2JzZXJ2YWJsZTxGYWNldExpc3Q+ID0gdGhpcy5mYWNldFNlcnZpY2UuZmFjZXRMaXN0JDtcclxuXHJcbiAgaWNvblR5cGVzID0gSUNPTl9UWVBFO1xyXG5cclxuICBkaWFsb2dGb2N1c0NvbmZpZzogRm9jdXNDb25maWcgPSB7XHJcbiAgICB0cmFwOiB0cnVlLFxyXG4gICAgYmxvY2s6IHRydWUsXHJcbiAgICBmb2N1c09uRXNjYXBlOiB0cnVlLFxyXG4gICAgYXV0b2ZvY3VzOiAnY3gtZmFjZXQnLFxyXG4gIH07XHJcblxyXG4gIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJykgaGFuZGxlQ2xpY2soKSB7XHJcbiAgICB0aGlzLmNsb3NlKCk7XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByb3RlY3RlZCBmYWNldFNlcnZpY2U6IEZhY2V0U2VydmljZSxcclxuICAgIHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcjJcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRvZ2dsZXMgdGhlIGZhY2V0IGdyb3VwIGluIGNhc2UgaXQgaXMgbm90IGV4cGFuZGVkLlxyXG4gICAqL1xyXG4gIGV4cGFuZEZhY2V0R3JvdXAoZmFjZXQ6IEZhY2V0LCByZWY6IEZhY2V0Q29tcG9uZW50KSB7XHJcbiAgICBpZiAoIXJlZi5pc0V4cGFuZGVkKSB7XHJcbiAgICAgIHRoaXMuZmFjZXRTZXJ2aWNlLnRvZ2dsZShmYWNldCwgcmVmLmlzRXhwYW5kZWQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGZhY2V0IGdyb3VwIGhhcyBiZWVuIGV4cGFuZGVkLlxyXG4gICAqL1xyXG4gIGlzRXhwYW5kZWQoZmFjZXQ6IEZhY2V0KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5mYWNldFNlcnZpY2VcclxuICAgICAgLmdldFN0YXRlKGZhY2V0KVxyXG4gICAgICAucGlwZShcclxuICAgICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS50b2dnbGVkID09PSBGYWNldEdyb3VwQ29sbGFwc2VkU3RhdGUuRVhQQU5ERUQpXHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgZmFjZXQgZ3JvdXAgaGFzIGJlZW4gY29sbGFwc2VkLlxyXG4gICAqL1xyXG4gIGlzQ29sbGFwc2VkKGZhY2V0OiBGYWNldCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xyXG4gICAgcmV0dXJuIHRoaXMuZmFjZXRTZXJ2aWNlXHJcbiAgICAgIC5nZXRTdGF0ZShmYWNldClcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgbWFwKCh2YWx1ZSkgPT4gdmFsdWUudG9nZ2xlZCA9PT0gRmFjZXRHcm91cENvbGxhcHNlZFN0YXRlLkNPTExBUFNFRClcclxuICAgICAgKTtcclxuICB9XHJcblxyXG4gIGNsb3NlKGV2ZW50PzogYm9vbGVhbik6IHZvaWQge1xyXG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDbGFzcyhkb2N1bWVudC5ib2R5LCAnbW9kYWwtb3BlbicpO1xyXG4gICAgdGhpcy5jbG9zZUxpc3QuZW1pdChldmVudCk7XHJcbiAgfVxyXG5cclxuICBibG9jayhldmVudD86IE1vdXNlRXZlbnQpIHtcclxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gIH1cclxufVxyXG4iXX0=