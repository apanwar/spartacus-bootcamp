import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, Input } from '@angular/core';
import { BaseOption, Product, RoutingService, VariantOptionQualifier, VariantQualifier, } from '@spartacus/core';
let VariantColorSelectorComponent = class VariantColorSelectorComponent {
    constructor(routingService) {
        this.routingService = routingService;
    }
    changeColor(code, name) {
        if (code) {
            this.routingService.go({
                cxRoute: 'product',
                params: { code, name },
            });
        }
        return null;
    }
    getVariantOptionValue(qualifiers) {
        const obj = qualifiers.find((q) => q.qualifier === VariantQualifier.COLOR);
        return obj ? obj.value : '';
    }
};
VariantColorSelectorComponent.ctorParameters = () => [
    { type: RoutingService }
];
__decorate([
    Input()
], VariantColorSelectorComponent.prototype, "product", void 0);
__decorate([
    Input()
], VariantColorSelectorComponent.prototype, "variants", void 0);
VariantColorSelectorComponent = __decorate([
    Component({
        selector: 'cx-variant-color-selector',
        template: "<ng-container>\n  <div class=\"variant-selector\">\n    <div class=\"variant-name\">{{ 'variant.color' | cxTranslate }}:</div>\n\n    <select\n      (change)=\"changeColor($event.target.value, product?.name)\"\n      class=\"form-control variant-select\"\n    >\n      <option\n        *ngFor=\"let v of variants?.options\"\n        value=\"{{ v.code }}\"\n        [selected]=\"v.code === product?.code\"\n        >{{ getVariantOptionValue(v.variantOptionQualifiers) }}</option\n      >\n    </select>\n  </div>\n</ng-container>\n",
        changeDetection: ChangeDetectionStrategy.OnPush
    })
], VariantColorSelectorComponent);
export { VariantColorSelectorComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFyaWFudC1jb2xvci1zZWxlY3Rvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL3N0b3JlZnJvbnQvIiwic291cmNlcyI6WyJjbXMtY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QtdmFyaWFudHMvdmFyaWFudC1jb2xvci1zZWxlY3Rvci92YXJpYW50LWNvbG9yLXNlbGVjdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDMUUsT0FBTyxFQUNMLFVBQVUsRUFDVixPQUFPLEVBQ1AsY0FBYyxFQUNkLHNCQUFzQixFQUN0QixnQkFBZ0IsR0FDakIsTUFBTSxpQkFBaUIsQ0FBQztBQU96QixJQUFhLDZCQUE2QixHQUExQyxNQUFhLDZCQUE2QjtJQUN4QyxZQUFvQixjQUE4QjtRQUE5QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7SUFBRyxDQUFDO0lBUXRELFdBQVcsQ0FBQyxJQUFZLEVBQUUsSUFBWTtRQUNwQyxJQUFJLElBQUksRUFBRTtZQUNSLElBQUksQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDO2dCQUNyQixPQUFPLEVBQUUsU0FBUztnQkFDbEIsTUFBTSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRTthQUN2QixDQUFDLENBQUM7U0FDSjtRQUNELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztJQUNELHFCQUFxQixDQUFDLFVBQW9DO1FBQ3hELE1BQU0sR0FBRyxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLEtBQUssZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0UsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUM5QixDQUFDO0NBQ0YsQ0FBQTs7WUFyQnFDLGNBQWM7O0FBR2xEO0lBREMsS0FBSyxFQUFFOzhEQUNTO0FBR2pCO0lBREMsS0FBSyxFQUFFOytEQUNhO0FBUFYsNkJBQTZCO0lBTHpDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSwyQkFBMkI7UUFDckMsOGhCQUFzRDtRQUN0RCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtLQUNoRCxDQUFDO0dBQ1csNkJBQTZCLENBc0J6QztTQXRCWSw2QkFBNkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSwgQ29tcG9uZW50LCBJbnB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIEJhc2VPcHRpb24sXHJcbiAgUHJvZHVjdCxcclxuICBSb3V0aW5nU2VydmljZSxcclxuICBWYXJpYW50T3B0aW9uUXVhbGlmaWVyLFxyXG4gIFZhcmlhbnRRdWFsaWZpZXIsXHJcbn0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnY3gtdmFyaWFudC1jb2xvci1zZWxlY3RvcicsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL3ZhcmlhbnQtY29sb3Itc2VsZWN0b3IuY29tcG9uZW50Lmh0bWwnLFxyXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgVmFyaWFudENvbG9yU2VsZWN0b3JDb21wb25lbnQge1xyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcm91dGluZ1NlcnZpY2U6IFJvdXRpbmdTZXJ2aWNlKSB7fVxyXG5cclxuICBASW5wdXQoKVxyXG4gIHByb2R1Y3Q6IFByb2R1Y3Q7XHJcblxyXG4gIEBJbnB1dCgpXHJcbiAgdmFyaWFudHM6IEJhc2VPcHRpb247XHJcblxyXG4gIGNoYW5nZUNvbG9yKGNvZGU6IHN0cmluZywgbmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgICBpZiAoY29kZSkge1xyXG4gICAgICB0aGlzLnJvdXRpbmdTZXJ2aWNlLmdvKHtcclxuICAgICAgICBjeFJvdXRlOiAncHJvZHVjdCcsXHJcbiAgICAgICAgcGFyYW1zOiB7IGNvZGUsIG5hbWUgfSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbiAgZ2V0VmFyaWFudE9wdGlvblZhbHVlKHF1YWxpZmllcnM6IFZhcmlhbnRPcHRpb25RdWFsaWZpZXJbXSkge1xyXG4gICAgY29uc3Qgb2JqID0gcXVhbGlmaWVycy5maW5kKChxKSA9PiBxLnF1YWxpZmllciA9PT0gVmFyaWFudFF1YWxpZmllci5DT0xPUik7XHJcbiAgICByZXR1cm4gb2JqID8gb2JqLnZhbHVlIDogJyc7XHJcbiAgfVxyXG59XHJcbiJdfQ==