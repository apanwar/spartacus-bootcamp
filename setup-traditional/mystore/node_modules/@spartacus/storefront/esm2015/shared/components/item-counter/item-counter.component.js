import { __decorate } from "tslib";
import { Component, HostBinding, HostListener, Input, ViewChild, } from '@angular/core';
import { startWith } from 'rxjs/operators';
/**
 * Provides a UI to manage the count of the quantity, typically by using
 * increase and decrease functionality. The item counter expects an input `FormControl`
 * so that the state of the control can be managed outside of this component.
 */
let ItemCounterComponent = class ItemCounterComponent {
    constructor() {
        /**
         * This can be used in case an item has a minmum order quantity.
         * @default 1
         */
        this.min = 1;
        /**
         * The step is used to increment the count. It is supposed to be a
         * positive integer or float.
         * @default 1
         */
        this.step = 1;
        /**
         * Indicates that the input can be manually set to zero,
         * despite the fact that the input controls will be limited to
         * the minimum. The zero value can be used to remove an item.
         */
        this.allowZero = false;
        /**
         * In readonly mode the item counter will only be shown as a label,
         * the form controls are not rendered.
         * Please not that readonly is different from the `disabled` form state.
         * @default false
         */
        this.readonly = false;
    }
    handleClick() {
        this.input.nativeElement.focus();
    }
    ngOnInit() {
        this.sub = this.control.valueChanges
            .pipe(startWith(this.control.value))
            .subscribe((value) => this.control.setValue(this.getValidCount(value), { emitEvent: false }));
    }
    ngOnDestroy() {
        if (this.sub) {
            this.sub.unsubscribe();
        }
    }
    increment() {
        // it's too early to use the `stepUp` and `stepDown` API...
        // let's wait for FF: https://caniuse.com/#search=stepUp
        this.control.setValue(this.control.value + this.step);
        this.control.markAsDirty();
    }
    decrement() {
        this.control.setValue(this.control.value - this.step);
        this.control.markAsDirty();
    }
    /**
     * Validate that the given value is in between
     * the `min` and `max` value. If the value is out
     * of  the min/max range, it will be altered.
     * If `allowZero` is set to true, the 0 value is ignored.
     *
     */
    getValidCount(value) {
        if (value < this.min && !(value === 0 && this.allowZero)) {
            value = this.min;
        }
        if (this.max && value > this.max) {
            value = this.max;
        }
        return value;
    }
};
__decorate([
    Input()
], ItemCounterComponent.prototype, "control", void 0);
__decorate([
    Input()
], ItemCounterComponent.prototype, "min", void 0);
__decorate([
    Input()
], ItemCounterComponent.prototype, "max", void 0);
__decorate([
    Input()
], ItemCounterComponent.prototype, "step", void 0);
__decorate([
    Input()
], ItemCounterComponent.prototype, "allowZero", void 0);
__decorate([
    HostBinding('class.readonly'), Input()
], ItemCounterComponent.prototype, "readonly", void 0);
__decorate([
    ViewChild('qty')
], ItemCounterComponent.prototype, "input", void 0);
__decorate([
    HostListener('click')
], ItemCounterComponent.prototype, "handleClick", null);
ItemCounterComponent = __decorate([
    Component({
        selector: 'cx-item-counter',
        template: "<button\r\n  type=\"button\"\r\n  (click)=\"decrement()\"\r\n  [disabled]=\"control.disabled || control.value <= min\"\r\n  tabindex=\"-1\"\r\n>\r\n  -\r\n</button>\r\n\r\n<input\r\n  #qty\r\n  type=\"number\"\r\n  [min]=\"min\"\r\n  [max]=\"max\"\r\n  [step]=\"step\"\r\n  [readonly]=\"readonly\"\r\n  [formControl]=\"control\"\r\n/>\r\n\r\n<button\r\n  type=\"button\"\r\n  (click)=\"increment()\"\r\n  [disabled]=\"control.disabled || control.value >= max\"\r\n  tabindex=\"-1\"\r\n>\r\n  +\r\n</button>\r\n"
    })
], ItemCounterComponent);
export { ItemCounterComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaXRlbS1jb3VudGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbInNoYXJlZC9jb21wb25lbnRzL2l0ZW0tY291bnRlci9pdGVtLWNvdW50ZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUVULFdBQVcsRUFDWCxZQUFZLEVBQ1osS0FBSyxFQUdMLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0M7Ozs7R0FJRztBQVNILElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQW9CO0lBQWpDO1FBT0U7OztXQUdHO1FBQ00sUUFBRyxHQUFHLENBQUMsQ0FBQztRQU9qQjs7OztXQUlHO1FBQ00sU0FBSSxHQUFHLENBQUMsQ0FBQztRQUVsQjs7OztXQUlHO1FBQ00sY0FBUyxHQUFHLEtBQUssQ0FBQztRQUUzQjs7Ozs7V0FLRztRQUNxQyxhQUFRLEdBQUcsS0FBSyxDQUFDO0lBdUQzRCxDQUFDO0lBOUN3QixXQUFXO1FBQ2hDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ25DLENBQUM7SUFFRCxRQUFRO1FBQ04sSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFlBQVk7YUFDakMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ25DLFNBQVMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQ25CLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FDdkUsQ0FBQztJQUNOLENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1osSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUN4QjtJQUNILENBQUM7SUFFRCxTQUFTO1FBQ1AsMkRBQTJEO1FBQzNELHdEQUF3RDtRQUN4RCxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEQsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQztJQUM3QixDQUFDO0lBRUQsU0FBUztRQUNQLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUN0RCxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzdCLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxhQUFhLENBQUMsS0FBYTtRQUNqQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRTtZQUN4RCxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUNsQjtRQUNELElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNoQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztTQUNsQjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztDQUNGLENBQUE7QUF4RlU7SUFBUixLQUFLLEVBQUU7cURBQXNCO0FBTXJCO0lBQVIsS0FBSyxFQUFFO2lEQUFTO0FBS1I7SUFBUixLQUFLLEVBQUU7aURBQWE7QUFPWjtJQUFSLEtBQUssRUFBRTtrREFBVTtBQU9UO0lBQVIsS0FBSyxFQUFFO3VEQUFtQjtBQVFhO0lBQXZDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxFQUFFLEtBQUssRUFBRTtzREFBa0I7QUFFdkM7SUFBakIsU0FBUyxDQUFDLEtBQUssQ0FBQzttREFBNkM7QUFPdkM7SUFBdEIsWUFBWSxDQUFDLE9BQU8sQ0FBQzt1REFFckI7QUFqRFUsb0JBQW9CO0lBUmhDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSxpQkFBaUI7UUFDM0IsMGdCQUE0QztLQUs3QyxDQUFDO0dBQ1csb0JBQW9CLENBNkZoQztTQTdGWSxvQkFBb0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENvbXBvbmVudCxcclxuICBFbGVtZW50UmVmLFxyXG4gIEhvc3RCaW5kaW5nLFxyXG4gIEhvc3RMaXN0ZW5lcixcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT25Jbml0LFxyXG4gIFZpZXdDaGlsZCxcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBzdGFydFdpdGggfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYSBVSSB0byBtYW5hZ2UgdGhlIGNvdW50IG9mIHRoZSBxdWFudGl0eSwgdHlwaWNhbGx5IGJ5IHVzaW5nXHJcbiAqIGluY3JlYXNlIGFuZCBkZWNyZWFzZSBmdW5jdGlvbmFsaXR5LiBUaGUgaXRlbSBjb3VudGVyIGV4cGVjdHMgYW4gaW5wdXQgYEZvcm1Db250cm9sYFxyXG4gKiBzbyB0aGF0IHRoZSBzdGF0ZSBvZiB0aGUgY29udHJvbCBjYW4gYmUgbWFuYWdlZCBvdXRzaWRlIG9mIHRoaXMgY29tcG9uZW50LlxyXG4gKi9cclxuQENvbXBvbmVudCh7XHJcbiAgc2VsZWN0b3I6ICdjeC1pdGVtLWNvdW50ZXInLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi9pdGVtLWNvdW50ZXIuY29tcG9uZW50Lmh0bWwnLFxyXG4gIC8vIGRvIG5vdCB1c2UgT25QdXNoIGNoYW5nZSBkZXRlY3Rpb24gc3RyYXRlZ3kgYXMgd2Ugd291bGQgbm90XHJcbiAgLy8gZ2V0IHVwZGF0ZXMgb2Ygb3RoZXIgZm9ybSBjb250cm9sIHN0YXRlIChkaXNhYmxlZCkuIFdlIHdhbnQgdG8gaGF2ZSBhXHJcbiAgLy8gZGlzYWJsZWQgc3RhdGUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgdGhlIGNvbnRyb2wgY2Fubm90IGJlIHVzZWQgd2hpbGVcclxuICAvLyB0aGUgY2FydCBpcyB1cGRhdGVkLlxyXG59KVxyXG5leHBvcnQgY2xhc3MgSXRlbUNvdW50ZXJDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcbiAgLyoqXHJcbiAgICogSG9sZHMgdGhlIHZhbHVlIG9mIHRoZSBjb3VudGVyLCB0aGUgc3RhdGUgb2YgdGhlIGBGb3JtQ29udHJvbGBcclxuICAgKiBjYW4gYmUgbWFuYWdlZCBvdXRzaWRlIG9mIHRoZSBpdGVtIGNvdW50ZXIuXHJcbiAgICovXHJcbiAgQElucHV0KCkgY29udHJvbDogRm9ybUNvbnRyb2w7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgY2FuIGJlIHVzZWQgaW4gY2FzZSBhbiBpdGVtIGhhcyBhIG1pbm11bSBvcmRlciBxdWFudGl0eS5cclxuICAgKiBAZGVmYXVsdCAxXHJcbiAgICovXHJcbiAgQElucHV0KCkgbWluID0gMTtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhpcyBjYW4gYmUgdXNlZCBpbiBjYXNlIGFuIGl0ZW0gaGFzIGEgbWF4aW11bSBvcmRlciBxdWFudGl0eS5cclxuICAgKi9cclxuICBASW5wdXQoKSBtYXg6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIHN0ZXAgaXMgdXNlZCB0byBpbmNyZW1lbnQgdGhlIGNvdW50LiBJdCBpcyBzdXBwb3NlZCB0byBiZSBhXHJcbiAgICogcG9zaXRpdmUgaW50ZWdlciBvciBmbG9hdC5cclxuICAgKiBAZGVmYXVsdCAxXHJcbiAgICovXHJcbiAgQElucHV0KCkgc3RlcCA9IDE7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSBpbnB1dCBjYW4gYmUgbWFudWFsbHkgc2V0IHRvIHplcm8sXHJcbiAgICogZGVzcGl0ZSB0aGUgZmFjdCB0aGF0IHRoZSBpbnB1dCBjb250cm9scyB3aWxsIGJlIGxpbWl0ZWQgdG9cclxuICAgKiB0aGUgbWluaW11bS4gVGhlIHplcm8gdmFsdWUgY2FuIGJlIHVzZWQgdG8gcmVtb3ZlIGFuIGl0ZW0uXHJcbiAgICovXHJcbiAgQElucHV0KCkgYWxsb3daZXJvID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluIHJlYWRvbmx5IG1vZGUgdGhlIGl0ZW0gY291bnRlciB3aWxsIG9ubHkgYmUgc2hvd24gYXMgYSBsYWJlbCxcclxuICAgKiB0aGUgZm9ybSBjb250cm9scyBhcmUgbm90IHJlbmRlcmVkLlxyXG4gICAqIFBsZWFzZSBub3QgdGhhdCByZWFkb25seSBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYGRpc2FibGVkYCBmb3JtIHN0YXRlLlxyXG4gICAqIEBkZWZhdWx0IGZhbHNlXHJcbiAgICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5yZWFkb25seScpIEBJbnB1dCgpIHJlYWRvbmx5ID0gZmFsc2U7XHJcblxyXG4gIEBWaWV3Q2hpbGQoJ3F0eScpIHByaXZhdGUgaW5wdXQ6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnNjcmlwdGlvbiByZXNwb25zaWJsZSBmb3IgYXV0by1jb3JyZWN0aW5nIGNvbnRyb2wncyB2YWx1ZSB3aGVuIGl0J3MgaW52YWxpZC5cclxuICAgKi9cclxuICBwcml2YXRlIHN1YjogU3Vic2NyaXB0aW9uO1xyXG5cclxuICBASG9zdExpc3RlbmVyKCdjbGljaycpIGhhbmRsZUNsaWNrKCkge1xyXG4gICAgdGhpcy5pbnB1dC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgfVxyXG5cclxuICBuZ09uSW5pdCgpIHtcclxuICAgIHRoaXMuc3ViID0gdGhpcy5jb250cm9sLnZhbHVlQ2hhbmdlc1xyXG4gICAgICAucGlwZShzdGFydFdpdGgodGhpcy5jb250cm9sLnZhbHVlKSlcclxuICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+XHJcbiAgICAgICAgdGhpcy5jb250cm9sLnNldFZhbHVlKHRoaXMuZ2V0VmFsaWRDb3VudCh2YWx1ZSksIHsgZW1pdEV2ZW50OiBmYWxzZSB9KVxyXG4gICAgICApO1xyXG4gIH1cclxuXHJcbiAgbmdPbkRlc3Ryb3koKSB7XHJcbiAgICBpZiAodGhpcy5zdWIpIHtcclxuICAgICAgdGhpcy5zdWIudW5zdWJzY3JpYmUoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGluY3JlbWVudCgpIHtcclxuICAgIC8vIGl0J3MgdG9vIGVhcmx5IHRvIHVzZSB0aGUgYHN0ZXBVcGAgYW5kIGBzdGVwRG93bmAgQVBJLi4uXHJcbiAgICAvLyBsZXQncyB3YWl0IGZvciBGRjogaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXN0ZXBVcFxyXG4gICAgdGhpcy5jb250cm9sLnNldFZhbHVlKHRoaXMuY29udHJvbC52YWx1ZSArIHRoaXMuc3RlcCk7XHJcbiAgICB0aGlzLmNvbnRyb2wubWFya0FzRGlydHkoKTtcclxuICB9XHJcblxyXG4gIGRlY3JlbWVudCgpIHtcclxuICAgIHRoaXMuY29udHJvbC5zZXRWYWx1ZSh0aGlzLmNvbnRyb2wudmFsdWUgLSB0aGlzLnN0ZXApO1xyXG4gICAgdGhpcy5jb250cm9sLm1hcmtBc0RpcnR5KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBWYWxpZGF0ZSB0aGF0IHRoZSBnaXZlbiB2YWx1ZSBpcyBpbiBiZXR3ZWVuXHJcbiAgICogdGhlIGBtaW5gIGFuZCBgbWF4YCB2YWx1ZS4gSWYgdGhlIHZhbHVlIGlzIG91dFxyXG4gICAqIG9mICB0aGUgbWluL21heCByYW5nZSwgaXQgd2lsbCBiZSBhbHRlcmVkLlxyXG4gICAqIElmIGBhbGxvd1plcm9gIGlzIHNldCB0byB0cnVlLCB0aGUgMCB2YWx1ZSBpcyBpZ25vcmVkLlxyXG4gICAqXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRWYWxpZENvdW50KHZhbHVlOiBudW1iZXIpIHtcclxuICAgIGlmICh2YWx1ZSA8IHRoaXMubWluICYmICEodmFsdWUgPT09IDAgJiYgdGhpcy5hbGxvd1plcm8pKSB7XHJcbiAgICAgIHZhbHVlID0gdGhpcy5taW47XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5tYXggJiYgdmFsdWUgPiB0aGlzLm1heCkge1xyXG4gICAgICB2YWx1ZSA9IHRoaXMubWF4O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG4gIH1cclxufVxyXG4iXX0=