import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { WindowRef } from '@spartacus/core';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
let CarouselService = class CarouselService {
    constructor(winRef) {
        this.winRef = winRef;
    }
    /**
     * The number of items per slide is calculated by the help of
     * the item width and the available width of the host element.
     * This appoach makes it possible to place the carousel in different
     * layouts. Instead of using the page breakpoints, the host size is
     * taken into account.
     *
     * Since there's no element resize API available, we use the
     * window `resize` event, so that we can adjust the number of items
     * whenever the window got resized.
     */
    getItemsPerSlide(nativeElement, itemWidth) {
        return this.winRef.resize$.pipe(map(() => nativeElement.clientWidth), map((totalWidth) => this.calculateItems(totalWidth, itemWidth)));
    }
    /**
     * Calculates the number of items per given hostSize.  calculated based on the given
     * intended size in pixels or percentages. The
     *
     * @param availableWidth The available width in pixels for the carousel items.
     * @param itemWidth The width per carousel item, in px or percentage.
     */
    calculateItems(availableWidth, itemWidth) {
        let calculatedItems = 0;
        if (itemWidth.endsWith('px')) {
            const num = itemWidth.substring(0, itemWidth.length - 2);
            calculatedItems = availableWidth / num;
        }
        if (itemWidth.endsWith('%')) {
            const perc = itemWidth.substring(0, itemWidth.length - 1);
            calculatedItems =
                availableWidth / (availableWidth * (perc / 100));
        }
        return Math.floor(calculatedItems) || 1;
    }
};
CarouselService.ctorParameters = () => [
    { type: WindowRef }
];
CarouselService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CarouselService_Factory() { return new CarouselService(i0.ɵɵinject(i1.WindowRef)); }, token: CarouselService, providedIn: "root" });
CarouselService = __decorate([
    Injectable({
        providedIn: 'root',
    })
], CarouselService);
export { CarouselService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2Fyb3VzZWwuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbInNoYXJlZC9jb21wb25lbnRzL2Nhcm91c2VsL2Nhcm91c2VsLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTVDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBS3JDLElBQWEsZUFBZSxHQUE1QixNQUFhLGVBQWU7SUFDMUIsWUFBb0IsTUFBaUI7UUFBakIsV0FBTSxHQUFOLE1BQU0sQ0FBVztJQUFHLENBQUM7SUFFekM7Ozs7Ozs7Ozs7T0FVRztJQUNILGdCQUFnQixDQUNkLGFBQTBCLEVBQzFCLFNBQWlCO1FBRWpCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUM3QixHQUFHLENBQUMsR0FBRyxFQUFFLENBQUUsYUFBNkIsQ0FBQyxXQUFXLENBQUMsRUFDckQsR0FBRyxDQUFDLENBQUMsVUFBVSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsRUFBRSxTQUFTLENBQUMsQ0FBQyxDQUNoRSxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNLLGNBQWMsQ0FBQyxjQUFzQixFQUFFLFNBQWlCO1FBQzlELElBQUksZUFBZSxHQUFHLENBQUMsQ0FBQztRQUN4QixJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDNUIsTUFBTSxHQUFHLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUN6RCxlQUFlLEdBQUcsY0FBYyxHQUFpQixHQUFJLENBQUM7U0FDdkQ7UUFFRCxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDM0IsTUFBTSxJQUFJLEdBQUcsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUMxRCxlQUFlO2dCQUNiLGNBQWMsR0FBRyxDQUFDLGNBQWMsR0FBRyxDQUFlLElBQUssR0FBRyxHQUFHLENBQUMsQ0FBQyxDQUFDO1NBQ25FO1FBRUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQyxDQUFDO0NBQ0YsQ0FBQTs7WUE3QzZCLFNBQVM7OztBQUQxQixlQUFlO0lBSDNCLFVBQVUsQ0FBQztRQUNWLFVBQVUsRUFBRSxNQUFNO0tBQ25CLENBQUM7R0FDVyxlQUFlLENBOEMzQjtTQTlDWSxlQUFlIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBXaW5kb3dSZWYgfSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDYXJvdXNlbFNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgd2luUmVmOiBXaW5kb3dSZWYpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgcGVyIHNsaWRlIGlzIGNhbGN1bGF0ZWQgYnkgdGhlIGhlbHAgb2ZcclxuICAgKiB0aGUgaXRlbSB3aWR0aCBhbmQgdGhlIGF2YWlsYWJsZSB3aWR0aCBvZiB0aGUgaG9zdCBlbGVtZW50LlxyXG4gICAqIFRoaXMgYXBwb2FjaCBtYWtlcyBpdCBwb3NzaWJsZSB0byBwbGFjZSB0aGUgY2Fyb3VzZWwgaW4gZGlmZmVyZW50XHJcbiAgICogbGF5b3V0cy4gSW5zdGVhZCBvZiB1c2luZyB0aGUgcGFnZSBicmVha3BvaW50cywgdGhlIGhvc3Qgc2l6ZSBpc1xyXG4gICAqIHRha2VuIGludG8gYWNjb3VudC5cclxuICAgKlxyXG4gICAqIFNpbmNlIHRoZXJlJ3Mgbm8gZWxlbWVudCByZXNpemUgQVBJIGF2YWlsYWJsZSwgd2UgdXNlIHRoZVxyXG4gICAqIHdpbmRvdyBgcmVzaXplYCBldmVudCwgc28gdGhhdCB3ZSBjYW4gYWRqdXN0IHRoZSBudW1iZXIgb2YgaXRlbXNcclxuICAgKiB3aGVuZXZlciB0aGUgd2luZG93IGdvdCByZXNpemVkLlxyXG4gICAqL1xyXG4gIGdldEl0ZW1zUGVyU2xpZGUoXHJcbiAgICBuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCxcclxuICAgIGl0ZW1XaWR0aDogc3RyaW5nXHJcbiAgKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgIHJldHVybiB0aGlzLndpblJlZi5yZXNpemUkLnBpcGUoXHJcbiAgICAgIG1hcCgoKSA9PiAobmF0aXZlRWxlbWVudCBhcyBIVE1MRWxlbWVudCkuY2xpZW50V2lkdGgpLFxyXG4gICAgICBtYXAoKHRvdGFsV2lkdGgpID0+IHRoaXMuY2FsY3VsYXRlSXRlbXModG90YWxXaWR0aCwgaXRlbVdpZHRoKSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgaXRlbXMgcGVyIGdpdmVuIGhvc3RTaXplLiAgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgZ2l2ZW5cclxuICAgKiBpbnRlbmRlZCBzaXplIGluIHBpeGVscyBvciBwZXJjZW50YWdlcy4gVGhlXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYXZhaWxhYmxlV2lkdGggVGhlIGF2YWlsYWJsZSB3aWR0aCBpbiBwaXhlbHMgZm9yIHRoZSBjYXJvdXNlbCBpdGVtcy5cclxuICAgKiBAcGFyYW0gaXRlbVdpZHRoIFRoZSB3aWR0aCBwZXIgY2Fyb3VzZWwgaXRlbSwgaW4gcHggb3IgcGVyY2VudGFnZS5cclxuICAgKi9cclxuICBwcml2YXRlIGNhbGN1bGF0ZUl0ZW1zKGF2YWlsYWJsZVdpZHRoOiBudW1iZXIsIGl0ZW1XaWR0aDogc3RyaW5nKSB7XHJcbiAgICBsZXQgY2FsY3VsYXRlZEl0ZW1zID0gMDtcclxuICAgIGlmIChpdGVtV2lkdGguZW5kc1dpdGgoJ3B4JykpIHtcclxuICAgICAgY29uc3QgbnVtID0gaXRlbVdpZHRoLnN1YnN0cmluZygwLCBpdGVtV2lkdGgubGVuZ3RoIC0gMik7XHJcbiAgICAgIGNhbGN1bGF0ZWRJdGVtcyA9IGF2YWlsYWJsZVdpZHRoIC8gPG51bWJlcj4oPGFueT5udW0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpdGVtV2lkdGguZW5kc1dpdGgoJyUnKSkge1xyXG4gICAgICBjb25zdCBwZXJjID0gaXRlbVdpZHRoLnN1YnN0cmluZygwLCBpdGVtV2lkdGgubGVuZ3RoIC0gMSk7XHJcbiAgICAgIGNhbGN1bGF0ZWRJdGVtcyA9XHJcbiAgICAgICAgYXZhaWxhYmxlV2lkdGggLyAoYXZhaWxhYmxlV2lkdGggKiAoPG51bWJlcj4oPGFueT5wZXJjKSAvIDEwMCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLmZsb29yKGNhbGN1bGF0ZWRJdGVtcykgfHwgMTtcclxuICB9XHJcbn1cclxuIl19