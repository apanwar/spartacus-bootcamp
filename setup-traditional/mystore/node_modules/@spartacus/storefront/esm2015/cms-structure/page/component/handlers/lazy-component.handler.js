import { __decorate } from "tslib";
import { Injectable, } from '@angular/core';
import { from } from 'rxjs';
import { DefaultComponentHandler } from './default-component.handler';
import { switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./default-component.handler";
/**
 * Lazy component handler used for launching lazy loaded cms components implemented
 * as native Angular components.
 */
let LazyComponentHandler = class LazyComponentHandler {
    constructor(defaultHandler) {
        this.defaultHandler = defaultHandler;
    }
    /**
     * We want to mach dynamic import signature () => import('')
     */
    hasMatch(componentMapping) {
        return (typeof componentMapping.component === 'function' &&
            this.isNotClass(componentMapping.component));
    }
    isNotClass(symbol) {
        const signature = symbol.toString().substr(0, 20).replace(' ', '');
        return signature.startsWith('function()') || signature.startsWith('()=>');
    }
    getPriority() {
        return -10 /* LOW */;
    }
    launcher(componentMapping, viewContainerRef, elementInjector) {
        return from(componentMapping.component()).pipe(switchMap((component) => this.defaultHandler.launcher(Object.assign(Object.assign({}, componentMapping), { component }), viewContainerRef, elementInjector)));
    }
};
LazyComponentHandler.ctorParameters = () => [
    { type: DefaultComponentHandler }
];
LazyComponentHandler.ɵprov = i0.ɵɵdefineInjectable({ factory: function LazyComponentHandler_Factory() { return new LazyComponentHandler(i0.ɵɵinject(i1.DefaultComponentHandler)); }, token: LazyComponentHandler, providedIn: "root" });
LazyComponentHandler = __decorate([
    Injectable({
        providedIn: 'root',
    })
], LazyComponentHandler);
export { LazyComponentHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS1jb21wb25lbnQuaGFuZGxlci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbImNtcy1zdHJ1Y3R1cmUvcGFnZS9jb21wb25lbnQvaGFuZGxlcnMvbGF6eS1jb21wb25lbnQuaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUdMLFVBQVUsR0FHWCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsSUFBSSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7O0FBRzNDOzs7R0FHRztBQUlILElBQWEsb0JBQW9CLEdBQWpDLE1BQWEsb0JBQW9CO0lBQy9CLFlBQXNCLGNBQXVDO1FBQXZDLG1CQUFjLEdBQWQsY0FBYyxDQUF5QjtJQUFHLENBQUM7SUFFakU7O09BRUc7SUFDSCxRQUFRLENBQUMsZ0JBQXFDO1FBQzVDLE9BQU8sQ0FDTCxPQUFPLGdCQUFnQixDQUFDLFNBQVMsS0FBSyxVQUFVO1lBQ2hELElBQUksQ0FBQyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQzVDLENBQUM7SUFDSixDQUFDO0lBRU8sVUFBVSxDQUFDLE1BQVc7UUFDNUIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUNuRSxPQUFPLFNBQVMsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLElBQUksU0FBUyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBRUQsV0FBVztRQUNULHFCQUFvQjtJQUN0QixDQUFDO0lBRUQsUUFBUSxDQUNOLGdCQUFxQyxFQUNyQyxnQkFBa0MsRUFDbEMsZUFBMEI7UUFFMUIsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQzVDLFNBQVMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLENBQ3RCLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxpQ0FDckIsZ0JBQWdCLEtBQUUsU0FBUyxLQUNoQyxnQkFBZ0IsRUFDaEIsZUFBZSxDQUNoQixDQUNGLENBQ0YsQ0FBQztJQUNKLENBQUM7Q0FDRixDQUFBOztZQXBDdUMsdUJBQXVCOzs7QUFEbEQsb0JBQW9CO0lBSGhDLFVBQVUsQ0FBQztRQUNWLFVBQVUsRUFBRSxNQUFNO0tBQ25CLENBQUM7R0FDVyxvQkFBb0IsQ0FxQ2hDO1NBckNZLG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XHJcbiAgQ29tcG9uZW50UmVmLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgSW5qZWN0YWJsZSxcclxuICBJbmplY3RvcixcclxuICBWaWV3Q29udGFpbmVyUmVmLFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBDbXNDb21wb25lbnRNYXBwaW5nLCBQcmlvcml0eSB9IGZyb20gJ0BzcGFydGFjdXMvY29yZSc7XHJcbmltcG9ydCB7IGZyb20sIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgRGVmYXVsdENvbXBvbmVudEhhbmRsZXIgfSBmcm9tICcuL2RlZmF1bHQtY29tcG9uZW50LmhhbmRsZXInO1xyXG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IENvbXBvbmVudEhhbmRsZXIgfSBmcm9tICcuL2NvbXBvbmVudC1oYW5kbGVyJztcclxuXHJcbi8qKlxyXG4gKiBMYXp5IGNvbXBvbmVudCBoYW5kbGVyIHVzZWQgZm9yIGxhdW5jaGluZyBsYXp5IGxvYWRlZCBjbXMgY29tcG9uZW50cyBpbXBsZW1lbnRlZFxyXG4gKiBhcyBuYXRpdmUgQW5ndWxhciBjb21wb25lbnRzLlxyXG4gKi9cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIExhenlDb21wb25lbnRIYW5kbGVyIGltcGxlbWVudHMgQ29tcG9uZW50SGFuZGxlciB7XHJcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGRlZmF1bHRIYW5kbGVyOiBEZWZhdWx0Q29tcG9uZW50SGFuZGxlcikge31cclxuXHJcbiAgLyoqXHJcbiAgICogV2Ugd2FudCB0byBtYWNoIGR5bmFtaWMgaW1wb3J0IHNpZ25hdHVyZSAoKSA9PiBpbXBvcnQoJycpXHJcbiAgICovXHJcbiAgaGFzTWF0Y2goY29tcG9uZW50TWFwcGluZzogQ21zQ29tcG9uZW50TWFwcGluZyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdHlwZW9mIGNvbXBvbmVudE1hcHBpbmcuY29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmXHJcbiAgICAgIHRoaXMuaXNOb3RDbGFzcyhjb21wb25lbnRNYXBwaW5nLmNvbXBvbmVudClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGlzTm90Q2xhc3Moc3ltYm9sOiBhbnkpOiBib29sZWFuIHtcclxuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHN5bWJvbC50b1N0cmluZygpLnN1YnN0cigwLCAyMCkucmVwbGFjZSgnICcsICcnKTtcclxuICAgIHJldHVybiBzaWduYXR1cmUuc3RhcnRzV2l0aCgnZnVuY3Rpb24oKScpIHx8IHNpZ25hdHVyZS5zdGFydHNXaXRoKCcoKT0+Jyk7XHJcbiAgfVxyXG5cclxuICBnZXRQcmlvcml0eSgpOiBQcmlvcml0eSB7XHJcbiAgICByZXR1cm4gUHJpb3JpdHkuTE9XO1xyXG4gIH1cclxuXHJcbiAgbGF1bmNoZXIoXHJcbiAgICBjb21wb25lbnRNYXBwaW5nOiBDbXNDb21wb25lbnRNYXBwaW5nLFxyXG4gICAgdmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZixcclxuICAgIGVsZW1lbnRJbmplY3Rvcj86IEluamVjdG9yXHJcbiAgKTogT2JzZXJ2YWJsZTx7IGVsZW1lbnRSZWY6IEVsZW1lbnRSZWY7IGNvbXBvbmVudFJlZj86IENvbXBvbmVudFJlZjxhbnk+IH0+IHtcclxuICAgIHJldHVybiBmcm9tKGNvbXBvbmVudE1hcHBpbmcuY29tcG9uZW50KCkpLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcCgoY29tcG9uZW50KSA9PlxyXG4gICAgICAgIHRoaXMuZGVmYXVsdEhhbmRsZXIubGF1bmNoZXIoXHJcbiAgICAgICAgICB7IC4uLmNvbXBvbmVudE1hcHBpbmcsIGNvbXBvbmVudCB9LFxyXG4gICAgICAgICAgdmlld0NvbnRhaW5lclJlZixcclxuICAgICAgICAgIGVsZW1lbnRJbmplY3RvclxyXG4gICAgICAgIClcclxuICAgICAgKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19