import { isDevMode } from '@angular/core';
/**
 * Matches the pattern '[ ** / ] marker / :paramName'
 *
 * @param marker phrase that indicates the start of the match
 * @param paramName name of the parameter present after the marker
 * @param precedingParamName name of the parameter for every preceding url segment
 *        i.e. `param` will result in `param0`, `param1`, ...
 */
export function getSuffixUrlMatcher({ marker, paramName, precedingParamName, }) {
    precedingParamName = precedingParamName || 'param';
    const matcher = function suffixUrlMatcher(segments) {
        const markerIndex = findLastIndex(segments, ({ path }) => path === marker);
        const isMarkerLastSegment = markerIndex === segments.length - 1;
        if (markerIndex === -1 || isMarkerLastSegment) {
            return null;
        }
        const paramIndex = markerIndex + 1;
        const posParams = {
            [paramName]: segments[paramIndex],
        };
        for (let i = 0; i < markerIndex; i++) {
            posParams[`${precedingParamName}${i}`] = segments[i];
        }
        return { consumed: segments.slice(0, paramIndex + 1), posParams };
    };
    if (isDevMode()) {
        matcher['_suffixRouteConfig'] = { marker, paramName, precedingParamName }; // property added for easier debugging of routes
    }
    return matcher;
}
function findLastIndex(elements, predicate) {
    for (let index = elements.length - 1; index >= 0; index--) {
        if (predicate(elements[index])) {
            return index;
        }
    }
    return -1;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3VmZml4LXVybC1tYXRjaGVyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9zdG9yZWZyb250LyIsInNvdXJjZXMiOlsiY21zLXN0cnVjdHVyZS9yb3V0aW5nL3N1ZmZpeC1yb3V0ZXMvc3VmZml4LXVybC1tYXRjaGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHMUM7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxFQUNsQyxNQUFNLEVBQ04sU0FBUyxFQUNULGtCQUFrQixHQUtuQjtJQUNDLGtCQUFrQixHQUFHLGtCQUFrQixJQUFJLE9BQU8sQ0FBQztJQUNuRCxNQUFNLE9BQU8sR0FBRyxTQUFTLGdCQUFnQixDQUN2QyxRQUFzQjtRQUV0QixNQUFNLFdBQVcsR0FBRyxhQUFhLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLE1BQU0sQ0FBQyxDQUFDO1FBQzNFLE1BQU0sbUJBQW1CLEdBQUcsV0FBVyxLQUFLLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBRWhFLElBQUksV0FBVyxLQUFLLENBQUMsQ0FBQyxJQUFJLG1CQUFtQixFQUFFO1lBQzdDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFFRCxNQUFNLFVBQVUsR0FBRyxXQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ25DLE1BQU0sU0FBUyxHQUFtQztZQUNoRCxDQUFDLFNBQVMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxVQUFVLENBQUM7U0FDbEMsQ0FBQztRQUVGLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDcEMsU0FBUyxDQUFDLEdBQUcsa0JBQWtCLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEQ7UUFFRCxPQUFPLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLFVBQVUsR0FBRyxDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsQ0FBQztJQUNwRSxDQUFDLENBQUM7SUFFRixJQUFJLFNBQVMsRUFBRSxFQUFFO1FBQ2YsT0FBTyxDQUFDLG9CQUFvQixDQUFDLEdBQUcsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLGtCQUFrQixFQUFFLENBQUMsQ0FBQyxnREFBZ0Q7S0FDNUg7SUFFRCxPQUFPLE9BQU8sQ0FBQztBQUNqQixDQUFDO0FBRUQsU0FBUyxhQUFhLENBQUksUUFBYSxFQUFFLFNBQTZCO0lBQ3BFLEtBQUssSUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsS0FBSyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRTtRQUN6RCxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUM5QixPQUFPLEtBQUssQ0FBQztTQUNkO0tBQ0Y7SUFDRCxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQ1osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBVcmxNYXRjaFJlc3VsdCwgVXJsU2VnbWVudCB9IGZyb20gJ0Bhbmd1bGFyL3JvdXRlcic7XHJcblxyXG4vKipcclxuICogTWF0Y2hlcyB0aGUgcGF0dGVybiAnWyAqKiAvIF0gbWFya2VyIC8gOnBhcmFtTmFtZSdcclxuICpcclxuICogQHBhcmFtIG1hcmtlciBwaHJhc2UgdGhhdCBpbmRpY2F0ZXMgdGhlIHN0YXJ0IG9mIHRoZSBtYXRjaFxyXG4gKiBAcGFyYW0gcGFyYW1OYW1lIG5hbWUgb2YgdGhlIHBhcmFtZXRlciBwcmVzZW50IGFmdGVyIHRoZSBtYXJrZXJcclxuICogQHBhcmFtIHByZWNlZGluZ1BhcmFtTmFtZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIgZm9yIGV2ZXJ5IHByZWNlZGluZyB1cmwgc2VnbWVudFxyXG4gKiAgICAgICAgaS5lLiBgcGFyYW1gIHdpbGwgcmVzdWx0IGluIGBwYXJhbTBgLCBgcGFyYW0xYCwgLi4uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VmZml4VXJsTWF0Y2hlcih7XHJcbiAgbWFya2VyLFxyXG4gIHBhcmFtTmFtZSxcclxuICBwcmVjZWRpbmdQYXJhbU5hbWUsXHJcbn06IHtcclxuICBtYXJrZXI6IHN0cmluZztcclxuICBwYXJhbU5hbWU6IHN0cmluZztcclxuICBwcmVjZWRpbmdQYXJhbU5hbWU/OiBzdHJpbmc7XHJcbn0pIHtcclxuICBwcmVjZWRpbmdQYXJhbU5hbWUgPSBwcmVjZWRpbmdQYXJhbU5hbWUgfHwgJ3BhcmFtJztcclxuICBjb25zdCBtYXRjaGVyID0gZnVuY3Rpb24gc3VmZml4VXJsTWF0Y2hlcihcclxuICAgIHNlZ21lbnRzOiBVcmxTZWdtZW50W11cclxuICApOiBVcmxNYXRjaFJlc3VsdCB8IG51bGwge1xyXG4gICAgY29uc3QgbWFya2VySW5kZXggPSBmaW5kTGFzdEluZGV4KHNlZ21lbnRzLCAoeyBwYXRoIH0pID0+IHBhdGggPT09IG1hcmtlcik7XHJcbiAgICBjb25zdCBpc01hcmtlckxhc3RTZWdtZW50ID0gbWFya2VySW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgaWYgKG1hcmtlckluZGV4ID09PSAtMSB8fCBpc01hcmtlckxhc3RTZWdtZW50KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHBhcmFtSW5kZXggPSBtYXJrZXJJbmRleCArIDE7XHJcbiAgICBjb25zdCBwb3NQYXJhbXM6IHsgW25hbWU6IHN0cmluZ106IFVybFNlZ21lbnQgfSA9IHtcclxuICAgICAgW3BhcmFtTmFtZV06IHNlZ21lbnRzW3BhcmFtSW5kZXhdLFxyXG4gICAgfTtcclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtlckluZGV4OyBpKyspIHtcclxuICAgICAgcG9zUGFyYW1zW2Ake3ByZWNlZGluZ1BhcmFtTmFtZX0ke2l9YF0gPSBzZWdtZW50c1tpXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geyBjb25zdW1lZDogc2VnbWVudHMuc2xpY2UoMCwgcGFyYW1JbmRleCArIDEpLCBwb3NQYXJhbXMgfTtcclxuICB9O1xyXG5cclxuICBpZiAoaXNEZXZNb2RlKCkpIHtcclxuICAgIG1hdGNoZXJbJ19zdWZmaXhSb3V0ZUNvbmZpZyddID0geyBtYXJrZXIsIHBhcmFtTmFtZSwgcHJlY2VkaW5nUGFyYW1OYW1lIH07IC8vIHByb3BlcnR5IGFkZGVkIGZvciBlYXNpZXIgZGVidWdnaW5nIG9mIHJvdXRlc1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG1hdGNoZXI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXg8VD4oZWxlbWVudHM6IFRbXSwgcHJlZGljYXRlOiAoZWw6IFQpID0+IGJvb2xlYW4pIHtcclxuICBmb3IgKGxldCBpbmRleCA9IGVsZW1lbnRzLmxlbmd0aCAtIDE7IGluZGV4ID49IDA7IGluZGV4LS0pIHtcclxuICAgIGlmIChwcmVkaWNhdGUoZWxlbWVudHNbaW5kZXhdKSkge1xyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAtMTtcclxufVxyXG4iXX0=