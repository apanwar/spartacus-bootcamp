import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Product, ProductScope, ProductService, RoutingService, } from '@spartacus/core';
import { of } from 'rxjs';
import { distinctUntilChanged, filter, map, switchMap } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
var CurrentProductService = /** @class */ (function () {
    function CurrentProductService(routingService, productService) {
        this.routingService = routingService;
        this.productService = productService;
        this.DEFAULT_PRODUCT_SCOPE = ProductScope.DETAILS;
    }
    /**
     * Will emit current product or null, if there is no current product (i.e. we are not on PDP)
     *
     * @param scopes
     */
    CurrentProductService.prototype.getProduct = function (scopes) {
        var _this = this;
        return this.routingService.getRouterState().pipe(map(function (state) { return state.state.params['productCode']; }), switchMap(function (productCode) {
            return productCode
                ? _this.productService.get(productCode, scopes || _this.DEFAULT_PRODUCT_SCOPE)
                : of(null);
        }), filter(function (x) { return x !== undefined; }), distinctUntilChanged());
    };
    CurrentProductService.ctorParameters = function () { return [
        { type: RoutingService },
        { type: ProductService }
    ]; };
    CurrentProductService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CurrentProductService_Factory() { return new CurrentProductService(i0.ɵɵinject(i1.RoutingService), i0.ɵɵinject(i1.ProductService)); }, token: CurrentProductService, providedIn: "root" });
    CurrentProductService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], CurrentProductService);
    return CurrentProductService;
}());
export { CurrentProductService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VycmVudC1wcm9kdWN0LnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL3N0b3JlZnJvbnQvIiwic291cmNlcyI6WyJjbXMtY29tcG9uZW50cy9wcm9kdWN0L2N1cnJlbnQtcHJvZHVjdC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFDTCxPQUFPLEVBQ1AsWUFBWSxFQUNaLGNBQWMsRUFDZCxjQUFjLEdBQ2YsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQWMsRUFBRSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3RDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFLOUU7SUFDRSwrQkFDVSxjQUE4QixFQUM5QixjQUE4QjtRQUQ5QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsbUJBQWMsR0FBZCxjQUFjLENBQWdCO1FBR3JCLDBCQUFxQixHQUFHLFlBQVksQ0FBQyxPQUFPLENBQUM7SUFGN0QsQ0FBQztJQUlKOzs7O09BSUc7SUFDSCwwQ0FBVSxHQUFWLFVBQ0UsTUFBMEQ7UUFENUQsaUJBZ0JDO1FBYkMsT0FBTyxJQUFJLENBQUMsY0FBYyxDQUFDLGNBQWMsRUFBRSxDQUFDLElBQUksQ0FDOUMsR0FBRyxDQUFDLFVBQUMsS0FBSyxJQUFLLE9BQUEsS0FBSyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLEVBQWpDLENBQWlDLENBQUMsRUFDakQsU0FBUyxDQUFDLFVBQUMsV0FBbUI7WUFDNUIsT0FBTyxXQUFXO2dCQUNoQixDQUFDLENBQUMsS0FBSSxDQUFDLGNBQWMsQ0FBQyxHQUFHLENBQ3JCLFdBQVcsRUFDWCxNQUFNLElBQUksS0FBSSxDQUFDLHFCQUFxQixDQUNyQztnQkFDSCxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ2YsQ0FBQyxDQUFDLEVBQ0YsTUFBTSxDQUFDLFVBQUMsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxLQUFLLFNBQVMsRUFBZixDQUFlLENBQUMsRUFDOUIsb0JBQW9CLEVBQUUsQ0FDdkIsQ0FBQztJQUNKLENBQUM7O2dCQTNCeUIsY0FBYztnQkFDZCxjQUFjOzs7SUFIN0IscUJBQXFCO1FBSGpDLFVBQVUsQ0FBQztZQUNWLFVBQVUsRUFBRSxNQUFNO1NBQ25CLENBQUM7T0FDVyxxQkFBcUIsQ0E4QmpDO2dDQTNDRDtDQTJDQyxBQTlCRCxJQThCQztTQTlCWSxxQkFBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgUHJvZHVjdCxcclxuICBQcm9kdWN0U2NvcGUsXHJcbiAgUHJvZHVjdFNlcnZpY2UsXHJcbiAgUm91dGluZ1NlcnZpY2UsXHJcbn0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgb2YgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIGZpbHRlciwgbWFwLCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgQ3VycmVudFByb2R1Y3RTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgcm91dGluZ1NlcnZpY2U6IFJvdXRpbmdTZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBwcm9kdWN0U2VydmljZTogUHJvZHVjdFNlcnZpY2VcclxuICApIHt9XHJcblxyXG4gIHByb3RlY3RlZCByZWFkb25seSBERUZBVUxUX1BST0RVQ1RfU0NPUEUgPSBQcm9kdWN0U2NvcGUuREVUQUlMUztcclxuXHJcbiAgLyoqXHJcbiAgICogV2lsbCBlbWl0IGN1cnJlbnQgcHJvZHVjdCBvciBudWxsLCBpZiB0aGVyZSBpcyBubyBjdXJyZW50IHByb2R1Y3QgKGkuZS4gd2UgYXJlIG5vdCBvbiBQRFApXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc2NvcGVzXHJcbiAgICovXHJcbiAgZ2V0UHJvZHVjdChcclxuICAgIHNjb3Blcz86IChQcm9kdWN0U2NvcGUgfCBzdHJpbmcpW10gfCBQcm9kdWN0U2NvcGUgfCBzdHJpbmdcclxuICApOiBPYnNlcnZhYmxlPFByb2R1Y3QgfCBudWxsPiB7XHJcbiAgICByZXR1cm4gdGhpcy5yb3V0aW5nU2VydmljZS5nZXRSb3V0ZXJTdGF0ZSgpLnBpcGUoXHJcbiAgICAgIG1hcCgoc3RhdGUpID0+IHN0YXRlLnN0YXRlLnBhcmFtc1sncHJvZHVjdENvZGUnXSksXHJcbiAgICAgIHN3aXRjaE1hcCgocHJvZHVjdENvZGU6IHN0cmluZykgPT4ge1xyXG4gICAgICAgIHJldHVybiBwcm9kdWN0Q29kZVxyXG4gICAgICAgICAgPyB0aGlzLnByb2R1Y3RTZXJ2aWNlLmdldChcclxuICAgICAgICAgICAgICBwcm9kdWN0Q29kZSxcclxuICAgICAgICAgICAgICBzY29wZXMgfHwgdGhpcy5ERUZBVUxUX1BST0RVQ1RfU0NPUEVcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgOiBvZihudWxsKTtcclxuICAgICAgfSksXHJcbiAgICAgIGZpbHRlcigoeCkgPT4geCAhPT0gdW5kZWZpbmVkKSxcclxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19