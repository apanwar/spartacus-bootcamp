import { __assign, __decorate } from "tslib";
import { HttpUrlEncodingCodec } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { tap } from 'rxjs/operators';
import { FacetGroupCollapsedState, } from '../facet.model';
import { ProductFacetService } from './product-facet.service';
import * as i0 from "@angular/core";
import * as i1 from "./product-facet.service";
/**
 * Provides access to the facets as well as their UI state. The UI state
 * represents user related changes on the facets, such as expanding or
 * collapsing a facet group or expanding the number of _visible_ facet values.
 */
var FacetService = /** @class */ (function () {
    function FacetService(productFacetService) {
        var _this = this;
        this.productFacetService = productFacetService;
        /**
         * An internal map where we keep the UI state of the facets.
         */
        this.facetState = new Map();
        /**
         * Observes the facets for the given page and configures the initial UI state.
         *
         * Facets are configured on each emission so that we keep the facet UI state.
         * This is mainly done to keep the state during usage of the facet, but also
         * benefitial when the facets are rebuild while using them.
         */
        this.facetList$ = this.productFacetService.facetList$.pipe(tap(function (facetList) {
            facetList.facets.forEach(function (facet) { return _this.initialize(facet); });
        }));
    }
    /**
     * Returns the observed UI state for the facet.
     *
     * The state is initialized using the `initialize` method.
     */
    FacetService.prototype.getState = function (facet) {
        this.initialize(facet);
        return this.facetState.get(facet.name);
    };
    /**
     * Returns the UI state for the facet.
     *
     * The state is initialized using the `initialize` method.
     */
    FacetService.prototype.getStateSnapshot = function (facet) {
        return this.getState(facet).value;
    };
    /**
     * Toggles the facet expanded state. If the expanded state becomes false,
     * the visible values will decrease to the top values only.
     *
     * If the optional value argument is provided the expanded state will be set
     * to this value, regardless of the current `expanded` state.
     */
    FacetService.prototype.toggle = function (facet, isExpanded) {
        var state = this.getStateSnapshot(facet);
        var toggledState = {
            toggled: isExpanded
                ? FacetGroupCollapsedState.COLLAPSED
                : FacetGroupCollapsedState.EXPANDED,
        };
        if (toggledState.toggled === FacetGroupCollapsedState.COLLAPSED) {
            toggledState.maxVisible = state.topVisible;
        }
        this.updateState(facet, toggledState);
    };
    /**
     * Increases the visible values to the maximum values of the facet.
     */
    FacetService.prototype.increaseVisibleValues = function (facet) {
        this.updateState(facet, { maxVisible: facet.values.length });
    };
    /**
     * Decreases the visible values to the topValueCount.
     *
     * The topValueCount defaults to 6, but can be controlled in
     * the backend as well.
     */
    FacetService.prototype.decreaseVisibleValues = function (facet) {
        this.updateState(facet, { maxVisible: facet.topValueCount });
    };
    /**
     * Persists the facet state and initializes the default values for the top
     * and max visible values.
     */
    FacetService.prototype.initialize = function (facet) {
        if (!this.hasState(facet)) {
            this.facetState.set(facet.name, new BehaviorSubject({
                topVisible: facet.topValueCount || 0,
                maxVisible: facet.topValueCount || 0,
            }));
        }
    };
    /**
     * Updates the state of the facet in the local facet map.
     */
    FacetService.prototype.updateState = function (facet, property) {
        var state = __assign(__assign({}, this.getStateSnapshot(facet)), property);
        this.facetState.get(facet.name).next(state);
    };
    FacetService.prototype.hasState = function (facet) {
        return this.facetState.has(facet.name);
    };
    FacetService.prototype.getLinkParams = function (query) {
        return {
            // to avoid encoding issues with facets that have space (' ') in their name,
            // we replace the decoded '+' back to empty space ' '.
            // For more, see https://github.com/SAP/spartacus/issues/7348
            query: new HttpUrlEncodingCodec().decodeValue(query).replace(/\+/g, ' '),
        };
    };
    FacetService.ctorParameters = function () { return [
        { type: ProductFacetService }
    ]; };
    FacetService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FacetService_Factory() { return new FacetService(i0.ɵɵinject(i1.ProductFacetService)); }, token: FacetService, providedIn: "root" });
    FacetService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], FacetService);
    return FacetService;
}());
export { FacetService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjZXQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbImNtcy1jb21wb25lbnRzL3Byb2R1Y3QvcHJvZHVjdC1saXN0L3Byb2R1Y3QtZmFjZXQtbmF2aWdhdGlvbi9zZXJ2aWNlcy9mYWNldC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBRSxlQUFlLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDbkQsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFFTCx3QkFBd0IsR0FFekIsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7O0FBRTlEOzs7O0dBSUc7QUFJSDtJQU1FLHNCQUFzQixtQkFBd0M7UUFBOUQsaUJBQWtFO1FBQTVDLHdCQUFtQixHQUFuQixtQkFBbUIsQ0FBcUI7UUFMOUQ7O1dBRUc7UUFDTyxlQUFVLEdBQUcsSUFBSSxHQUFHLEVBQStDLENBQUM7UUFJOUU7Ozs7OztXQU1HO1FBQ0gsZUFBVSxHQUEwQixJQUFJLENBQUMsbUJBQW1CLENBQUMsVUFBVSxDQUFDLElBQUksQ0FDMUUsR0FBRyxDQUFDLFVBQUMsU0FBUztZQUNaLFNBQVMsQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQUMsS0FBSyxJQUFLLE9BQUEsS0FBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBdEIsQ0FBc0IsQ0FBQyxDQUFDO1FBQzlELENBQUMsQ0FBQyxDQUNILENBQUM7SUFiK0QsQ0FBQztJQWVsRTs7OztPQUlHO0lBQ0gsK0JBQVEsR0FBUixVQUFTLEtBQVk7UUFDbkIsSUFBSSxDQUFDLFVBQVUs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SFksWUFBWSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEh0dHBVcmxFbmNvZGluZ0NvZGVjIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEZhY2V0IH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHtcclxuICBGYWNldENvbGxhcHNlU3RhdGUsXHJcbiAgRmFjZXRHcm91cENvbGxhcHNlZFN0YXRlLFxyXG4gIEZhY2V0TGlzdCxcclxufSBmcm9tICcuLi9mYWNldC5tb2RlbCc7XHJcbmltcG9ydCB7IFByb2R1Y3RGYWNldFNlcnZpY2UgfSBmcm9tICcuL3Byb2R1Y3QtZmFjZXQuc2VydmljZSc7XHJcblxyXG4vKipcclxuICogUHJvdmlkZXMgYWNjZXNzIHRvIHRoZSBmYWNldHMgYXMgd2VsbCBhcyB0aGVpciBVSSBzdGF0ZS4gVGhlIFVJIHN0YXRlXHJcbiAqIHJlcHJlc2VudHMgdXNlciByZWxhdGVkIGNoYW5nZXMgb24gdGhlIGZhY2V0cywgc3VjaCBhcyBleHBhbmRpbmcgb3JcclxuICogY29sbGFwc2luZyBhIGZhY2V0IGdyb3VwIG9yIGV4cGFuZGluZyB0aGUgbnVtYmVyIG9mIF92aXNpYmxlXyBmYWNldCB2YWx1ZXMuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRmFjZXRTZXJ2aWNlIHtcclxuICAvKipcclxuICAgKiBBbiBpbnRlcm5hbCBtYXAgd2hlcmUgd2Uga2VlcCB0aGUgVUkgc3RhdGUgb2YgdGhlIGZhY2V0cy5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZmFjZXRTdGF0ZSA9IG5ldyBNYXA8c3RyaW5nLCBCZWhhdmlvclN1YmplY3Q8RmFjZXRDb2xsYXBzZVN0YXRlPj4oKTtcclxuXHJcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHByb2R1Y3RGYWNldFNlcnZpY2U6IFByb2R1Y3RGYWNldFNlcnZpY2UpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIE9ic2VydmVzIHRoZSBmYWNldHMgZm9yIHRoZSBnaXZlbiBwYWdlIGFuZCBjb25maWd1cmVzIHRoZSBpbml0aWFsIFVJIHN0YXRlLlxyXG4gICAqXHJcbiAgICogRmFjZXRzIGFyZSBjb25maWd1cmVkIG9uIGVhY2ggZW1pc3Npb24gc28gdGhhdCB3ZSBrZWVwIHRoZSBmYWNldCBVSSBzdGF0ZS5cclxuICAgKiBUaGlzIGlzIG1haW5seSBkb25lIHRvIGtlZXAgdGhlIHN0YXRlIGR1cmluZyB1c2FnZSBvZiB0aGUgZmFjZXQsIGJ1dCBhbHNvXHJcbiAgICogYmVuZWZpdGlhbCB3aGVuIHRoZSBmYWNldHMgYXJlIHJlYnVpbGQgd2hpbGUgdXNpbmcgdGhlbS5cclxuICAgKi9cclxuICBmYWNldExpc3QkOiBPYnNlcnZhYmxlPEZhY2V0TGlzdD4gPSB0aGlzLnByb2R1Y3RGYWNldFNlcnZpY2UuZmFjZXRMaXN0JC5waXBlKFxyXG4gICAgdGFwKChmYWNldExpc3QpID0+IHtcclxuICAgICAgZmFjZXRMaXN0LmZhY2V0cy5mb3JFYWNoKChmYWNldCkgPT4gdGhpcy5pbml0aWFsaXplKGZhY2V0KSk7XHJcbiAgICB9KVxyXG4gICk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIG9ic2VydmVkIFVJIHN0YXRlIGZvciB0aGUgZmFjZXQuXHJcbiAgICpcclxuICAgKiBUaGUgc3RhdGUgaXMgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIGBpbml0aWFsaXplYCBtZXRob2QuXHJcbiAgICovXHJcbiAgZ2V0U3RhdGUoZmFjZXQ6IEZhY2V0KTogT2JzZXJ2YWJsZTxGYWNldENvbGxhcHNlU3RhdGU+IHtcclxuICAgIHRoaXMuaW5pdGlhbGl6ZShmYWNldCk7XHJcbiAgICByZXR1cm4gdGhpcy5mYWNldFN0YXRlLmdldChmYWNldC5uYW1lKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIFVJIHN0YXRlIGZvciB0aGUgZmFjZXQuXHJcbiAgICpcclxuICAgKiBUaGUgc3RhdGUgaXMgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlIGBpbml0aWFsaXplYCBtZXRob2QuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGdldFN0YXRlU25hcHNob3QoZmFjZXQ6IEZhY2V0KTogRmFjZXRDb2xsYXBzZVN0YXRlIHtcclxuICAgIHJldHVybiAodGhpcy5nZXRTdGF0ZShmYWNldCkgYXMgQmVoYXZpb3JTdWJqZWN0PEZhY2V0Q29sbGFwc2VTdGF0ZT4pLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlcyB0aGUgZmFjZXQgZXhwYW5kZWQgc3RhdGUuIElmIHRoZSBleHBhbmRlZCBzdGF0ZSBiZWNvbWVzIGZhbHNlLFxyXG4gICAqIHRoZSB2aXNpYmxlIHZhbHVlcyB3aWxsIGRlY3JlYXNlIHRvIHRoZSB0b3AgdmFsdWVzIG9ubHkuXHJcbiAgICpcclxuICAgKiBJZiB0aGUgb3B0aW9uYWwgdmFsdWUgYXJndW1lbnQgaXMgcHJvdmlkZWQgdGhlIGV4cGFuZGVkIHN0YXRlIHdpbGwgYmUgc2V0XHJcbiAgICogdG8gdGhpcyB2YWx1ZSwgcmVnYXJkbGVzcyBvZiB0aGUgY3VycmVudCBgZXhwYW5kZWRgIHN0YXRlLlxyXG4gICAqL1xyXG4gIHRvZ2dsZShmYWNldDogRmFjZXQsIGlzRXhwYW5kZWQ6IGJvb2xlYW4pOiB2b2lkIHtcclxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZVNuYXBzaG90KGZhY2V0KTtcclxuXHJcbiAgICBjb25zdCB0b2dnbGVkU3RhdGUgPSB7XHJcbiAgICAgIHRvZ2dsZWQ6IGlzRXhwYW5kZWRcclxuICAgICAgICA/IEZhY2V0R3JvdXBDb2xsYXBzZWRTdGF0ZS5DT0xMQVBTRURcclxuICAgICAgICA6IEZhY2V0R3JvdXBDb2xsYXBzZWRTdGF0ZS5FWFBBTkRFRCxcclxuICAgIH0gYXMgRmFjZXRDb2xsYXBzZVN0YXRlO1xyXG5cclxuICAgIGlmICh0b2dnbGVkU3RhdGUudG9nZ2xlZCA9PT0gRmFjZXRHcm91cENvbGxhcHNlZFN0YXRlLkNPTExBUFNFRCkge1xyXG4gICAgICB0b2dnbGVkU3RhdGUubWF4VmlzaWJsZSA9IHN0YXRlLnRvcFZpc2libGU7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy51cGRhdGVTdGF0ZShmYWNldCwgdG9nZ2xlZFN0YXRlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluY3JlYXNlcyB0aGUgdmlzaWJsZSB2YWx1ZXMgdG8gdGhlIG1heGltdW0gdmFsdWVzIG9mIHRoZSBmYWNldC5cclxuICAgKi9cclxuICBpbmNyZWFzZVZpc2libGVWYWx1ZXMoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKGZhY2V0LCB7IG1heFZpc2libGU6IGZhY2V0LnZhbHVlcy5sZW5ndGggfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZWNyZWFzZXMgdGhlIHZpc2libGUgdmFsdWVzIHRvIHRoZSB0b3BWYWx1ZUNvdW50LlxyXG4gICAqXHJcbiAgICogVGhlIHRvcFZhbHVlQ291bnQgZGVmYXVsdHMgdG8gNiwgYnV0IGNhbiBiZSBjb250cm9sbGVkIGluXHJcbiAgICogdGhlIGJhY2tlbmQgYXMgd2VsbC5cclxuICAgKi9cclxuICBkZWNyZWFzZVZpc2libGVWYWx1ZXMoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XHJcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKGZhY2V0LCB7IG1heFZpc2libGU6IGZhY2V0LnRvcFZhbHVlQ291bnQgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQZXJzaXN0cyB0aGUgZmFjZXQgc3RhdGUgYW5kIGluaXRpYWxpemVzIHRoZSBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlIHRvcFxyXG4gICAqIGFuZCBtYXggdmlzaWJsZSB2YWx1ZXMuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGluaXRpYWxpemUoZmFjZXQ6IEZhY2V0KTogdm9pZCB7XHJcbiAgICBpZiAoIXRoaXMuaGFzU3RhdGUoZmFjZXQpKSB7XHJcbiAgICAgIHRoaXMuZmFjZXRTdGF0ZS5zZXQoXHJcbiAgICAgICAgZmFjZXQubmFtZSxcclxuICAgICAgICBuZXcgQmVoYXZpb3JTdWJqZWN0KHtcclxuICAgICAgICAgIHRvcFZpc2libGU6IGZhY2V0LnRvcFZhbHVlQ291bnQgfHwgMCxcclxuICAgICAgICAgIG1heFZpc2libGU6IGZhY2V0LnRvcFZhbHVlQ291bnQgfHwgMCxcclxuICAgICAgICB9IGFzIEZhY2V0Q29sbGFwc2VTdGF0ZSlcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBmYWNldCBpbiB0aGUgbG9jYWwgZmFjZXQgbWFwLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCB1cGRhdGVTdGF0ZShmYWNldDogRmFjZXQsIHByb3BlcnR5OiBGYWNldENvbGxhcHNlU3RhdGUpOiB2b2lkIHtcclxuICAgIGNvbnN0IHN0YXRlID0geyAuLi50aGlzLmdldFN0YXRlU25hcHNob3QoZmFjZXQpLCAuLi5wcm9wZXJ0eSB9O1xyXG4gICAgdGhpcy5mYWNldFN0YXRlLmdldChmYWNldC5uYW1lKS5uZXh0KHN0YXRlKTtcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBoYXNTdGF0ZShmYWNldDogRmFjZXQpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLmZhY2V0U3RhdGUuaGFzKGZhY2V0Lm5hbWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0TGlua1BhcmFtcyhxdWVyeTogc3RyaW5nKTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAvLyB0byBhdm9pZCBlbmNvZGluZyBpc3N1ZXMgd2l0aCBmYWNldHMgdGhhdCBoYXZlIHNwYWNlICgnICcpIGluIHRoZWlyIG5hbWUsXHJcbiAgICAgIC8vIHdlIHJlcGxhY2UgdGhlIGRlY29kZWQgJysnIGJhY2sgdG8gZW1wdHkgc3BhY2UgJyAnLlxyXG4gICAgICAvLyBGb3IgbW9yZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9TQVAvc3BhcnRhY3VzL2lzc3Vlcy83MzQ4XHJcbiAgICAgIHF1ZXJ5OiBuZXcgSHR0cFVybEVuY29kaW5nQ29kZWMoKS5kZWNvZGVWYWx1ZShxdWVyeSkucmVwbGFjZSgvXFwrL2csICcgJyksXHJcbiAgICB9O1xyXG4gIH1cclxufVxyXG4iXX0=