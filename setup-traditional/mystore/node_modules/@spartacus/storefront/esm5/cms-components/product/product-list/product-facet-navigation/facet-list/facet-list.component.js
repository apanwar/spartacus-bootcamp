import { __decorate } from "tslib";
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, HostListener, Input, Output, Renderer2, } from '@angular/core';
import { map } from 'rxjs/operators';
import { ICON_TYPE } from '../../../../misc/icon/icon.model';
import { FacetGroupCollapsedState } from '../facet.model';
import { FacetService } from '../services/facet.service';
var FacetListComponent = /** @class */ (function () {
    function FacetListComponent(facetService, elementRef, renderer) {
        this.facetService = facetService;
        this.elementRef = elementRef;
        this.renderer = renderer;
        /** Emits when the list must close */
        this.closeList = new EventEmitter();
        /** The list of all facet and values related to the products in the list */
        this.facetList$ = this.facetService.facetList$;
        this.iconTypes = ICON_TYPE;
        this.dialogFocusConfig = {
            trap: true,
            block: true,
            focusOnEscape: true,
            autofocus: 'cx-facet',
        };
    }
    Object.defineProperty(FacetListComponent.prototype, "isDialog", {
        get: function () {
            return this._isDialog;
        },
        /**
         * Indicates that the facet navigation is rendered in dialog.
         */
        set: function (value) {
            this._isDialog = value;
            if (value) {
                this.renderer.addClass(document.body, 'modal-open');
            }
        },
        enumerable: true,
        configurable: true
    });
    FacetListComponent.prototype.handleClick = function () {
        this.close();
    };
    /**
     * Toggles the facet group in case it is not expanded.
     */
    FacetListComponent.prototype.expandFacetGroup = function (facet, ref) {
        if (!ref.isExpanded) {
            this.facetService.toggle(facet, ref.isExpanded);
        }
    };
    /**
     * Indicates that the facet group has been expanded.
     */
    FacetListComponent.prototype.isExpanded = function (facet) {
        return this.facetService
            .getState(facet)
            .pipe(map(function (value) { return value.toggled === FacetGroupCollapsedState.EXPANDED; }));
    };
    /**
     * Indicates that the facet group has been collapsed.
     */
    FacetListComponent.prototype.isCollapsed = function (facet) {
        return this.facetService
            .getState(facet)
            .pipe(map(function (value) { return value.toggled === FacetGroupCollapsedState.COLLAPSED; }));
    };
    FacetListComponent.prototype.close = function (event) {
        this.renderer.removeClass(document.body, 'modal-open');
        this.closeList.emit(event);
    };
    FacetListComponent.prototype.block = function (event) {
        event.stopPropagation();
    };
    FacetListComponent.ctorParameters = function () { return [
        { type: FacetService },
        { type: ElementRef },
        { type: Renderer2 }
    ]; };
    __decorate([
        Input()
    ], FacetListComponent.prototype, "isDialog", null);
    __decorate([
        Output()
    ], FacetListComponent.prototype, "closeList", void 0);
    __decorate([
        HostListener('click')
    ], FacetListComponent.prototype, "handleClick", null);
    FacetListComponent = __decorate([
        Component({
            selector: 'cx-facet-list',
            template: "<div\r\n  class=\"inner\"\r\n  *ngIf=\"(facetList$ | async)?.facets as facets\"\r\n  [cxFocus]=\"isDialog ? dialogFocusConfig : {}\"\r\n  (esc)=\"close($event)\"\r\n  (click)=\"block($event)\"\r\n>\r\n  <h4>\r\n    {{ 'productList.filterBy.label' | cxTranslate }}\r\n    <button type=\"button\" class=\"close\" aria-label=\"Close\" (click)=\"close()\">\r\n      <cx-icon aria-hidden=\"true\" [type]=\"iconTypes.CLOSE\"></cx-icon>\r\n    </button>\r\n  </h4>\r\n\r\n  <!-- \r\n      Here we'd like to introduce configurable facet components, \r\n      either by using specific configuration or generic sproutlets \r\n  -->\r\n  <cx-facet\r\n    *ngFor=\"let facet of facets\"\r\n    #facetRef\r\n    [facet]=\"facet\"\r\n    [cxFocus]=\"{ lock: true, trap: true, autofocus: 'a' }\"\r\n    (unlock)=\"expandFacetGroup(facet, facetRef)\"\r\n    [class.expanded]=\"isExpanded(facet) | async\"\r\n    [class.collapsed]=\"isCollapsed(facet) | async\"\r\n  ></cx-facet>\r\n</div>\r\n",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], FacetListComponent);
    return FacetListComponent;
}());
export { FacetListComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFjZXQtbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL3N0b3JlZnJvbnQvIiwic291cmNlcyI6WyJjbXMtY29tcG9uZW50cy9wcm9kdWN0L3Byb2R1Y3QtbGlzdC9wcm9kdWN0LWZhY2V0LW5hdmlnYXRpb24vZmFjZXQtbGlzdC9mYWNldC1saXN0LmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFDTixTQUFTLEdBQ1YsTUFBTSxlQUFlLENBQUM7QUFHdkIsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXJDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQztBQUM3RCxPQUFPLEVBQUUsd0JBQXdCLEVBQWEsTUFBTSxnQkFBZ0IsQ0FBQztBQUVyRSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFPekQ7SUFvQ0UsNEJBQ1ksWUFBMEIsRUFDMUIsVUFBc0IsRUFDdEIsUUFBbUI7UUFGbkIsaUJBQVksR0FBWixZQUFZLENBQWM7UUFDMUIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0QixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBdEIvQixxQ0FBcUM7UUFDM0IsY0FBUyxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7UUFFekMsMkVBQTJFO1FBQzNFLGVBQVUsR0FBMEIsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUM7UUFFakUsY0FBUyxHQUFHLFNBQVMsQ0FBQztRQUV0QixzQkFBaUIsR0FBZ0I7WUFDL0IsSUFBSSxFQUFFLElBQUk7WUFDVixLQUFLLEVBQUUsSUFBSTtZQUNYLGFBQWEsRUFBRSxJQUFJO1lBQ25CLFNBQVMsRUFBRSxVQUFVO1NBQ3RCLENBQUM7SUFVQyxDQUFDO0lBbENKLHNCQUFJLHdDQUFRO2FBT1o7WUFDRSxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDeEIsQ0FBQztRQWJEOztXQUVHO2FBRUgsVUFBYSxLQUFjO1lBQ3pCLElBQUksQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDO1lBQ3ZCLElBQUksS0FBSyxFQUFFO2dCQUNULElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7YUFDckQ7UUFDSCxDQUFDOzs7T0FBQTtJQXFCc0Isd0NBQVcsR0FBWDtRQUNyQixJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDZixDQUFDO0lBUUQ7O09BRUc7SUFDSCw2Q0FBZ0IsR0FBaEIsVUFBaUIsS0FBWSxFQUFFLEdBQW1CO1FBQ2hELElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFO1lBQ25CLElBQUksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDakQ7SUFDSCxDQUFDO0lBRUQ7O09BRUc7SUFDSCx1Q0FBVSxHQUFWLFVBQVcsS0FBWTtRQUNyQixPQUFPLElBQUksQ0FBQyxZQUFZO2FBQ3JCLFFBQVEsQ0FBQyxLQUFLLENBQUM7YUFDZixJQUFJLENBQ0gsR0FBRyxDQUFDLFVBQUMsS0FBSyxJQUFLLE9BQUEsS0FBSyxDQUFDLE9BQU8sS0FBSyx3QkFBd0IsQ0FBQyxRQUFRLEVBQW5ELENBQW1ELENBQUMsQ0FDcEUsQ0FBQztJQUNOLENBQUM7SUFFRDs7T0FFRztJQUNILHdDQUFXLEdBQVgsVUFBWSxLQUFZO1FBQ3RCLE9BQU8sSUFBSSxDQUFDLFlBQVk7YUFDckIsUUFBUSxDQUFDLEtBQUssQ0FBQzthQUNmLElBQUksQ0FDSCxHQUFHLENBQUMsVUFBQyxLQUFLLElBQUssT0FBQSxLQUFLLENBQUMsT0FBTyxLQUFLLHdCQUF3QixDQUFDLFNBQVMsRUFBcEQsQ0FBb0QsQ0FBQyxDQUNyRSxDQUFDO0lBQ04sQ0FBQztJQUVELGtDQUFLLEdBQUwsVUFBTSxLQUFlO1FBQ25CLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDdkQsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVELGtDQUFLLEdBQUwsVUFBTSxLQUFrQjtRQUN0QixLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDMUIsQ0FBQzs7Z0JBM0N5QixZQUFZO2dCQUNkLFVBQVU7Z0JBQ1osU0FBUzs7SUFqQy9CO1FBREMsS0FBSyxFQUFFO3NEQU1QO0lBT1M7UUFBVCxNQUFNLEVBQUU7eURBQWdDO0lBY2xCO1FBQXRCLFlBQVksQ0FBQyxPQUFPLENBQUM7eURBRXJCO0lBbENVLGtCQUFrQjtRQUw5QixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsZUFBZTtZQUN6Qiw0OUJBQTBDO1lBQzFDLGVBQWUsRUFBRSx1QkFBdUIsQ0FBQyxNQUFNO1NBQ2hELENBQUM7T0FDVyxrQkFBa0IsQ0FpRjlCO0lBQUQseUJBQUM7Q0FBQSxBQWpGRCxJQWlGQztTQWpGWSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxyXG4gIENvbXBvbmVudCxcclxuICBFbGVtZW50UmVmLFxyXG4gIEV2ZW50RW1pdHRlcixcclxuICBIb3N0TGlzdGVuZXIsXHJcbiAgSW5wdXQsXHJcbiAgT3V0cHV0LFxyXG4gIFJlbmRlcmVyMixcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRmFjZXQgfSBmcm9tICdAc3BhcnRhY3VzL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcclxuaW1wb3J0IHsgRm9jdXNDb25maWcgfSBmcm9tICcuLi8uLi8uLi8uLi8uLi9sYXlvdXQvYTExeS9rZXlib2FyZC1mb2N1cy9pbmRleCc7XHJcbmltcG9ydCB7IElDT05fVFlQRSB9IGZyb20gJy4uLy4uLy4uLy4uL21pc2MvaWNvbi9pY29uLm1vZGVsJztcclxuaW1wb3J0IHsgRmFjZXRHcm91cENvbGxhcHNlZFN0YXRlLCBGYWNldExpc3QgfSBmcm9tICcuLi9mYWNldC5tb2RlbCc7XHJcbmltcG9ydCB7IEZhY2V0Q29tcG9uZW50IH0gZnJvbSAnLi4vZmFjZXQvZmFjZXQuY29tcG9uZW50JztcclxuaW1wb3J0IHsgRmFjZXRTZXJ2aWNlIH0gZnJvbSAnLi4vc2VydmljZXMvZmFjZXQuc2VydmljZSc7XHJcblxyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2N4LWZhY2V0LWxpc3QnLFxyXG4gIHRlbXBsYXRlVXJsOiAnLi9mYWNldC1saXN0LmNvbXBvbmVudC5odG1sJyxcclxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcclxufSlcclxuZXhwb3J0IGNsYXNzIEZhY2V0TGlzdENvbXBvbmVudCB7XHJcbiAgcHJpdmF0ZSBfaXNEaWFsb2c6IGJvb2xlYW47XHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIGZhY2V0IG5hdmlnYXRpb24gaXMgcmVuZGVyZWQgaW4gZGlhbG9nLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpXHJcbiAgc2V0IGlzRGlhbG9nKHZhbHVlOiBib29sZWFuKSB7XHJcbiAgICB0aGlzLl9pc0RpYWxvZyA9IHZhbHVlO1xyXG4gICAgaWYgKHZhbHVlKSB7XHJcbiAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3MoZG9jdW1lbnQuYm9keSwgJ21vZGFsLW9wZW4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldCBpc0RpYWxvZygpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLl9pc0RpYWxvZztcclxuICB9XHJcblxyXG4gIC8qKiBFbWl0cyB3aGVuIHRoZSBsaXN0IG11c3QgY2xvc2UgKi9cclxuICBAT3V0cHV0KCkgY2xvc2VMaXN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xyXG5cclxuICAvKiogVGhlIGxpc3Qgb2YgYWxsIGZhY2V0IGFuZCB2YWx1ZXMgcmVsYXRlZCB0byB0aGUgcHJvZHVjdHMgaW4gdGhlIGxpc3QgKi9cclxuICBmYWNldExpc3QkOiBPYnNlcnZhYmxlPEZhY2V0TGlzdD4gPSB0aGlzLmZhY2V0U2VydmljZS5mYWNldExpc3QkO1xyXG5cclxuICBpY29uVHlwZXMgPSBJQ09OX1RZUEU7XHJcblxyXG4gIGRpYWxvZ0ZvY3VzQ29uZmlnOiBGb2N1c0NvbmZpZyA9IHtcclxuICAgIHRyYXA6IHRydWUsXHJcbiAgICBibG9jazogdHJ1ZSxcclxuICAgIGZvY3VzT25Fc2NhcGU6IHRydWUsXHJcbiAgICBhdXRvZm9jdXM6ICdjeC1mYWNldCcsXHJcbiAgfTtcclxuXHJcbiAgQEhvc3RMaXN0ZW5lcignY2xpY2snKSBoYW5kbGVDbGljaygpIHtcclxuICAgIHRoaXMuY2xvc2UoKTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJvdGVjdGVkIGZhY2V0U2VydmljZTogRmFjZXRTZXJ2aWNlLFxyXG4gICAgcHJvdGVjdGVkIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyMlxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogVG9nZ2xlcyB0aGUgZmFjZXQgZ3JvdXAgaW4gY2FzZSBpdCBpcyBub3QgZXhwYW5kZWQuXHJcbiAgICovXHJcbiAgZXhwYW5kRmFjZXRHcm91cChmYWNldDogRmFjZXQsIHJlZjogRmFjZXRDb21wb25lbnQpIHtcclxuICAgIGlmICghcmVmLmlzRXhwYW5kZWQpIHtcclxuICAgICAgdGhpcy5mYWNldFNlcnZpY2UudG9nZ2xlKGZhY2V0LCByZWYuaXNFeHBhbmRlZCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGUgZmFjZXQgZ3JvdXAgaGFzIGJlZW4gZXhwYW5kZWQuXHJcbiAgICovXHJcbiAgaXNFeHBhbmRlZChmYWNldDogRmFjZXQpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiB0aGlzLmZhY2V0U2VydmljZVxyXG4gICAgICAuZ2V0U3RhdGUoZmFjZXQpXHJcbiAgICAgIC5waXBlKFxyXG4gICAgICAgIG1hcCgodmFsdWUpID0+IHZhbHVlLnRvZ2dsZWQgPT09IEZhY2V0R3JvdXBDb2xsYXBzZWRTdGF0ZS5FWFBBTkRFRClcclxuICAgICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSBmYWNldCBncm91cCBoYXMgYmVlbiBjb2xsYXBzZWQuXHJcbiAgICovXHJcbiAgaXNDb2xsYXBzZWQoZmFjZXQ6IEZhY2V0KTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5mYWNldFNlcnZpY2VcclxuICAgICAgLmdldFN0YXRlKGZhY2V0KVxyXG4gICAgICAucGlwZShcclxuICAgICAgICBtYXAoKHZhbHVlKSA9PiB2YWx1ZS50b2dnbGVkID09PSBGYWNldEdyb3VwQ29sbGFwc2VkU3RhdGUuQ09MTEFQU0VEKVxyXG4gICAgICApO1xyXG4gIH1cclxuXHJcbiAgY2xvc2UoZXZlbnQ/OiBib29sZWFuKTogdm9pZCB7XHJcbiAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdtb2RhbC1vcGVuJyk7XHJcbiAgICB0aGlzLmNsb3NlTGlzdC5lbWl0KGV2ZW50KTtcclxuICB9XHJcblxyXG4gIGJsb2NrKGV2ZW50PzogTW91c2VFdmVudCkge1xyXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==