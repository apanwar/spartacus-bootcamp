import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
var SelectFocusUtility = /** @class */ (function () {
    function SelectFocusUtility() {
        /**
         * Query selectors used to query focusable child elements of the host element.
         * The selectors are supplemented with `:not([disabled])` and `:not([hidden])`.
         */
        this.focusableSelectors = [
            'a[href]',
            'button',
            '[tabindex]',
            'input',
            'select',
            'textarea',
        ];
        // like to leave out the following as we don't use it, and make this list exensible.
        //   `[contentEditable=true]`, // very unlikely to suport as we're not a business tool
        //   `iframe`, // we really don't like iframes...
        //   `area[href]`, // very debatable!
        this.focusableSelectorSuffix = ':not([disabled]):not([hidden])';
    }
    SelectFocusUtility.prototype.query = function (host, selector) {
        if (!selector || selector === '') {
            return [];
        }
        return Array.from(host.querySelectorAll(selector));
    };
    SelectFocusUtility.prototype.findFirstFocusable = function (host, config) {
        var _this = this;
        if (config === void 0) { config = { autofocus: true }; }
        var selector = typeof (config === null || config === void 0 ? void 0 : config.autofocus) === 'string' ? config.autofocus : '[autofocus]';
        // fallback to first focusable
        return (this.query(host, selector).find(function (el) { return !_this.isHidden(el); }) ||
            this.findFocusable(host).find(function (el) { return Boolean(el); }));
    };
    /**
     * returns all focusable child elements of the host element. The element selectors
     * are build from the `focusableSelectors`.
     *
     * @param host the `HTMLElement` used to query focusable elements
     * @param locked indicates whether inactive (`tabindex="-1"`) focusable elements should be returned
     * @param invisible indicates whether hidden focusable elements should be returned
     */
    SelectFocusUtility.prototype.findFocusable = function (host, locked, invisible) {
        var _this = this;
        if (locked === void 0) { locked = false; }
        if (invisible === void 0) { invisible = false; }
        var suffix = this.focusableSelectorSuffix;
        if (!locked) {
            suffix += ":not([tabindex='-1'])";
        }
        var selector = this.focusableSelectors
            .map(function (s) { return (s += suffix); })
            .join(',');
        return this.query(host, selector).filter(function (el) {
            return !invisible ? !_this.isHidden(el) : Boolean(el);
        });
    };
    /**
     * Indicates whether the element is hidden by CSS. There are various CSS rules and
     * HTML structures which can lead to an hidden or invisible element. An `offsetParent`
     * of null indicates that the element or any of it's decendants is hidden (`display:none`).
     *
     * Oother techniques use the visibility (`visibility: hidden`), opacity (`opacity`) or
     * phyisical location on the element itself or any of it's anchestor elements. Those
     * technique require to work with the _computed styles_, which will cause a performance
     * downgrade. We don't do this in the standard implementaton.
     */
    SelectFocusUtility.prototype.isHidden = function (el) {
        return el.offsetParent === null;
    };
    SelectFocusUtility.ɵprov = i0.ɵɵdefineInjectable({ factory: function SelectFocusUtility_Factory() { return new SelectFocusUtility(); }, token: SelectFocusUtility, providedIn: "root" });
    SelectFocusUtility = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], SelectFocusUtility);
    return SelectFocusUtility;
}());
export { SelectFocusUtility };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0LWZvY3VzLnV0aWwuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL3N0b3JlZnJvbnQvIiwic291cmNlcyI6WyJsYXlvdXQvYTExeS9rZXlib2FyZC1mb2N1cy9zZXJ2aWNlcy9zZWxlY3QtZm9jdXMudXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7QUFNM0M7SUFBQTtRQUNFOzs7V0FHRztRQUNPLHVCQUFrQixHQUFhO1lBQ3ZDLFNBQVM7WUFDVCxRQUFRO1lBQ1IsWUFBWTtZQUNaLE9BQU87WUFDUCxRQUFRO1lBQ1IsVUFBVTtTQUNYLENBQUM7UUFFRixvRkFBb0Y7UUFDcEYsc0ZBQXNGO1FBQ3RGLGlEQUFpRDtRQUNqRCxxQ0FBcUM7UUFFM0IsNEJBQXVCLEdBQUcsZ0NBQWdDLENBQUM7S0E4RHRFO0lBNURDLGtDQUFLLEdBQUwsVUFBTSxJQUFpQixFQUFFLFFBQWdCO1FBQ3ZDLElBQUksQ0FBQyxRQUFRLElBQUksUUFBUSxLQUFLLEVBQUUsRUFBRTtZQUNoQyxPQUFPLEVBQUUsQ0FBQztTQUNYO1FBQ0QsT0FBTyxLQUFLLENBQUMsSUFBSSxDQUNmLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQTRCLENBQzNELENBQUM7SUFDSixDQUFDO0lBRUQsK0NBQWtCLEdBQWxCLFVBQ0UsSUFBaUIsRUFDakIsTUFBNkM7UUFGL0MsaUJBV0M7UUFUQyx1QkFBQSxFQUFBLFdBQTRCLFNBQVMsRUFBRSxJQUFJLEVBQUU7UUFFN0MsSUFBTSxRQUFRLEdBQ1osUUFBTyxNQUFNLGFBQU4sTUFBTSx1QkFBTixNQUFNLENBQUUsU0FBUyxDQUFBLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7UUFDM0UsOEJBQThCO1FBQzlCLE9BQU8sQ0FDTCxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksRUFBRSxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxFQUFFLElBQUssT0FBQSxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLEVBQWxCLENBQWtCLENBQUM7WUFDM0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxFQUFFLElBQUssT0FBQSxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQVgsQ0FBVyxDQUFDLENBQ25ELENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNILDBDQUFhLEdBQWIsVUFDRSxJQUFpQixFQUNqQixNQUFjLEVBQ2QsU0FBaUI7UUFIbkIsaUJBZUM7UUFiQyx1QkFBQSxFQUFBLGNBQWM7UUFDZCwwQkFBQSxFQUFBLGlCQUFpQjtRQUVqQixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUM7UUFDMUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNYLE1BQU0sSUFBSSx1QkFBdUIsQ0FBQztTQUNuQztRQUNELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxrQkFBa0I7YUFDckMsR0FBRyxDQUFDLFVBQUMsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLEVBQWIsQ0FBYSxDQUFDO2FBQ3pCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNiLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUMsTUFBTSxDQUFDLFVBQUMsRUFBRTtZQUMxQyxPQUFBLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUM7UUFBN0MsQ0FBNkMsQ0FDOUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDTyxxQ0FBUSxHQUFsQixVQUFtQixFQUFlO1FBQ2hDLE9BQU8sRUFBRSxDQUFDLFlBQVksS0FBSyxJQUFJLENBQUM7SUFDbEMsQ0FBQzs7SUFoRlUsa0JBQWtCO1FBSDlCLFVBQVUsQ0FBQztZQUNWLFVBQVUsRUFBRSxNQUFNO1NBQ25CLENBQUM7T0FDVyxrQkFBa0IsQ0FpRjlCOzZCQXZGRDtDQXVGQyxBQWpGRCxJQWlGQztTQWpGWSxrQkFBa0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEF1dG9Gb2N1c0NvbmZpZyB9IGZyb20gJy4uL2tleWJvYXJkLWZvY3VzLm1vZGVsJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTZWxlY3RGb2N1c1V0aWxpdHkge1xyXG4gIC8qKlxyXG4gICAqIFF1ZXJ5IHNlbGVjdG9ycyB1c2VkIHRvIHF1ZXJ5IGZvY3VzYWJsZSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgaG9zdCBlbGVtZW50LlxyXG4gICAqIFRoZSBzZWxlY3RvcnMgYXJlIHN1cHBsZW1lbnRlZCB3aXRoIGA6bm90KFtkaXNhYmxlZF0pYCBhbmQgYDpub3QoW2hpZGRlbl0pYC5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZm9jdXNhYmxlU2VsZWN0b3JzOiBzdHJpbmdbXSA9IFtcclxuICAgICdhW2hyZWZdJyxcclxuICAgICdidXR0b24nLFxyXG4gICAgJ1t0YWJpbmRleF0nLFxyXG4gICAgJ2lucHV0JyxcclxuICAgICdzZWxlY3QnLFxyXG4gICAgJ3RleHRhcmVhJyxcclxuICBdO1xyXG5cclxuICAvLyBsaWtlIHRvIGxlYXZlIG91dCB0aGUgZm9sbG93aW5nIGFzIHdlIGRvbid0IHVzZSBpdCwgYW5kIG1ha2UgdGhpcyBsaXN0IGV4ZW5zaWJsZS5cclxuICAvLyAgIGBbY29udGVudEVkaXRhYmxlPXRydWVdYCwgLy8gdmVyeSB1bmxpa2VseSB0byBzdXBvcnQgYXMgd2UncmUgbm90IGEgYnVzaW5lc3MgdG9vbFxyXG4gIC8vICAgYGlmcmFtZWAsIC8vIHdlIHJlYWxseSBkb24ndCBsaWtlIGlmcmFtZXMuLi5cclxuICAvLyAgIGBhcmVhW2hyZWZdYCwgLy8gdmVyeSBkZWJhdGFibGUhXHJcblxyXG4gIHByb3RlY3RlZCBmb2N1c2FibGVTZWxlY3RvclN1ZmZpeCA9ICc6bm90KFtkaXNhYmxlZF0pOm5vdChbaGlkZGVuXSknO1xyXG5cclxuICBxdWVyeShob3N0OiBIVE1MRWxlbWVudCwgc2VsZWN0b3I6IHN0cmluZyk6IEhUTUxFbGVtZW50W10ge1xyXG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJycpIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIEFycmF5LmZyb20oXHJcbiAgICAgIGhvc3QucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikgYXMgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBmaW5kRmlyc3RGb2N1c2FibGUoXHJcbiAgICBob3N0OiBIVE1MRWxlbWVudCxcclxuICAgIGNvbmZpZzogQXV0b0ZvY3VzQ29uZmlnID0geyBhdXRvZm9jdXM6IHRydWUgfVxyXG4gICk6IEhUTUxFbGVtZW50IHtcclxuICAgIGNvbnN0IHNlbGVjdG9yID1cclxuICAgICAgdHlwZW9mIGNvbmZpZz8uYXV0b2ZvY3VzID09PSAnc3RyaW5nJyA/IGNvbmZpZy5hdXRvZm9jdXMgOiAnW2F1dG9mb2N1c10nO1xyXG4gICAgLy8gZmFsbGJhY2sgdG8gZmlyc3QgZm9jdXNhYmxlXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICB0aGlzLnF1ZXJ5KGhvc3QsIHNlbGVjdG9yKS5maW5kKChlbCkgPT4gIXRoaXMuaXNIaWRkZW4oZWwpKSB8fFxyXG4gICAgICB0aGlzLmZpbmRGb2N1c2FibGUoaG9zdCkuZmluZCgoZWwpID0+IEJvb2xlYW4oZWwpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHJldHVybnMgYWxsIGZvY3VzYWJsZSBjaGlsZCBlbGVtZW50cyBvZiB0aGUgaG9zdCBlbGVtZW50LiBUaGUgZWxlbWVudCBzZWxlY3RvcnNcclxuICAgKiBhcmUgYnVpbGQgZnJvbSB0aGUgYGZvY3VzYWJsZVNlbGVjdG9yc2AuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaG9zdCB0aGUgYEhUTUxFbGVtZW50YCB1c2VkIHRvIHF1ZXJ5IGZvY3VzYWJsZSBlbGVtZW50c1xyXG4gICAqIEBwYXJhbSBsb2NrZWQgaW5kaWNhdGVzIHdoZXRoZXIgaW5hY3RpdmUgKGB0YWJpbmRleD1cIi0xXCJgKSBmb2N1c2FibGUgZWxlbWVudHMgc2hvdWxkIGJlIHJldHVybmVkXHJcbiAgICogQHBhcmFtIGludmlzaWJsZSBpbmRpY2F0ZXMgd2hldGhlciBoaWRkZW4gZm9jdXNhYmxlIGVsZW1lbnRzIHNob3VsZCBiZSByZXR1cm5lZFxyXG4gICAqL1xyXG4gIGZpbmRGb2N1c2FibGUoXHJcbiAgICBob3N0OiBIVE1MRWxlbWVudCxcclxuICAgIGxvY2tlZCA9IGZhbHNlLFxyXG4gICAgaW52aXNpYmxlID0gZmFsc2VcclxuICApOiBIVE1MRWxlbWVudFtdIHtcclxuICAgIGxldCBzdWZmaXggPSB0aGlzLmZvY3VzYWJsZVNlbGVjdG9yU3VmZml4O1xyXG4gICAgaWYgKCFsb2NrZWQpIHtcclxuICAgICAgc3VmZml4ICs9IGA6bm90KFt0YWJpbmRleD0nLTEnXSlgO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmZvY3VzYWJsZVNlbGVjdG9yc1xyXG4gICAgICAubWFwKChzKSA9PiAocyArPSBzdWZmaXgpKVxyXG4gICAgICAuam9pbignLCcpO1xyXG4gICAgcmV0dXJuIHRoaXMucXVlcnkoaG9zdCwgc2VsZWN0b3IpLmZpbHRlcigoZWwpID0+XHJcbiAgICAgICFpbnZpc2libGUgPyAhdGhpcy5pc0hpZGRlbihlbCkgOiBCb29sZWFuKGVsKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGhpZGRlbiBieSBDU1MuIFRoZXJlIGFyZSB2YXJpb3VzIENTUyBydWxlcyBhbmRcclxuICAgKiBIVE1MIHN0cnVjdHVyZXMgd2hpY2ggY2FuIGxlYWQgdG8gYW4gaGlkZGVuIG9yIGludmlzaWJsZSBlbGVtZW50LiBBbiBgb2Zmc2V0UGFyZW50YFxyXG4gICAqIG9mIG51bGwgaW5kaWNhdGVzIHRoYXQgdGhlIGVsZW1lbnQgb3IgYW55IG9mIGl0J3MgZGVjZW5kYW50cyBpcyBoaWRkZW4gKGBkaXNwbGF5Om5vbmVgKS5cclxuICAgKlxyXG4gICAqIE9vdGhlciB0ZWNobmlxdWVzIHVzZSB0aGUgdmlzaWJpbGl0eSAoYHZpc2liaWxpdHk6IGhpZGRlbmApLCBvcGFjaXR5IChgb3BhY2l0eWApIG9yXHJcbiAgICogcGh5aXNpY2FsIGxvY2F0aW9uIG9uIHRoZSBlbGVtZW50IGl0c2VsZiBvciBhbnkgb2YgaXQncyBhbmNoZXN0b3IgZWxlbWVudHMuIFRob3NlXHJcbiAgICogdGVjaG5pcXVlIHJlcXVpcmUgdG8gd29yayB3aXRoIHRoZSBfY29tcHV0ZWQgc3R5bGVzXywgd2hpY2ggd2lsbCBjYXVzZSBhIHBlcmZvcm1hbmNlXHJcbiAgICogZG93bmdyYWRlLiBXZSBkb24ndCBkbyB0aGlzIGluIHRoZSBzdGFuZGFyZCBpbXBsZW1lbnRhdG9uLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBpc0hpZGRlbihlbDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcclxuICAgIHJldHVybiBlbC5vZmZzZXRQYXJlbnQgPT09IG51bGw7XHJcbiAgfVxyXG59XHJcbiJdfQ==