import { __decorate, __param, __values } from "tslib";
import { DOCUMENT } from '@angular/common';
import { Inject, } from '@angular/core';
import { DIALOG_TYPE, } from '../config';
var LaunchRenderStrategy = /** @class */ (function () {
    function LaunchRenderStrategy(document, rendererFactory) {
        this.document = document;
        this.rendererFactory = rendererFactory;
        // List of called references; only used for rendered elements
        this.renderedCallers = [];
        /**
         * Classes to apply to the component when the dialog is a DIALOG
         */
        this.dialogClasses = ['d-block', 'fade', 'modal', 'show'];
        /**
         * Classes to apply to the component when the dialog is a POPOVER
         */
        this.popoverClasses = ['cx-dialog-popover'];
        /**
         * Classes to apply to the component when the dialog is a SIDEBAR_END
         */
        this.sidebarEndClasses = ['cx-sidebar-end'];
        /**
         * Classes to apply to the component when the dialog is a SIDEBAR_START
         */
        this.sidebarStartClasses = ['cx-sidebar-start'];
        this.renderer = rendererFactory.createRenderer(null, null);
    }
    /**
     * Determines if element should render
     *
     * @param caller
     * @param config
     */
    LaunchRenderStrategy.prototype.shouldRender = function (caller, config) {
        return (Boolean(config.component) &&
            (this.renderedCallers.some(function (el) { return el.caller === caller; })
                ? !!config.multi
                : true));
    };
    LaunchRenderStrategy.prototype.applyClasses = function (component, dialogType) {
        var e_1, _a;
        var classes = [];
        // TODO: make classes configurable
        switch (dialogType) {
            case DIALOG_TYPE.DIALOG:
                classes = this.dialogClasses;
                this.renderer.addClass(this.document.body, 'modal-open');
                break;
            case DIALOG_TYPE.POPOVER:
                classes = this.popoverClasses;
                break;
            case DIALOG_TYPE.SIDEBAR_END:
                classes = this.sidebarEndClasses;
                break;
            case DIALOG_TYPE.SIDEBAR_START:
                classes = this.sidebarStartClasses;
                break;
        }
        try {
            for (var classes_1 = __values(classes), classes_1_1 = classes_1.next(); !classes_1_1.done; classes_1_1 = classes_1.next()) {
                var newClass = classes_1_1.value;
                this.renderer.addClass(component.location.nativeElement, newClass);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (classes_1_1 && !classes_1_1.done && (_a = classes_1.return)) _a.call(classes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Method to call when rendered element is destroyed
     * The element will be removed from the list of rendered elements
     *
     * @param caller
     * @param _config optional parameters used in children strategies
     */
    LaunchRenderStrategy.prototype.remove = function (caller, config) {
        var _a;
        this.renderedCallers = this.renderedCallers.filter(function (el) { return el.caller !== caller; });
        if (((_a = config) === null || _a === void 0 ? void 0 : _a.dialogType) === DIALOG_TYPE.DIALOG) {
            this.renderer.removeClass(this.document.body, 'modal-open');
        }
    };
    LaunchRenderStrategy.prototype.getPriority = function () {
        return -10 /* LOW */; // low, as it's a default matcher
    };
    LaunchRenderStrategy = __decorate([
        __param(0, Inject(DOCUMENT))
    ], LaunchRenderStrategy);
    return LaunchRenderStrategy;
}());
export { LaunchRenderStrategy };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF1bmNoLXJlbmRlci5zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbImxheW91dC9sYXVuY2gtZGlhbG9nL3NlcnZpY2VzL2xhdW5jaC1yZW5kZXIuc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBRUwsTUFBTSxHQUlQLE1BQU0sZUFBZSxDQUFDO0FBR3ZCLE9BQU8sRUFDTCxXQUFXLEdBSVosTUFBTSxXQUFXLENBQUM7QUFFbkI7SUEyQkUsOEJBQzhCLFFBQWEsRUFDL0IsZUFBaUM7UUFEZixhQUFRLEdBQVIsUUFBUSxDQUFLO1FBQy9CLG9CQUFlLEdBQWYsZUFBZSxDQUFrQjtRQTVCN0MsNkRBQTZEO1FBQ25ELG9CQUFlLEdBSXBCLEVBQUUsQ0FBQztRQUVSOztXQUVHO1FBQ08sa0JBQWEsR0FBRyxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQy9EOztXQUVHO1FBQ08sbUJBQWMsR0FBRyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDakQ7O1dBRUc7UUFDTyxzQkFBaUIsR0FBRyxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFDakQ7O1dBRUc7UUFDTyx3QkFBbUIsR0FBRyxDQUFDLGtCQUFrQixDQUFDLENBQUM7UUFRbkQsSUFBSSxDQUFDLFFBQVEsR0FBRyxlQUFlLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBb0JEOzs7OztPQUtHO0lBQ08sMkNBQVksR0FBdEIsVUFDRSxNQUE4QixFQUM5QixNQUFvQjtRQUVwQixPQUFPLENBQ0wsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUM7WUFDekIsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxVQUFDLEVBQUUsSUFBSyxPQUFBLEVBQUUsQ0FBQyxNQUFNLEtBQUssTUFBTSxFQUFwQixDQUFvQixDQUFDO2dCQUN0RCxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLO2dCQUNoQixDQUFDLENBQUMsSUFBSSxDQUFDLENBQ1YsQ0FBQztJQUNKLENBQUM7SUFFUywyQ0FBWSxHQUF0QixVQUNFLFNBQTRCLEVBQzVCLFVBQXVCOztRQUV2QixJQUFJLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFFakIsa0NBQWtDO1FBQ2xDLFFBQVEsVUFBVSxFQUFFO1lBQ2xCLEtBQUssV0FBVyxDQUFDLE1BQU07Z0JBQ3JCLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO2dCQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztnQkFDekQsTUFBTTtZQUNSLEtBQUssV0FBVyxDQUFDLE9BQU87Z0JBQ3RCLE9BQU8sR0FBRyxJQUFJLENBQUMsY0FBYyxDQUFDO2dCQUM5QixNQUFNO1lBQ1IsS0FBSyxXQUFXLENBQUMsV0FBVztnQkFDMUIsT0FBTyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQztnQkFDakMsTUFBTTtZQUNSLEtBQUssV0FBVyxDQUFDLGFBQWE7Z0JBQzVCLE9BQU8sR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7Z0JBQ25DLE1BQU07U0FDVDs7WUFFRCxLQUF1QixJQUFBLFlBQUEsU0FBQSxPQUFPLENBQUEsZ0NBQUEscURBQUU7Z0JBQTNCLElBQU0sUUFBUSxvQkFBQTtnQkFDakIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxhQUFhLEVBQUUsUUFBUSxDQUFDLENBQUM7YUFDcEU7Ozs7Ozs7OztJQUNILENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSSxxQ0FBTSxHQUFiLFVBQWMsTUFBOEIsRUFBRSxNQUFxQjs7UUFDakUsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FDaEQsVUFBQyxFQUFFLElBQUssT0FBQSxFQUFFLENBQUMsTUFBTSxLQUFLLE1BQU0sRUFBcEIsQ0FBb0IsQ0FDN0IsQ0FBQztRQUVGLElBQUksT0FBQyxNQUF1QiwwQ0FBRSxVQUFVLE1BQUssV0FBVyxDQUFDLE1BQU0sRUFBRTtZQUMvRCxJQUFJLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztTQUM3RDtJQUNILENBQUM7SUFFRCwwQ0FBVyxHQUFYO1FBQ0UscUJBQW9CLENBQUMsaUNBQWlDO0lBQ3hELENBQUM7SUFySG1CLG9CQUFvQjtRQTRCckMsV0FBQSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUE7T0E1QkMsb0JBQW9CLENBc0h6QztJQUFELDJCQUFDO0NBQUEsQUF0SEQsSUFzSEM7U0F0SHFCLG9CQUFvQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHtcclxuICBDb21wb25lbnRSZWYsXHJcbiAgSW5qZWN0LFxyXG4gIFJlbmRlcmVyMixcclxuICBSZW5kZXJlckZhY3RvcnkyLFxyXG4gIFZpZXdDb250YWluZXJSZWYsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IEFwcGxpY2FibGUsIFByaW9yaXR5IH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQge1xyXG4gIERJQUxPR19UWVBFLFxyXG4gIExhdW5jaERpYWxvZyxcclxuICBMYXVuY2hPcHRpb25zLFxyXG4gIExBVU5DSF9DQUxMRVIsXHJcbn0gZnJvbSAnLi4vY29uZmlnJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBMYXVuY2hSZW5kZXJTdHJhdGVneSBpbXBsZW1lbnRzIEFwcGxpY2FibGUge1xyXG4gIC8vIExpc3Qgb2YgY2FsbGVkIHJlZmVyZW5jZXM7IG9ubHkgdXNlZCBmb3IgcmVuZGVyZWQgZWxlbWVudHNcclxuICBwcm90ZWN0ZWQgcmVuZGVyZWRDYWxsZXJzOiBBcnJheTx7XHJcbiAgICBjYWxsZXI6IExBVU5DSF9DQUxMRVIgfCBzdHJpbmc7XHJcbiAgICBlbGVtZW50PzogYW55O1xyXG4gICAgY29tcG9uZW50PzogQ29tcG9uZW50UmVmPGFueT47XHJcbiAgfT4gPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3NlcyB0byBhcHBseSB0byB0aGUgY29tcG9uZW50IHdoZW4gdGhlIGRpYWxvZyBpcyBhIERJQUxPR1xyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBkaWFsb2dDbGFzc2VzID0gWydkLWJsb2NrJywgJ2ZhZGUnLCAnbW9kYWwnLCAnc2hvdyddO1xyXG4gIC8qKlxyXG4gICAqIENsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIGNvbXBvbmVudCB3aGVuIHRoZSBkaWFsb2cgaXMgYSBQT1BPVkVSXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHBvcG92ZXJDbGFzc2VzID0gWydjeC1kaWFsb2ctcG9wb3ZlciddO1xyXG4gIC8qKlxyXG4gICAqIENsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIGNvbXBvbmVudCB3aGVuIHRoZSBkaWFsb2cgaXMgYSBTSURFQkFSX0VORFxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBzaWRlYmFyRW5kQ2xhc3NlcyA9IFsnY3gtc2lkZWJhci1lbmQnXTtcclxuICAvKipcclxuICAgKiBDbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBjb21wb25lbnQgd2hlbiB0aGUgZGlhbG9nIGlzIGEgU0lERUJBUl9TVEFSVFxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBzaWRlYmFyU3RhcnRDbGFzc2VzID0gWydjeC1zaWRlYmFyLXN0YXJ0J107XHJcblxyXG4gIHByb3RlY3RlZCByZW5kZXJlcjogUmVuZGVyZXIyO1xyXG5cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByb3RlY3RlZCBkb2N1bWVudDogYW55LFxyXG4gICAgcHJvdGVjdGVkIHJlbmRlcmVyRmFjdG9yeTogUmVuZGVyZXJGYWN0b3J5MlxyXG4gICkge1xyXG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyRmFjdG9yeS5jcmVhdGVSZW5kZXJlcihudWxsLCBudWxsKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbmRlciBtZXRob2QgdG8gaW1wbGVtZW50IGJhc2VkIG9uIHRoZSBzdHJhdGVneVxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNvbmZpZyBMYXVuY2ggY29uZmlndXJhdGlvblxyXG4gICAqL1xyXG4gIGFic3RyYWN0IHJlbmRlcihcclxuICAgIGNvbmZpZzogTGF1bmNoT3B0aW9ucyxcclxuICAgIGNhbGxlcjogTEFVTkNIX0NBTExFUiB8IHN0cmluZyxcclxuICAgIHZjcj86IFZpZXdDb250YWluZXJSZWZcclxuICApOiB2b2lkIHwgT2JzZXJ2YWJsZTxDb21wb25lbnRSZWY8YW55Pj47XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgaWYgdGhlIHN0cmF0ZWd5IGlzIHRoZSByaWdodCBvbmUgZm9yIHRoZSBwcm92aWRlZCBjb25maWd1cmF0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICovXHJcbiAgYWJzdHJhY3QgaGFzTWF0Y2goY29uZmlnOiBMYXVuY2hPcHRpb25zKTogYm9vbGVhbjtcclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyBpZiBlbGVtZW50IHNob3VsZCByZW5kZXJcclxuICAgKlxyXG4gICAqIEBwYXJhbSBjYWxsZXJcclxuICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHNob3VsZFJlbmRlcihcclxuICAgIGNhbGxlcjogTEFVTkNIX0NBTExFUiB8IHN0cmluZyxcclxuICAgIGNvbmZpZzogTGF1bmNoRGlhbG9nXHJcbiAgKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBCb29sZWFuKGNvbmZpZy5jb21wb25lbnQpICYmXHJcbiAgICAgICh0aGlzLnJlbmRlcmVkQ2FsbGVycy5zb21lKChlbCkgPT4gZWwuY2FsbGVyID09PSBjYWxsZXIpXHJcbiAgICAgICAgPyAhIWNvbmZpZy5tdWx0aVxyXG4gICAgICAgIDogdHJ1ZSlcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgYXBwbHlDbGFzc2VzKFxyXG4gICAgY29tcG9uZW50OiBDb21wb25lbnRSZWY8YW55PixcclxuICAgIGRpYWxvZ1R5cGU6IERJQUxPR19UWVBFXHJcbiAgKTogdm9pZCB7XHJcbiAgICBsZXQgY2xhc3NlcyA9IFtdO1xyXG5cclxuICAgIC8vIFRPRE86IG1ha2UgY2xhc3NlcyBjb25maWd1cmFibGVcclxuICAgIHN3aXRjaCAoZGlhbG9nVHlwZSkge1xyXG4gICAgICBjYXNlIERJQUxPR19UWVBFLkRJQUxPRzpcclxuICAgICAgICBjbGFzc2VzID0gdGhpcy5kaWFsb2dDbGFzc2VzO1xyXG4gICAgICAgIHRoaXMucmVuZGVyZXIuYWRkQ2xhc3ModGhpcy5kb2N1bWVudC5ib2R5LCAnbW9kYWwtb3BlbicpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlIERJQUxPR19UWVBFLlBPUE9WRVI6XHJcbiAgICAgICAgY2xhc3NlcyA9IHRoaXMucG9wb3ZlckNsYXNzZXM7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElBTE9HX1RZUEUuU0lERUJBUl9FTkQ6XHJcbiAgICAgICAgY2xhc3NlcyA9IHRoaXMuc2lkZWJhckVuZENsYXNzZXM7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIGNhc2UgRElBTE9HX1RZUEUuU0lERUJBUl9TVEFSVDpcclxuICAgICAgICBjbGFzc2VzID0gdGhpcy5zaWRlYmFyU3RhcnRDbGFzc2VzO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoY29uc3QgbmV3Q2xhc3Mgb2YgY2xhc3Nlcykge1xyXG4gICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKGNvbXBvbmVudC5sb2NhdGlvbi5uYXRpdmVFbGVtZW50LCBuZXdDbGFzcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNZXRob2QgdG8gY2FsbCB3aGVuIHJlbmRlcmVkIGVsZW1lbnQgaXMgZGVzdHJveWVkXHJcbiAgICogVGhlIGVsZW1lbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3Qgb2YgcmVuZGVyZWQgZWxlbWVudHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSBjYWxsZXJcclxuICAgKiBAcGFyYW0gX2NvbmZpZyBvcHRpb25hbCBwYXJhbWV0ZXJzIHVzZWQgaW4gY2hpbGRyZW4gc3RyYXRlZ2llc1xyXG4gICAqL1xyXG4gIHB1YmxpYyByZW1vdmUoY2FsbGVyOiBMQVVOQ0hfQ0FMTEVSIHwgc3RyaW5nLCBjb25maWc6IExhdW5jaE9wdGlvbnMpOiB2b2lkIHtcclxuICAgIHRoaXMucmVuZGVyZWRDYWxsZXJzID0gdGhpcy5yZW5kZXJlZENhbGxlcnMuZmlsdGVyKFxyXG4gICAgICAoZWwpID0+IGVsLmNhbGxlciAhPT0gY2FsbGVyXHJcbiAgICApO1xyXG5cclxuICAgIGlmICgoY29uZmlnIGFzIExhdW5jaERpYWxvZyk/LmRpYWxvZ1R5cGUgPT09IERJQUxPR19UWVBFLkRJQUxPRykge1xyXG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbW92ZUNsYXNzKHRoaXMuZG9jdW1lbnQuYm9keSwgJ21vZGFsLW9wZW4nKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGdldFByaW9yaXR5KCk6IFByaW9yaXR5IHtcclxuICAgIHJldHVybiBQcmlvcml0eS5MT1c7IC8vIGxvdywgYXMgaXQncyBhIGRlZmF1bHQgbWF0Y2hlclxyXG4gIH1cclxufVxyXG4iXX0=