var _a;
import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { WindowRef } from '@spartacus/core';
import { of } from 'rxjs';
import { distinctUntilChanged, map } from 'rxjs/operators';
import { BREAKPOINT, LayoutConfig } from '../config/layout-config';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
import * as i2 from "../config/layout-config";
var DEFAULT_BREAKPOINTS = (_a = {},
    _a[BREAKPOINT.xs] = 576,
    _a[BREAKPOINT.sm] = 768,
    _a[BREAKPOINT.md] = 992,
    _a[BREAKPOINT.lg] = 1200,
    _a);
var BreakpointService = /** @class */ (function () {
    function BreakpointService(winRef, config) {
        this.winRef = winRef;
        this.config = config;
    }
    Object.defineProperty(BreakpointService.prototype, "breakpoint$", {
        get: function () {
            var _this = this;
            if (!this.window) {
                return of(BREAKPOINT.xs);
            }
            return this.winRef.resize$.pipe(map(function (event) { return _this.getBreakpoint(event.target.innerWidth); }), distinctUntilChanged());
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the _maximum_ size for the breakpint, given by the `LayoutConfig.breakpoints`
     * configuration. If no configuration is available for the given breakpoint, the
     * method will return the default values:
     * - xs: 567
     * - sm: 768
     * - md: 992
     * - lg: 1200
     */
    BreakpointService.prototype.getSize = function (breakpoint) {
        var _a;
        return ((_a = this.config.breakpoints) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(breakpoint)) ? this.config.breakpoints[breakpoint]
            : DEFAULT_BREAKPOINTS[breakpoint];
    };
    Object.defineProperty(BreakpointService.prototype, "breakpoints", {
        /**
         * Returns all available breakpoints for the system.
         */
        get: function () {
            return [
                BREAKPOINT.xs,
                BREAKPOINT.sm,
                BREAKPOINT.md,
                BREAKPOINT.lg,
                BREAKPOINT.xl,
            ];
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates whether the current screen size is smaller than the maximum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is smaller than the configured size of `BREAKPOINT.md`.
     */
    BreakpointService.prototype.isDown = function (breakpoint) {
        var _this = this;
        return this.breakpoint$.pipe(map(function (br) {
            return _this.breakpoints
                .slice(0, _this.breakpoints.indexOf(breakpoint) + 1)
                .includes(br);
        }));
    };
    /**
     * Indicates whether the current screen size is larger than the minimum size of the
     * given breakpoint.
     *
     * If the given breakpoint is `BREAKPOINT.md`, the method returns `true` when the
     * window innerWidth is larger than the configured size of `BREAKPOINT.sm`.
     */
    BreakpointService.prototype.isUp = function (breakpoint) {
        var _this = this;
        return this.breakpoint$.pipe(map(function (br) {
            return _this.breakpoints
                .slice(_this.breakpoints.indexOf(breakpoint))
                .includes(br);
        }));
    };
    /**
     * Indicates whether the current screen size fits to the given breakpoint
     */
    BreakpointService.prototype.isEqual = function (breakpoint) {
        return this.breakpoint$.pipe(map(function (br) { return br === breakpoint; }));
    };
    BreakpointService.prototype.getBreakpoint = function (windowWidth) {
        var breakpoint = this.getClosest(windowWidth);
        return BREAKPOINT[breakpoint || BREAKPOINT.lg];
    };
    BreakpointService.prototype.getClosest = function (windowWidth) {
        var _this = this;
        if (!windowWidth) {
            windowWidth = this.window.innerWidth;
        }
        return windowWidth > this.getSize(BREAKPOINT.lg)
            ? BREAKPOINT.xl
            : this.breakpoints.find(function (br) { return windowWidth <= _this.getSize(br); });
    };
    Object.defineProperty(BreakpointService.prototype, "window", {
        get: function () {
            return this.winRef.nativeWindow;
        },
        enumerable: true,
        configurable: true
    });
    BreakpointService.ctorParameters = function () { return [
        { type: WindowRef },
        { type: LayoutConfig }
    ]; };
    BreakpointService.ɵprov = i0.ɵɵdefineInjectable({ factory: function BreakpointService_Factory() { return new BreakpointService(i0.ɵɵinject(i1.WindowRef), i0.ɵɵinject(i2.LayoutConfig)); }, token: BreakpointService, providedIn: "root" });
    BreakpointService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], BreakpointService);
    return BreakpointService;
}());
export { BreakpointService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWtwb2ludC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9zdG9yZWZyb250LyIsInNvdXJjZXMiOlsibGF5b3V0L2JyZWFrcG9pbnQvYnJlYWtwb2ludC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDNUMsT0FBTyxFQUFjLEVBQUUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0QyxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7OztBQUVuRSxJQUFNLG1CQUFtQjtJQUN2QixHQUFDLFVBQVUsQ0FBQyxFQUFFLElBQUcsR0FBRztJQUNwQixHQUFDLFVBQVUsQ0FBQyxFQUFFLElBQUcsR0FBRztJQUNwQixHQUFDLFVBQVUsQ0FBQyxFQUFFLElBQUcsR0FBRztJQUNwQixHQUFDLFVBQVUsQ0FBQyxFQUFFLElBQUcsSUFBSTtPQUN0QixDQUFDO0FBS0Y7SUFDRSwyQkFBb0IsTUFBaUIsRUFBVSxNQUFvQjtRQUEvQyxXQUFNLEdBQU4sTUFBTSxDQUFXO1FBQVUsV0FBTSxHQUFOLE1BQU0sQ0FBYztJQUFHLENBQUM7SUFFdkUsc0JBQUksMENBQVc7YUFBZjtZQUFBLGlCQVFDO1lBUEMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUU7Z0JBQ2hCLE9BQU8sRUFBRSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQzthQUMxQjtZQUNELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUM3QixHQUFHLENBQUMsVUFBQyxLQUFLLElBQUssT0FBQSxLQUFJLENBQUMsYUFBYSxDQUFVLEtBQUssQ0FB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aUJBQWlCO1FBSDdCLFVBQVUsQ0FBQztZQUNWLFVBQVUsRUFBRSxNQUFNO1NBQ25CLENBQUM7T0FDVyxpQkFBaUIsQ0FvRzdCOzRCQXBIRDtDQW9IQyxBQXBHRCxJQW9HQztTQXBHWSxpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFdpbmRvd1JlZiB9IGZyb20gJ0BzcGFydGFjdXMvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGRpc3RpbmN0VW50aWxDaGFuZ2VkLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IEJSRUFLUE9JTlQsIExheW91dENvbmZpZyB9IGZyb20gJy4uL2NvbmZpZy9sYXlvdXQtY29uZmlnJztcclxuXHJcbmNvbnN0IERFRkFVTFRfQlJFQUtQT0lOVFMgPSB7XHJcbiAgW0JSRUFLUE9JTlQueHNdOiA1NzYsXHJcbiAgW0JSRUFLUE9JTlQuc21dOiA3NjgsXHJcbiAgW0JSRUFLUE9JTlQubWRdOiA5OTIsXHJcbiAgW0JSRUFLUE9JTlQubGddOiAxMjAwLFxyXG59O1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIEJyZWFrcG9pbnRTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHdpblJlZjogV2luZG93UmVmLCBwcml2YXRlIGNvbmZpZzogTGF5b3V0Q29uZmlnKSB7fVxyXG5cclxuICBnZXQgYnJlYWtwb2ludCQoKTogT2JzZXJ2YWJsZTxCUkVBS1BPSU5UPiB7XHJcbiAgICBpZiAoIXRoaXMud2luZG93KSB7XHJcbiAgICAgIHJldHVybiBvZihCUkVBS1BPSU5ULnhzKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLndpblJlZi5yZXNpemUkLnBpcGUoXHJcbiAgICAgIG1hcCgoZXZlbnQpID0+IHRoaXMuZ2V0QnJlYWtwb2ludCgoPFdpbmRvdz5ldmVudC50YXJnZXQpLmlubmVyV2lkdGgpKSxcclxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIF9tYXhpbXVtXyBzaXplIGZvciB0aGUgYnJlYWtwaW50LCBnaXZlbiBieSB0aGUgYExheW91dENvbmZpZy5icmVha3BvaW50c2BcclxuICAgKiBjb25maWd1cmF0aW9uLiBJZiBubyBjb25maWd1cmF0aW9uIGlzIGF2YWlsYWJsZSBmb3IgdGhlIGdpdmVuIGJyZWFrcG9pbnQsIHRoZVxyXG4gICAqIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgZGVmYXVsdCB2YWx1ZXM6XHJcbiAgICogLSB4czogNTY3XHJcbiAgICogLSBzbTogNzY4XHJcbiAgICogLSBtZDogOTkyXHJcbiAgICogLSBsZzogMTIwMFxyXG4gICAqL1xyXG4gIGdldFNpemUoYnJlYWtwb2ludDogQlJFQUtQT0lOVCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5jb25maWcuYnJlYWtwb2ludHM/Lmhhc093blByb3BlcnR5KGJyZWFrcG9pbnQpXHJcbiAgICAgID8gdGhpcy5jb25maWcuYnJlYWtwb2ludHNbYnJlYWtwb2ludF1cclxuICAgICAgOiBERUZBVUxUX0JSRUFLUE9JTlRTW2JyZWFrcG9pbnRdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhbGwgYXZhaWxhYmxlIGJyZWFrcG9pbnRzIGZvciB0aGUgc3lzdGVtLlxyXG4gICAqL1xyXG4gIGdldCBicmVha3BvaW50cygpOiBCUkVBS1BPSU5UW10ge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgQlJFQUtQT0lOVC54cyxcclxuICAgICAgQlJFQUtQT0lOVC5zbSxcclxuICAgICAgQlJFQUtQT0lOVC5tZCxcclxuICAgICAgQlJFQUtQT0lOVC5sZyxcclxuICAgICAgQlJFQUtQT0lOVC54bCxcclxuICAgIF07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gc2l6ZSBpcyBzbWFsbGVyIHRoYW4gdGhlIG1heGltdW0gc2l6ZSBvZiB0aGVcclxuICAgKiBnaXZlbiBicmVha3BvaW50LlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGdpdmVuIGJyZWFrcG9pbnQgaXMgYEJSRUFLUE9JTlQubWRgLCB0aGUgbWV0aG9kIHJldHVybnMgYHRydWVgIHdoZW4gdGhlXHJcbiAgICogd2luZG93IGlubmVyV2lkdGggaXMgc21hbGxlciB0aGFuIHRoZSBjb25maWd1cmVkIHNpemUgb2YgYEJSRUFLUE9JTlQubWRgLlxyXG4gICAqL1xyXG4gIGlzRG93bihicmVha3BvaW50OiBCUkVBS1BPSU5UKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5icmVha3BvaW50JC5waXBlKFxyXG4gICAgICBtYXAoKGJyKSA9PlxyXG4gICAgICAgIHRoaXMuYnJlYWtwb2ludHNcclxuICAgICAgICAgIC5zbGljZSgwLCB0aGlzLmJyZWFrcG9pbnRzLmluZGV4T2YoYnJlYWtwb2ludCkgKyAxKVxyXG4gICAgICAgICAgLmluY2x1ZGVzKGJyKVxyXG4gICAgICApXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGN1cnJlbnQgc2NyZWVuIHNpemUgaXMgbGFyZ2VyIHRoYW4gdGhlIG1pbmltdW0gc2l6ZSBvZiB0aGVcclxuICAgKiBnaXZlbiBicmVha3BvaW50LlxyXG4gICAqXHJcbiAgICogSWYgdGhlIGdpdmVuIGJyZWFrcG9pbnQgaXMgYEJSRUFLUE9JTlQubWRgLCB0aGUgbWV0aG9kIHJldHVybnMgYHRydWVgIHdoZW4gdGhlXHJcbiAgICogd2luZG93IGlubmVyV2lkdGggaXMgbGFyZ2VyIHRoYW4gdGhlIGNvbmZpZ3VyZWQgc2l6ZSBvZiBgQlJFQUtQT0lOVC5zbWAuXHJcbiAgICovXHJcbiAgaXNVcChicmVha3BvaW50OiBCUkVBS1BPSU5UKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5icmVha3BvaW50JC5waXBlKFxyXG4gICAgICBtYXAoKGJyKSA9PlxyXG4gICAgICAgIHRoaXMuYnJlYWtwb2ludHNcclxuICAgICAgICAgIC5zbGljZSh0aGlzLmJyZWFrcG9pbnRzLmluZGV4T2YoYnJlYWtwb2ludCkpXHJcbiAgICAgICAgICAuaW5jbHVkZXMoYnIpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY3VycmVudCBzY3JlZW4gc2l6ZSBmaXRzIHRvIHRoZSBnaXZlbiBicmVha3BvaW50XHJcbiAgICovXHJcbiAgaXNFcXVhbChicmVha3BvaW50OiBCUkVBS1BPSU5UKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XHJcbiAgICByZXR1cm4gdGhpcy5icmVha3BvaW50JC5waXBlKG1hcCgoYnIpID0+IGJyID09PSBicmVha3BvaW50KSk7XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0QnJlYWtwb2ludCh3aW5kb3dXaWR0aDogbnVtYmVyKTogQlJFQUtQT0lOVCB7XHJcbiAgICBjb25zdCBicmVha3BvaW50ID0gdGhpcy5nZXRDbG9zZXN0KHdpbmRvd1dpZHRoKTtcclxuICAgIHJldHVybiBCUkVBS1BPSU5UW2JyZWFrcG9pbnQgfHwgQlJFQUtQT0lOVC5sZ107XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0Q2xvc2VzdCh3aW5kb3dXaWR0aD86IG51bWJlcik6IEJSRUFLUE9JTlQge1xyXG4gICAgaWYgKCF3aW5kb3dXaWR0aCkge1xyXG4gICAgICB3aW5kb3dXaWR0aCA9IHRoaXMud2luZG93LmlubmVyV2lkdGg7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHdpbmRvd1dpZHRoID4gdGhpcy5nZXRTaXplKEJSRUFLUE9JTlQubGcpXHJcbiAgICAgID8gQlJFQUtQT0lOVC54bFxyXG4gICAgICA6IHRoaXMuYnJlYWtwb2ludHMuZmluZCgoYnIpID0+IHdpbmRvd1dpZHRoIDw9IHRoaXMuZ2V0U2l6ZShicikpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHdpbmRvdygpOiBXaW5kb3cge1xyXG4gICAgcmV0dXJuIHRoaXMud2luUmVmLm5hdGl2ZVdpbmRvdztcclxuICB9XHJcbn1cclxuIl19