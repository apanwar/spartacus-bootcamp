import { __decorate } from "tslib";
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, HostBinding, Input, OnDestroy, OnInit, Renderer2, } from '@angular/core';
import { CmsService, ContentSlotComponentData, ContentSlotData, DynamicAttributeService, } from '@spartacus/core';
import { BehaviorSubject, Subscription } from 'rxjs';
import { distinctUntilChanged, map, switchMap, tap } from 'rxjs/operators';
import { CmsComponentsService } from '../../services/cms-components.service';
/**
 * The `PageSlotComponent` is used to render the CMS page slot and it's components.
 *
 * The Page slot host element will be supplemented with css classes so that the layout
 * can be fully controlled by customers:
 * - The page slot _position_ is added as a css class by default.
 * - The `cx-pending` is added for as long as the slot hasn't start loading.
 * - The `page-fold` style class is added for the page slot which is configured as the page fold.
 */
var PageSlotComponent = /** @class */ (function () {
    function PageSlotComponent(cmsService, dynamicAttributeService, renderer, elementRef, cmsComponentsService, cd) {
        var _this = this;
        this.cmsService = cmsService;
        this.dynamicAttributeService = dynamicAttributeService;
        this.renderer = renderer;
        this.elementRef = elementRef;
        this.cmsComponentsService = cmsComponentsService;
        this.cd = cd;
        /**
         * Indicates that the page slot is the last page slot above the fold.
         */
        this.isPageFold = false;
        /**
         * Indicates that the components of the page slot haven't been loaded as long
         * as the isPending state is true.
         */
        this.isPending = true;
        /**
         * Indicates that the page slot doesn't contain any components. This is no
         * longer used in spartacus, but kept for backwards compatibility.
         */
        this.hasComponents = false;
        this.position$ = new BehaviorSubject(undefined);
        this.slot$ = this.position$.pipe(switchMap(function (position) { return _this.cmsService.getContentSlot(position); }), distinctUntilChanged(this.isDistinct));
        /** Observes the components for the given page slot. */
        this.components$ = this.slot$.pipe(map(function (slot) { var _a; return (_a = slot === null || slot === void 0 ? void 0 : slot.components) !== null && _a !== void 0 ? _a : []; }));
        this.subscription = new Subscription();
        /** Keeps track of the pending components that must be loaded for the page slot */
        this.pendingComponentCount = 0;
    }
    Object.defineProperty(PageSlotComponent.prototype, "position", {
        get: function () {
            return this.position$.value;
        },
        /**
         * The position represents the unique key for a page slot on a single page, but can
         * be reused cross pages.
         *
         * The position is used to find the CMS components for the page slot. It is also
         * added as an additional CSS class so that layoutt can be applied.
         */
        set: function (value) {
            this.position$.next(value);
        },
        enumerable: true,
        configurable: true
    });
    PageSlotComponent.prototype.ngOnInit = function () {
        var _this = this;
        this.subscription.add(this.slot$.pipe(tap(function (slot) { return _this.decorate(slot); })).subscribe(function (value) {
            _this.components = (value === null || value === void 0 ? void 0 : value.components) || [];
            _this.cd.markForCheck();
        }));
    };
    PageSlotComponent.prototype.decorate = function (slot) {
        var _a, _b;
        var cls = this.class || '';
        if (this.lastPosition && cls.indexOf(this.lastPosition) > -1) {
            cls = cls.replace(this.lastPosition, '');
        }
        if (this.position$.value) {
            cls += " " + this.position$.value;
            this.lastPosition = this.position$.value;
        }
        // host bindings
        this.pending = ((_a = slot === null || slot === void 0 ? void 0 : slot.components) === null || _a === void 0 ? void 0 : _a.length) || 0;
        this.hasComponents = ((_b = slot === null || slot === void 0 ? void 0 : slot.components) === null || _b === void 0 ? void 0 : _b.length) > 0;
        if (cls && cls !== this.class) {
            this.class = cls;
        }
        this.addSmartEditSlotClass(slot);
    };
    Object.defineProperty(PageSlotComponent.prototype, "pending", {
        get: function () {
            return this.pendingComponentCount;
        },
        /**
         * Sets the pending count for the page slot components. Once all pending components are
         * loaded, the `isPending` flag is updated, so that the associated class can be updated
         */
        set: function (count) {
            this.pendingComponentCount = count;
            this.isPending = this.pendingComponentCount > 0;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Is triggered when a component is added to the view. This is used to
     * update the pending count
     */
    PageSlotComponent.prototype.isLoaded = function (loadState) {
        if (loadState) {
            this.pending--;
            this.cd.markForCheck();
        }
    };
    /**
     * The `DeferLoadingStrategy` indicates whether the component should be
     * rendered instantly or whether it should be deferred.
     */
    PageSlotComponent.prototype.getComponentDeferOptions = function (componentType) {
        var deferLoading = this.cmsComponentsService.getDeferLoadingStrategy(componentType);
        return { deferLoading: deferLoading };
    };
    PageSlotComponent.prototype.isDistinct = function (old, current) {
        var _a;
        return (current.components &&
            ((_a = old.components) === null || _a === void 0 ? void 0 : _a.length) === current.components.length &&
            !old.components.find(function (el, index) { return el.uid !== current.components[index].uid; }));
    };
    PageSlotComponent.prototype.addSmartEditSlotClass = function (slot) {
        if (slot) {
            this.dynamicAttributeService.addDynamicAttributes(this.elementRef.nativeElement, this.renderer, { slotData: slot });
        }
    };
    PageSlotComponent.prototype.ngOnDestroy = function () {
        var _a;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
    };
    PageSlotComponent.ctorParameters = function () { return [
        { type: CmsService },
        { type: DynamicAttributeService },
        { type: Renderer2 },
        { type: ElementRef },
        { type: CmsComponentsService },
        { type: ChangeDetectorRef }
    ]; };
    __decorate([
        Input()
    ], PageSlotComponent.prototype, "position", null);
    __decorate([
        Input(), HostBinding()
    ], PageSlotComponent.prototype, "class", void 0);
    __decorate([
        HostBinding('class.page-fold'), Input()
    ], PageSlotComponent.prototype, "isPageFold", void 0);
    __decorate([
        HostBinding('class.cx-pending')
    ], PageSlotComponent.prototype, "isPending", void 0);
    __decorate([
        HostBinding('class.has-components'), Input()
    ], PageSlotComponent.prototype, "hasComponents", void 0);
    PageSlotComponent = __decorate([
        Component({
            selector: 'cx-page-slot,[cx-page-slot]',
            template: "<ng-template\r\n  [cxOutlet]=\"position\"\r\n  [cxOutletContext]=\"{ components$: components$ }\"\r\n>\r\n  <ng-template\r\n    *ngFor=\"let component of components\"\r\n    [cxOutlet]=\"component.flexType\"\r\n    [cxOutletContext]=\"{ component: component }\"\r\n    [cxOutletDefer]=\"getComponentDeferOptions(component.flexType)\"\r\n    (loaded)=\"isLoaded($event)\"\r\n  >\r\n    <ng-container [cxComponentWrapper]=\"component\"></ng-container>\r\n  </ng-template>\r\n</ng-template>\r\n",
            changeDetection: ChangeDetectionStrategy.OnPush
        })
    ], PageSlotComponent);
    return PageSlotComponent;
}());
export { PageSlotComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS1zbG90LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbImNtcy1zdHJ1Y3R1cmUvcGFnZS9zbG90L3BhZ2Utc2xvdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFDTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFDTCxTQUFTLEVBQ1QsTUFBTSxFQUNOLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQ0wsVUFBVSxFQUNWLHdCQUF3QixFQUN4QixlQUFlLEVBQ2YsdUJBQXVCLEdBQ3hCLE1BQU0saUJBQWlCLENBQUM7QUFDekIsT0FBTyxFQUFFLGVBQWUsRUFBYyxZQUFZLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDakUsT0FBTyxFQUFFLG9CQUFvQixFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0UsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFFN0U7Ozs7Ozs7O0dBUUc7QUFNSDtJQTBERSwyQkFDWSxVQUFzQixFQUN0Qix1QkFBZ0QsRUFDaEQsUUFBbUIsRUFDbkIsVUFBc0IsRUFDdEIsb0JBQTBDLEVBQzFDLEVBQXFCO1FBTmpDLGlCQU9JO1FBTlEsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0Qiw0QkFBdUIsR0FBdkIsdUJBQXVCLENBQXlCO1FBQ2hELGFBQVEsR0FBUixRQUFRLENBQVc7UUFDbkIsZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUN0Qix5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBQzFDLE9BQUUsR0FBRixFQUFFLENBQW1CO1FBNUNqQzs7V0FFRztRQUNzQyxlQUFVLEdBQUcsS0FBSyxDQUFDO1FBRTVEOzs7V0FHRztRQUM4QixjQUFTLEdBQUcs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Q0FBQyxvQkFBb0IsQ0FDL0MsSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLEVBQzdCLElBQUksQ0FBQyxRQUFRLEVBQ2IsRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQ25CLENBQUM7U0FDSDtJQUNILENBQUM7SUFFRCx1Q0FBVyxHQUFYOztRQUNFLE1BQUEsSUFBSSxDQUFDLFlBQVksMENBQUUsV0FBVyxHQUFHO0lBQ25DLENBQUM7O2dCQS9GdUIsVUFBVTtnQkFDRyx1QkFBdUI7Z0JBQ3RDLFNBQVM7Z0JBQ1AsVUFBVTtnQkFDQSxvQkFBb0I7Z0JBQ3RDLGlCQUFpQjs7SUF4RHhCO1FBQVIsS0FBSyxFQUFFO3FEQUVQO0lBUXVCO1FBQXZCLEtBQUssRUFBRSxFQUFFLFdBQVcsRUFBRTtvREFBZTtJQUtHO1FBQXhDLFdBQVcsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLEtBQUssRUFBRTt5REFBb0I7SUFNM0I7UUFBaEMsV0FBVyxDQUFDLGtCQUFrQixDQUFDO3dEQUFrQjtJQU1KO1FBQTdDLFdBQVcsQ0FBQyxzQkFBc0IsQ0FBQyxFQUFFLEtBQUssRUFBRTs0REFBdUI7SUFuQ3pELGlCQUFpQjtRQUw3QixTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsNkJBQTZCO1lBQ3ZDLHVmQUF5QztZQUN6QyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTtTQUNoRCxDQUFDO09BQ1csaUJBQWlCLENBMko3QjtJQUFELHdCQUFDO0NBQUEsQUEzSkQsSUEySkM7U0EzSlksaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcclxuICBDaGFuZ2VEZXRlY3RvclJlZixcclxuICBDb21wb25lbnQsXHJcbiAgRWxlbWVudFJlZixcclxuICBIb3N0QmluZGluZyxcclxuICBJbnB1dCxcclxuICBPbkRlc3Ryb3ksXHJcbiAgT25Jbml0LFxyXG4gIFJlbmRlcmVyMixcclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHtcclxuICBDbXNTZXJ2aWNlLFxyXG4gIENvbnRlbnRTbG90Q29tcG9uZW50RGF0YSxcclxuICBDb250ZW50U2xvdERhdGEsXHJcbiAgRHluYW1pY0F0dHJpYnV0ZVNlcnZpY2UsXHJcbn0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBPYnNlcnZhYmxlLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcCwgc3dpdGNoTWFwLCB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IEludGVyc2VjdGlvbk9wdGlvbnMgfSBmcm9tICcuLi8uLi8uLi9sYXlvdXQvbG9hZGluZy9pbnRlcnNlY3Rpb24ubW9kZWwnO1xyXG5pbXBvcnQgeyBDbXNDb21wb25lbnRzU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2Ntcy1jb21wb25lbnRzLnNlcnZpY2UnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBgUGFnZVNsb3RDb21wb25lbnRgIGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBDTVMgcGFnZSBzbG90IGFuZCBpdCdzIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIFRoZSBQYWdlIHNsb3QgaG9zdCBlbGVtZW50IHdpbGwgYmUgc3VwcGxlbWVudGVkIHdpdGggY3NzIGNsYXNzZXMgc28gdGhhdCB0aGUgbGF5b3V0XHJcbiAqIGNhbiBiZSBmdWxseSBjb250cm9sbGVkIGJ5IGN1c3RvbWVyczpcclxuICogLSBUaGUgcGFnZSBzbG90IF9wb3NpdGlvbl8gaXMgYWRkZWQgYXMgYSBjc3MgY2xhc3MgYnkgZGVmYXVsdC5cclxuICogLSBUaGUgYGN4LXBlbmRpbmdgIGlzIGFkZGVkIGZvciBhcyBsb25nIGFzIHRoZSBzbG90IGhhc24ndCBzdGFydCBsb2FkaW5nLlxyXG4gKiAtIFRoZSBgcGFnZS1mb2xkYCBzdHlsZSBjbGFzcyBpcyBhZGRlZCBmb3IgdGhlIHBhZ2Ugc2xvdCB3aGljaCBpcyBjb25maWd1cmVkIGFzIHRoZSBwYWdlIGZvbGQuXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ2N4LXBhZ2Utc2xvdCxbY3gtcGFnZS1zbG90XScsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL3BhZ2Utc2xvdC5jb21wb25lbnQuaHRtbCcsXHJcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBQYWdlU2xvdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcclxuICAvKipcclxuICAgKiBUaGUgcG9zaXRpb24gcmVwcmVzZW50cyB0aGUgdW5pcXVlIGtleSBmb3IgYSBwYWdlIHNsb3Qgb24gYSBzaW5nbGUgcGFnZSwgYnV0IGNhblxyXG4gICAqIGJlIHJldXNlZCBjcm9zcyBwYWdlcy5cclxuICAgKlxyXG4gICAqIFRoZSBwb3NpdGlvbiBpcyB1c2VkIHRvIGZpbmQgdGhlIENNUyBjb21wb25lbnRzIGZvciB0aGUgcGFnZSBzbG90LiBJdCBpcyBhbHNvXHJcbiAgICogYWRkZWQgYXMgYW4gYWRkaXRpb25hbCBDU1MgY2xhc3Mgc28gdGhhdCBsYXlvdXR0IGNhbiBiZSBhcHBsaWVkLlxyXG4gICAqL1xyXG4gIEBJbnB1dCgpIHNldCBwb3NpdGlvbih2YWx1ZTogc3RyaW5nKSB7XHJcbiAgICB0aGlzLnBvc2l0aW9uJC5uZXh0KHZhbHVlKTtcclxuICB9XHJcbiAgZ2V0IHBvc2l0aW9uKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5wb3NpdGlvbiQudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYWludGFpbnMgY3NzIGNsYXNzZXMgaW50cm9kdWNlZCBieSB0aGUgaG9zdCBhbmQgYWRkcyBhZGRpdGlvbmFsIGNsYXNzZXMuXHJcbiAgICovXHJcbiAgQElucHV0KCkgQEhvc3RCaW5kaW5nKCkgY2xhc3M6IHN0cmluZztcclxuXHJcbiAgLyoqXHJcbiAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHBhZ2Ugc2xvdCBpcyB0aGUgbGFzdCBwYWdlIHNsb3QgYWJvdmUgdGhlIGZvbGQuXHJcbiAgICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5wYWdlLWZvbGQnKSBASW5wdXQoKSBpc1BhZ2VGb2xkID0gZmFsc2U7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSBjb21wb25lbnRzIG9mIHRoZSBwYWdlIHNsb3QgaGF2ZW4ndCBiZWVuIGxvYWRlZCBhcyBsb25nXHJcbiAgICogYXMgdGhlIGlzUGVuZGluZyBzdGF0ZSBpcyB0cnVlLlxyXG4gICAqL1xyXG4gIEBIb3N0QmluZGluZygnY2xhc3MuY3gtcGVuZGluZycpIGlzUGVuZGluZyA9IHRydWU7XHJcblxyXG4gIC8qKlxyXG4gICAqIEluZGljYXRlcyB0aGF0IHRoZSBwYWdlIHNsb3QgZG9lc24ndCBjb250YWluIGFueSBjb21wb25lbnRzLiBUaGlzIGlzIG5vXHJcbiAgICogbG9uZ2VyIHVzZWQgaW4gc3BhcnRhY3VzLCBidXQga2VwdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXHJcbiAgICovXHJcbiAgQEhvc3RCaW5kaW5nKCdjbGFzcy5oYXMtY29tcG9uZW50cycpIEBJbnB1dCgpIGhhc0NvbXBvbmVudHMgPSBmYWxzZTtcclxuXHJcbiAgcHJvdGVjdGVkIHBvc2l0aW9uJDogQmVoYXZpb3JTdWJqZWN0PHN0cmluZz4gPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHVuZGVmaW5lZCk7XHJcblxyXG4gIGNvbXBvbmVudHM6IENvbnRlbnRTbG90Q29tcG9uZW50RGF0YVtdO1xyXG5cclxuICBwcm90ZWN0ZWQgc2xvdCQ6IE9ic2VydmFibGU8Q29udGVudFNsb3REYXRhPiA9IHRoaXMucG9zaXRpb24kLnBpcGUoXHJcbiAgICBzd2l0Y2hNYXAoKHBvc2l0aW9uKSA9PiB0aGlzLmNtc1NlcnZpY2UuZ2V0Q29udGVudFNsb3QocG9zaXRpb24pKSxcclxuICAgIGRpc3RpbmN0VW50aWxDaGFuZ2VkKHRoaXMuaXNEaXN0aW5jdClcclxuICApO1xyXG5cclxuICAvKiogT2JzZXJ2ZXMgdGhlIGNvbXBvbmVudHMgZm9yIHRoZSBnaXZlbiBwYWdlIHNsb3QuICovXHJcbiAgY29tcG9uZW50cyQ6IE9ic2VydmFibGU8Q29udGVudFNsb3RDb21wb25lbnREYXRhW10+ID0gdGhpcy5zbG90JC5waXBlKFxyXG4gICAgbWFwKChzbG90KSA9PiBzbG90Py5jb21wb25lbnRzID8/IFtdKVxyXG4gICk7XHJcblxyXG4gIHByb3RlY3RlZCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuXHJcbiAgLyoqIEtlZXBzIHRyYWNrIG9mIHRoZSBwZW5kaW5nIGNvbXBvbmVudHMgdGhhdCBtdXN0IGJlIGxvYWRlZCBmb3IgdGhlIHBhZ2Ugc2xvdCAqL1xyXG4gIHByaXZhdGUgcGVuZGluZ0NvbXBvbmVudENvdW50ID0gMDtcclxuXHJcbiAgLyoqIFRyYWNrcyB0aGUgbGFzdCB1c2VkIHBvc2l0aW9uLCBpbiBjYXNlIHRoZSBwYWdlIHNsb3QgaXMgdXNlZCBkeW5hbWljYWxseSAqL1xyXG4gIHByaXZhdGUgbGFzdFBvc2l0aW9uOiBzdHJpbmc7XHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcm90ZWN0ZWQgY21zU2VydmljZTogQ21zU2VydmljZSxcclxuICAgIHByb3RlY3RlZCBkeW5hbWljQXR0cmlidXRlU2VydmljZTogRHluYW1pY0F0dHJpYnV0ZVNlcnZpY2UsXHJcbiAgICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyMixcclxuICAgIHByb3RlY3RlZCBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgcHJvdGVjdGVkIGNtc0NvbXBvbmVudHNTZXJ2aWNlOiBDbXNDb21wb25lbnRzU2VydmljZSxcclxuICAgIHByb3RlY3RlZCBjZDogQ2hhbmdlRGV0ZWN0b3JSZWZcclxuICApIHt9XHJcblxyXG4gIG5nT25Jbml0KCkge1xyXG4gICAgdGhpcy5zdWJzY3JpcHRpb24uYWRkKFxyXG4gICAgICB0aGlzLnNsb3QkLnBpcGUodGFwKChzbG90KSA9PiB0aGlzLmRlY29yYXRlKHNsb3QpKSkuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IHZhbHVlPy5jb21wb25lbnRzIHx8IFtdO1xyXG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICAgIH0pXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGRlY29yYXRlKHNsb3Q6IENvbnRlbnRTbG90RGF0YSk6IHZvaWQge1xyXG4gICAgbGV0IGNscyA9IHRoaXMuY2xhc3MgfHwgJyc7XHJcblxyXG4gICAgaWYgKHRoaXMubGFzdFBvc2l0aW9uICYmIGNscy5pbmRleE9mKHRoaXMubGFzdFBvc2l0aW9uKSA+IC0xKSB7XHJcbiAgICAgIGNscyA9IGNscy5yZXBsYWNlKHRoaXMubGFzdFBvc2l0aW9uLCAnJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5wb3NpdGlvbiQudmFsdWUpIHtcclxuICAgICAgY2xzICs9IGAgJHt0aGlzLnBvc2l0aW9uJC52YWx1ZX1gO1xyXG4gICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24kLnZhbHVlO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIGhvc3QgYmluZGluZ3NcclxuICAgIHRoaXMucGVuZGluZyA9IHNsb3Q/LmNvbXBvbmVudHM/Lmxlbmd0aCB8fCAwO1xyXG4gICAgdGhpcy5oYXNDb21wb25lbnRzID0gc2xvdD8uY29tcG9uZW50cz8ubGVuZ3RoID4gMDtcclxuICAgIGlmIChjbHMgJiYgY2xzICE9PSB0aGlzLmNsYXNzKSB7XHJcbiAgICAgIHRoaXMuY2xhc3MgPSBjbHM7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5hZGRTbWFydEVkaXRTbG90Q2xhc3Moc2xvdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSBwZW5kaW5nIGNvdW50IGZvciB0aGUgcGFnZSBzbG90IGNvbXBvbmVudHMuIE9uY2UgYWxsIHBlbmRpbmcgY29tcG9uZW50cyBhcmVcclxuICAgKiBsb2FkZWQsIHRoZSBgaXNQZW5kaW5nYCBmbGFnIGlzIHVwZGF0ZWQsIHNvIHRoYXQgdGhlIGFzc29jaWF0ZWQgY2xhc3MgY2FuIGJlIHVwZGF0ZWRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgc2V0IHBlbmRpbmcoY291bnQ6IG51bWJlcikge1xyXG4gICAgdGhpcy5wZW5kaW5nQ29tcG9uZW50Q291bnQgPSBjb3VudDtcclxuICAgIHRoaXMuaXNQZW5kaW5nID0gdGhpcy5wZW5kaW5nQ29tcG9uZW50Q291bnQgPiAwO1xyXG4gIH1cclxuXHJcbiAgcHJvdGVjdGVkIGdldCBwZW5kaW5nKCk6IG51bWJlciB7XHJcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nQ29tcG9uZW50Q291bnQ7XHJcbiAgfVxyXG5cclxuICAvKlxyXG4gICAqIElzIHRyaWdnZXJlZCB3aGVuIGEgY29tcG9uZW50IGlzIGFkZGVkIHRvIHRoZSB2aWV3LiBUaGlzIGlzIHVzZWQgdG9cclxuICAgKiB1cGRhdGUgdGhlIHBlbmRpbmcgY291bnRcclxuICAgKi9cclxuICBpc0xvYWRlZChsb2FkU3RhdGU6IGJvb2xlYW4pIHtcclxuICAgIGlmIChsb2FkU3RhdGUpIHtcclxuICAgICAgdGhpcy5wZW5kaW5nLS07XHJcbiAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgYERlZmVyTG9hZGluZ1N0cmF0ZWd5YCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgY29tcG9uZW50IHNob3VsZCBiZVxyXG4gICAqIHJlbmRlcmVkIGluc3RhbnRseSBvciB3aGV0aGVyIGl0IHNob3VsZCBiZSBkZWZlcnJlZC5cclxuICAgKi9cclxuICBnZXRDb21wb25lbnREZWZlck9wdGlvbnMoY29tcG9uZW50VHlwZTogc3RyaW5nKTogSW50ZXJzZWN0aW9uT3B0aW9ucyB7XHJcbiAgICBjb25zdCBkZWZlckxvYWRpbmcgPSB0aGlzLmNtc0NvbXBvbmVudHNTZXJ2aWNlLmdldERlZmVyTG9hZGluZ1N0cmF0ZWd5KFxyXG4gICAgICBjb21wb25lbnRUeXBlXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHsgZGVmZXJMb2FkaW5nIH07XHJcbiAgfVxyXG5cclxuICBwcm90ZWN0ZWQgaXNEaXN0aW5jdChvbGQ6IENvbnRlbnRTbG90RGF0YSwgY3VycmVudDogQ29udGVudFNsb3REYXRhKSB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBjdXJyZW50LmNvbXBvbmVudHMgJiZcclxuICAgICAgb2xkLmNvbXBvbmVudHM/Lmxlbmd0aCA9PT0gY3VycmVudC5jb21wb25lbnRzLmxlbmd0aCAmJlxyXG4gICAgICAhb2xkLmNvbXBvbmVudHMuZmluZChcclxuICAgICAgICAoZWwsIGluZGV4KSA9PiBlbC51aWQgIT09IGN1cnJlbnQuY29tcG9uZW50c1tpbmRleF0udWlkXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFkZFNtYXJ0RWRpdFNsb3RDbGFzcyhzbG90OiBDb250ZW50U2xvdERhdGEpOiB2b2lkIHtcclxuICAgIGlmIChzbG90KSB7XHJcbiAgICAgIHRoaXMuZHluYW1pY0F0dHJpYnV0ZVNlcnZpY2UuYWRkRHluYW1pY0F0dHJpYnV0ZXMoXHJcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsXHJcbiAgICAgICAgdGhpcy5yZW5kZXJlcixcclxuICAgICAgICB7IHNsb3REYXRhOiBzbG90IH1cclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5zdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG59XHJcbiJdfQ==