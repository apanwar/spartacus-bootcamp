import { __decorate, __param } from "tslib";
import { Inject, Injectable } from '@angular/core';
import { Config } from '@spartacus/core';
import { BreakpointService } from '../../../layout/breakpoint/breakpoint.service';
import * as i0 from "@angular/core";
import * as i1 from "@spartacus/core";
import * as i2 from "../../../layout/breakpoint/breakpoint.service";
/**
 * Service which generates media URLs. It leverage the MediaContainer and MediaFormats so
 * that URLs and sizes are generated for the same media. This helps to improve performance
 * across difference devices and layouts.
 *
 * Media formats are optional, but highly recommended. The format will help the browser to
 * identify the right media for the right experience.
 *
 * The MediaService will generate absolute URLs in case relative URLs are provided for the Media.
 * The baseUrl is read from the `occConfig.backend.media.baseUrl` or
 * `occConfig.backend.occ.baseUrl`.
 */
var MediaService = /** @class */ (function () {
    function MediaService(config, 
    /**
     * The BreakpointService is no longer used in version 2.0 as the different size formats are
     * driven by configuration only. There's however a change that this service will play a role
     * in the near future, which is why we keep the constructor as-is.
     */
    breakpointService) {
        this.config = config;
        this.breakpointService = breakpointService;
    }
    /**
     * Returns a `Media` object with the main media (`src`) and various media (`src`)
     * for specific formats.
     */
    MediaService.prototype.getMedia = function (mediaContainer, format, alt) {
        if (!mediaContainer) {
            return;
        }
        var mainMedia = mediaContainer.url
            ? mediaContainer
            : this.resolveMedia(mediaContainer, format);
        return {
            src: this.resolveAbsoluteUrl(mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.url),
            alt: alt || (mainMedia === null || mainMedia === void 0 ? void 0 : mainMedia.altText),
            srcset: this.resolveSrcSet(mediaContainer),
        };
    };
    Object.defineProperty(MediaService.prototype, "sortedFormats", {
        /**
         * Creates the media formats in a logical sorted order. The map contains the
         * format key and the format size information. We do this only once for performance
         * benefits.
         */
        get: function () {
            var _this = this;
            if (!this._sortedFormats) {
                this._sortedFormats = Object.keys(this.config.mediaFormats)
                    .map(function (key) { return ({
                    code: key,
                    size: _this.config.mediaFormats[key],
                }); })
                    .sort(function (a, b) { return (a.size.width > b.size.width ? 1 : -1); });
            }
            return this._sortedFormats;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MediaService.prototype, "reversedFormats", {
        /**
         * Creates the media formats in a reversed sorted order.
         */
        get: function () {
            if (!this._reversedFormats) {
                this._reversedFormats = this.sortedFormats.slice().reverse();
            }
            return this._reversedFormats;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolves the right media for the given format. The fo
     */
    MediaService.prototype.resolveMedia = function (media, format) {
        return media[this.resolveFormat(media, format)];
    };
    /**
     * Validates the format against the given mediaContainer. If there is no format available,
     * or if the mediaContainer doesn't contain a media for the given media, the most optimal
     * format is resolved. If even that is not possible, the first format is returned.
     */
    MediaService.prototype.resolveFormat = function (mediaContainer, format) {
        if (format && mediaContainer[format]) {
            return format;
        }
        return (this.resolveBestFormat(mediaContainer) || Object.keys(mediaContainer)[0]);
    };
    /**
     * Returns the media format code with the best size.
     */
    MediaService.prototype.resolveBestFormat = function (media) {
        var _a;
        return (_a = this.reversedFormats.find(function (format) {
            return media.hasOwnProperty(format.code);
        })) === null || _a === void 0 ? void 0 : _a.code;
    };
    /**
     * Returns a set of media for the available media formats. Additionally, the congiured media
     * format width is added to the srcset, so that browsers can select the appropriate media.
     */
    MediaService.prototype.resolveSrcSet = function (media) {
        var _this = this;
        if (!media) {
            return undefined;
        }
        var srcset = this.sortedFormats.reduce(function (set, format) {
            if (!!media[format.code]) {
                if (set) {
                    set += ', ';
                }
                set += _this.resolveAbsoluteUrl(media[format.code].url) + " " + format.size.width + "w";
            }
            return set;
        }, '');
        return srcset === '' ? undefined : srcset;
    };
    /**
     * Resolves the absolute URL for the given url. In most cases, this URL represents
     * the relative URL on the backend. In that case, we prefix the url with the baseUrl.
     */
    MediaService.prototype.resolveAbsoluteUrl = function (url) {
        if (!url) {
            return null;
        }
        return url.startsWith('http') ? url : this.getBaseUrl() + url;
    };
    /**
     * The base URL is either driven by a specific `backend.media.baseUrl`, or by the
     * `backend.occ.baseUrl`.
     *
     * The `backend.media.baseUrl` can be used to load media from a different location.
     *
     * In Commerce Cloud, a differnt location could mean a different "aspect".
     */
    MediaService.prototype.getBaseUrl = function () {
        return (this.config.backend.media.baseUrl ||
            this.config.backend.occ.baseUrl ||
            '');
    };
    MediaService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [Config,] }] },
        { type: BreakpointService }
    ]; };
    MediaService.ɵprov = i0.ɵɵdefineInjectable({ factory: function MediaService_Factory() { return new MediaService(i0.ɵɵinject(i1.Config), i0.ɵɵinject(i2.BreakpointService)); }, token: MediaService, providedIn: "root" });
    MediaService = __decorate([
        Injectable({
            providedIn: 'root',
        }),
        __param(0, Inject(Config))
    ], MediaService);
    return MediaService;
}());
export { MediaService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVkaWEuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbInNoYXJlZC9jb21wb25lbnRzL21lZGlhL21lZGlhLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ25ELE9BQU8sRUFBRSxNQUFNLEVBQW9CLE1BQU0saUJBQWlCLENBQUM7QUFDM0QsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sK0NBQStDLENBQUM7Ozs7QUFLbEY7Ozs7Ozs7Ozs7O0dBV0c7QUFJSDtJQVFFLHNCQUM0QixNQUF3QjtJQUNsRDs7OztPQUlHO0lBQ08saUJBQW9DO1FBTnBCLFdBQU0sR0FBTixNQUFNLENBQWtCO1FBTXhDLHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBbUI7SUFDN0MsQ0FBQztJQUVKOzs7T0FHRztJQUNILCtCQUFRLEdBQVIsVUFDRSxjQUFzQyxFQUN0QyxNQUFlLEVBQ2YsR0FBWTtRQUVaLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDbkIsT0FBTztTQUNSO1FBRUQsSUFBTSxTQUFTLEdBQVUsY0FBYyxDQUFDLEdBQUc7WUFDekMsQ0FBQyxDQUFDLGNBQWM7WUFDaEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsY0FBZ0MsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUVoRSxPQUFPO1lBQ0wsR0FBRyxFQUFFLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxTQUFTLGFBQVQsU0FBUyx1QkFBVCxTQUFTLENBQUUsR0FBRyxDQUFDO1lBQzVDLEdBQUcsRUFBRSxHQUFHLEtBQUksU0FBUyxhQUFULFNBQVMsdUJBQVQsU0FBUyxDQUFFLE9BQU8sQ0FBQTtZQUM5QixNQUFNLEVBQUUsSUFBSSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUM7U0FDM0MsQ0FBQztJQUNKLENBQUM7SUFPRCxzQkFBYyx1Q0FB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QVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBQzVDLENBQUM7SUFFRDs7O09BR0c7SUFDTyx5Q0FBa0IsR0FBNUIsVUFBNkIsR0FBVztRQUN0QyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1IsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE9BQU8sR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQ2hFLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ08saUNBQVUsR0FBcEI7UUFDRSxPQUFPLENBQ0osSUFBSSxDQUFDLE1BQW9CLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPO1lBQy9DLElBQUksQ0FBQyxNQUFvQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsT0FBTztZQUM5QyxFQUFFLENBQ0gsQ0FBQztJQUNKLENBQUM7O2dEQWhKRSxNQUFNLFNBQUMsTUFBTTtnQkFNZSxpQkFBaUI7OztJQWZyQyxZQUFZO1FBSHhCLFVBQVUsQ0FBQztZQUNWLFVBQVUsRUFBRSxNQUFNO1NBQ25CLENBQUM7UUFVRyxXQUFBLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtPQVROLFlBQVksQ0EwSnhCO3VCQWhMRDtDQWdMQyxBQTFKRCxJQTBKQztTQTFKWSxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IENvbmZpZywgSW1hZ2UsIE9jY0NvbmZpZyB9IGZyb20gJ0BzcGFydGFjdXMvY29yZSc7XHJcbmltcG9ydCB7IEJyZWFrcG9pbnRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vbGF5b3V0L2JyZWFrcG9pbnQvYnJlYWtwb2ludC5zZXJ2aWNlJztcclxuaW1wb3J0IHsgU3RvcmVmcm9udENvbmZpZyB9IGZyb20gJy4uLy4uLy4uL3N0b3JlZnJvbnQtY29uZmlnJztcclxuaW1wb3J0IHsgTWVkaWFDb25maWcgfSBmcm9tICcuL21lZGlhLmNvbmZpZyc7XHJcbmltcG9ydCB7IE1lZGlhLCBNZWRpYUNvbnRhaW5lciwgTWVkaWFGb3JtYXRTaXplIH0gZnJvbSAnLi9tZWRpYS5tb2RlbCc7XHJcblxyXG4vKipcclxuICogU2VydmljZSB3aGljaCBnZW5lcmF0ZXMgbWVkaWEgVVJMcy4gSXQgbGV2ZXJhZ2UgdGhlIE1lZGlhQ29udGFpbmVyIGFuZCBNZWRpYUZvcm1hdHMgc29cclxuICogdGhhdCBVUkxzIGFuZCBzaXplcyBhcmUgZ2VuZXJhdGVkIGZvciB0aGUgc2FtZSBtZWRpYS4gVGhpcyBoZWxwcyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXHJcbiAqIGFjcm9zcyBkaWZmZXJlbmNlIGRldmljZXMgYW5kIGxheW91dHMuXHJcbiAqXHJcbiAqIE1lZGlhIGZvcm1hdHMgYXJlIG9wdGlvbmFsLCBidXQgaGlnaGx5IHJlY29tbWVuZGVkLiBUaGUgZm9ybWF0IHdpbGwgaGVscCB0aGUgYnJvd3NlciB0b1xyXG4gKiBpZGVudGlmeSB0aGUgcmlnaHQgbWVkaWEgZm9yIHRoZSByaWdodCBleHBlcmllbmNlLlxyXG4gKlxyXG4gKiBUaGUgTWVkaWFTZXJ2aWNlIHdpbGwgZ2VuZXJhdGUgYWJzb2x1dGUgVVJMcyBpbiBjYXNlIHJlbGF0aXZlIFVSTHMgYXJlIHByb3ZpZGVkIGZvciB0aGUgTWVkaWEuXHJcbiAqIFRoZSBiYXNlVXJsIGlzIHJlYWQgZnJvbSB0aGUgYG9jY0NvbmZpZy5iYWNrZW5kLm1lZGlhLmJhc2VVcmxgIG9yXHJcbiAqIGBvY2NDb25maWcuYmFja2VuZC5vY2MuYmFzZVVybGAuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgTWVkaWFTZXJ2aWNlIHtcclxuICAvKipcclxuICAgKiBUaGUgbWVkaWEgZm9ybWF0cyBzb3J0ZWQgYnkgc2l6ZS4gVGhlIG1lZGlhIGZvcm1hdCByZXByZXNlbnRpbmcgdGhlIHNtYWxsZXN0XHJcbiAgICogc2l6ZSBpcyBzb3J0ZWQgb24gdG9wLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3NvcnRlZEZvcm1hdHM6IHsgY29kZTogc3RyaW5nOyBzaXplOiBNZWRpYUZvcm1hdFNpemUgfVtdO1xyXG4gIHByaXZhdGUgX3JldmVyc2VkRm9ybWF0czogeyBjb2RlOiBzdHJpbmc7IHNpemU6IE1lZGlhRm9ybWF0U2l6ZSB9W107XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChDb25maWcpIHByb3RlY3RlZCBjb25maWc6IFN0b3JlZnJvbnRDb25maWcsXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBCcmVha3BvaW50U2VydmljZSBpcyBubyBsb25nZXIgdXNlZCBpbiB2ZXJzaW9uIDIuMCBhcyB0aGUgZGlmZmVyZW50IHNpemUgZm9ybWF0cyBhcmVcclxuICAgICAqIGRyaXZlbiBieSBjb25maWd1cmF0aW9uIG9ubHkuIFRoZXJlJ3MgaG93ZXZlciBhIGNoYW5nZSB0aGF0IHRoaXMgc2VydmljZSB3aWxsIHBsYXkgYSByb2xlXHJcbiAgICAgKiBpbiB0aGUgbmVhciBmdXR1cmUsIHdoaWNoIGlzIHdoeSB3ZSBrZWVwIHRoZSBjb25zdHJ1Y3RvciBhcy1pcy5cclxuICAgICAqL1xyXG4gICAgcHJvdGVjdGVkIGJyZWFrcG9pbnRTZXJ2aWNlOiBCcmVha3BvaW50U2VydmljZVxyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIGBNZWRpYWAgb2JqZWN0IHdpdGggdGhlIG1haW4gbWVkaWEgKGBzcmNgKSBhbmQgdmFyaW91cyBtZWRpYSAoYHNyY2ApXHJcbiAgICogZm9yIHNwZWNpZmljIGZvcm1hdHMuXHJcbiAgICovXHJcbiAgZ2V0TWVkaWEoXHJcbiAgICBtZWRpYUNvbnRhaW5lcjogTWVkaWFDb250YWluZXIgfCBJbWFnZSxcclxuICAgIGZvcm1hdD86IHN0cmluZyxcclxuICAgIGFsdD86IHN0cmluZ1xyXG4gICk6IE1lZGlhIHtcclxuICAgIGlmICghbWVkaWFDb250YWluZXIpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1haW5NZWRpYTogSW1hZ2UgPSBtZWRpYUNvbnRhaW5lci51cmxcclxuICAgICAgPyBtZWRpYUNvbnRhaW5lclxyXG4gICAgICA6IHRoaXMucmVzb2x2ZU1lZGlhKG1lZGlhQ29udGFpbmVyIGFzIE1lZGlhQ29udGFpbmVyLCBmb3JtYXQpO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHNyYzogdGhpcy5yZXNvbHZlQWJzb2x1dGVVcmwobWFpbk1lZGlhPy51cmwpLFxyXG4gICAgICBhbHQ6IGFsdCB8fCBtYWluTWVkaWE/LmFsdFRleHQsXHJcbiAgICAgIHNyY3NldDogdGhpcy5yZXNvbHZlU3JjU2V0KG1lZGlhQ29udGFpbmVyKSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHRoZSBtZWRpYSBmb3JtYXRzIGluIGEgbG9naWNhbCBzb3J0ZWQgb3JkZXIuIFRoZSBtYXAgY29udGFpbnMgdGhlXHJcbiAgICogZm9ybWF0IGtleSBhbmQgdGhlIGZvcm1hdCBzaXplIGluZm9ybWF0aW9uLiBXZSBkbyB0aGlzIG9ubHkgb25jZSBmb3IgcGVyZm9ybWFuY2VcclxuICAgKiBiZW5lZml0cy5cclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2V0IHNvcnRlZEZvcm1hdHMoKTogeyBjb2RlOiBzdHJpbmc7IHNpemU6IE1lZGlhRm9ybWF0U2l6ZSB9W10ge1xyXG4gICAgaWYgKCF0aGlzLl9zb3J0ZWRGb3JtYXRzKSB7XHJcbiAgICAgIHRoaXMuX3NvcnRlZEZvcm1hdHMgPSBPYmplY3Qua2V5cyhcclxuICAgICAgICAodGhpcy5jb25maWcgYXMgTWVkaWFDb25maWcpLm1lZGlhRm9ybWF0c1xyXG4gICAgICApXHJcbiAgICAgICAgLm1hcCgoa2V5KSA9PiAoe1xyXG4gICAgICAgICAgY29kZToga2V5LFxyXG4gICAgICAgICAgc2l6ZTogKHRoaXMuY29uZmlnIGFzIE1lZGlhQ29uZmlnKS5tZWRpYUZvcm1hdHNba2V5XSxcclxuICAgICAgICB9KSlcclxuICAgICAgICAuc29ydCgoYSwgYikgPT4gKGEuc2l6ZS53aWR0aCA+IGIuc2l6ZS53aWR0aCA/IDEgOiAtMSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMuX3NvcnRlZEZvcm1hdHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHRoZSBtZWRpYSBmb3JtYXRzIGluIGEgcmV2ZXJzZWQgc29ydGVkIG9yZGVyLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXQgcmV2ZXJzZWRGb3JtYXRzKCk6IHsgY29kZTogc3RyaW5nOyBzaXplOiBNZWRpYUZvcm1hdFNpemUgfVtdIHtcclxuICAgIGlmICghdGhpcy5fcmV2ZXJzZWRGb3JtYXRzKSB7XHJcbiAgICAgIHRoaXMuX3JldmVyc2VkRm9ybWF0cyA9IHRoaXMuc29ydGVkRm9ybWF0cy5zbGljZSgpLnJldmVyc2UoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLl9yZXZlcnNlZEZvcm1hdHM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNvbHZlcyB0aGUgcmlnaHQgbWVkaWEgZm9yIHRoZSBnaXZlbiBmb3JtYXQuIFRoZSBmb1xyXG4gICAqL1xyXG4gIHByb3RlY3RlZCByZXNvbHZlTWVkaWEobWVkaWE6IE1lZGlhQ29udGFpbmVyLCBmb3JtYXQ/OiBzdHJpbmcpOiBJbWFnZSB7XHJcbiAgICByZXR1cm4gbWVkaWFbdGhpcy5yZXNvbHZlRm9ybWF0KG1lZGlhLCBmb3JtYXQpXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlcyB0aGUgZm9ybWF0IGFnYWluc3QgdGhlIGdpdmVuIG1lZGlhQ29udGFpbmVyLiBJZiB0aGVyZSBpcyBubyBmb3JtYXQgYXZhaWxhYmxlLFxyXG4gICAqIG9yIGlmIHRoZSBtZWRpYUNvbnRhaW5lciBkb2Vzbid0IGNvbnRhaW4gYSBtZWRpYSBmb3IgdGhlIGdpdmVuIG1lZGlhLCB0aGUgbW9zdCBvcHRpbWFsXHJcbiAgICogZm9ybWF0IGlzIHJlc29sdmVkLiBJZiBldmVuIHRoYXQgaXMgbm90IHBvc3NpYmxlLCB0aGUgZmlyc3QgZm9ybWF0IGlzIHJldHVybmVkLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCByZXNvbHZlRm9ybWF0KFxyXG4gICAgbWVkaWFDb250YWluZXI6IE1lZGlhQ29udGFpbmVyLFxyXG4gICAgZm9ybWF0Pzogc3RyaW5nXHJcbiAgKTogc3RyaW5nIHtcclxuICAgIGlmIChmb3JtYXQgJiYgbWVkaWFDb250YWluZXJbZm9ybWF0XSkge1xyXG4gICAgICByZXR1cm4gZm9ybWF0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5yZXNvbHZlQmVzdEZvcm1hdChtZWRpYUNvbnRhaW5lcikgfHwgT2JqZWN0LmtleXMobWVkaWFDb250YWluZXIpWzBdXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgbWVkaWEgZm9ybWF0IGNvZGUgd2l0aCB0aGUgYmVzdCBzaXplLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCByZXNvbHZlQmVzdEZvcm1hdChtZWRpYTogTWVkaWFDb250YWluZXIgfCBJbWFnZSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlZEZvcm1hdHMuZmluZCgoZm9ybWF0KSA9PlxyXG4gICAgICBtZWRpYS5oYXNPd25Qcm9wZXJ0eShmb3JtYXQuY29kZSlcclxuICAgICk/LmNvZGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgc2V0IG9mIG1lZGlhIGZvciB0aGUgYXZhaWxhYmxlIG1lZGlhIGZvcm1hdHMuIEFkZGl0aW9uYWxseSwgdGhlIGNvbmdpdXJlZCBtZWRpYVxyXG4gICAqIGZvcm1hdCB3aWR0aCBpcyBhZGRlZCB0byB0aGUgc3Jjc2V0LCBzbyB0aGF0IGJyb3dzZXJzIGNhbiBzZWxlY3QgdGhlIGFwcHJvcHJpYXRlIG1lZGlhLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCByZXNvbHZlU3JjU2V0KG1lZGlhOiBNZWRpYUNvbnRhaW5lciB8IEltYWdlKTogc3RyaW5nIHtcclxuICAgIGlmICghbWVkaWEpIHtcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBzcmNzZXQgPSB0aGlzLnNvcnRlZEZvcm1hdHMucmVkdWNlKChzZXQsIGZvcm1hdCkgPT4ge1xyXG4gICAgICBpZiAoISFtZWRpYVtmb3JtYXQuY29kZV0pIHtcclxuICAgICAgICBpZiAoc2V0KSB7XHJcbiAgICAgICAgICBzZXQgKz0gJywgJztcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0ICs9IGAke3RoaXMucmVzb2x2ZUFic29sdXRlVXJsKG1lZGlhW2Zvcm1hdC5jb2RlXS51cmwpfSAke1xyXG4gICAgICAgICAgZm9ybWF0LnNpemUud2lkdGhcclxuICAgICAgICB9d2A7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHNldDtcclxuICAgIH0sICcnKTtcclxuXHJcbiAgICByZXR1cm4gc3Jjc2V0ID09PSAnJyA/IHVuZGVmaW5lZCA6IHNyY3NldDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc29sdmVzIHRoZSBhYnNvbHV0ZSBVUkwgZm9yIHRoZSBnaXZlbiB1cmwuIEluIG1vc3QgY2FzZXMsIHRoaXMgVVJMIHJlcHJlc2VudHNcclxuICAgKiB0aGUgcmVsYXRpdmUgVVJMIG9uIHRoZSBiYWNrZW5kLiBJbiB0aGF0IGNhc2UsIHdlIHByZWZpeCB0aGUgdXJsIHdpdGggdGhlIGJhc2VVcmwuXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHJlc29sdmVBYnNvbHV0ZVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBpZiAoIXVybCkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiB1cmwuc3RhcnRzV2l0aCgnaHR0cCcpID8gdXJsIDogdGhpcy5nZXRCYXNlVXJsKCkgKyB1cmw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGUgYmFzZSBVUkwgaXMgZWl0aGVyIGRyaXZlbiBieSBhIHNwZWNpZmljIGBiYWNrZW5kLm1lZGlhLmJhc2VVcmxgLCBvciBieSB0aGVcclxuICAgKiBgYmFja2VuZC5vY2MuYmFzZVVybGAuXHJcbiAgICpcclxuICAgKiBUaGUgYGJhY2tlbmQubWVkaWEuYmFzZVVybGAgY2FuIGJlIHVzZWQgdG8gbG9hZCBtZWRpYSBmcm9tIGEgZGlmZmVyZW50IGxvY2F0aW9uLlxyXG4gICAqXHJcbiAgICogSW4gQ29tbWVyY2UgQ2xvdWQsIGEgZGlmZmVybnQgbG9jYXRpb24gY291bGQgbWVhbiBhIGRpZmZlcmVudCBcImFzcGVjdFwiLlxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXRCYXNlVXJsKCk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAodGhpcy5jb25maWcgYXMgT2NjQ29uZmlnKS5iYWNrZW5kLm1lZGlhLmJhc2VVcmwgfHxcclxuICAgICAgKHRoaXMuY29uZmlnIGFzIE9jY0NvbmZpZykuYmFja2VuZC5vY2MuYmFzZVVybCB8fFxyXG4gICAgICAnJ1xyXG4gICAgKTtcclxuICB9XHJcbn1cclxuIl19