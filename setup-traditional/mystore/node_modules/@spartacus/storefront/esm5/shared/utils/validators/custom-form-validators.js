import { EMAIL_PATTERN, PASSWORD_PATTERN } from '@spartacus/core';
var CustomFormValidators = /** @class */ (function () {
    function CustomFormValidators() {
    }
    /**
     * Checks control's value with predefined email regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidEmail' validator error
     * @memberof CustomFormValidators
     */
    CustomFormValidators.emailValidator = function (control) {
        var email = control.value;
        return !email.length || email.match(EMAIL_PATTERN)
            ? null
            : { cxInvalidEmail: true };
    };
    /**
     * Checks control's value with predefined password regexp
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxInvalidPassword' validator error
     * @memberof CustomFormValidators
     */
    CustomFormValidators.passwordValidator = function (control) {
        var password = control.value;
        return !password.length || password.match(PASSWORD_PATTERN)
            ? null
            : { cxInvalidPassword: true };
    };
    /**
     * Checks if control's value is between 1 and 5
     *
     * NOTE: Use it as a control validator
     *
     * @static
     * @param {AbstractControl} control
     * @returns {(ValidationErrors | null)} Uses 'cxStarRatingEmpty' validator error
     * @memberof CustomFormValidators
     */
    CustomFormValidators.starRatingEmpty = function (control) {
        var rating = control.value;
        return rating >= 1 && rating <= 5 ? null : { cxStarRatingEmpty: true };
    };
    /**
     * Checks if two password controls match
     *
     * NOTE: Use it as a form validator and pass password control names as parameters
     *
     * @static
     * @param {string} password First password control name
     * @param {string} passwordConfirmation Second password control name
     * @returns Uses 'cxPasswordsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    CustomFormValidators.passwordsMustMatch = function (password, passwordConfirmation) {
        var validator = function (formGroup) {
            return controlsMustMatch(formGroup, password, passwordConfirmation, 'cxPasswordsMustMatch');
        };
        return validator;
    };
    /**
     * Checks if two email controls match
     *
     * NOTE: Use it as a form validator and pass email control names as parameters
     *
     * @static
     * @param {string} email First email control name
     * @param {string} emailConfirmation Second email control name
     * @returns Uses 'cxEmailsMustMatch' validator error
     * @memberof CustomFormValidators
     */
    CustomFormValidators.emailsMustMatch = function (email, emailConfirmation) {
        var validator = function (formGroup) {
            return controlsMustMatch(formGroup, email, emailConfirmation, 'cxEmailsMustMatch');
        };
        return validator;
    };
    return CustomFormValidators;
}());
export { CustomFormValidators };
/**
 * Generic function for validators, which checks if two passed controls match.
 *
 * @param formGroup
 * @param firstControlName First control to check
 * @param secondControlName Second control to check
 * @param errorName Error which will be returned by validator
 */
export function controlsMustMatch(formGroup, firstControlName, secondControlName, errorName) {
    var _a;
    var firstControl = formGroup.controls[firstControlName];
    var secondControl = formGroup.controls[secondControlName];
    if (secondControl.errors && !secondControl.errors[errorName]) {
        return;
    }
    secondControl.setErrors(firstControl.value !== secondControl.value ? (_a = {}, _a[errorName] = true, _a) : null);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLWZvcm0tdmFsaWRhdG9ycy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvc3RvcmVmcm9udC8iLCJzb3VyY2VzIjpbInNoYXJlZC91dGlscy92YWxpZGF0b3JzL2N1c3RvbS1mb3JtLXZhbGlkYXRvcnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLGFBQWEsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRWxFO0lBQUE7SUFxR0EsQ0FBQztJQXBHQzs7Ozs7Ozs7O09BU0c7SUFDSSxtQ0FBYyxHQUFyQixVQUFzQixPQUF3QjtRQUM1QyxJQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBZSxDQUFDO1FBRXRDLE9BQU8sQ0FBQyxLQUFLLENBQUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDO1lBQ2hELENBQUMsQ0FBQyxJQUFJO1lBQ04sQ0FBQyxDQUFDLEVBQUUsY0FBYyxFQUFFLElBQUksRUFBRSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSSxzQ0FBaUIsR0FBeEIsVUFBeUIsT0FBd0I7UUFDL0MsSUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLEtBQWUsQ0FBQztRQUV6QyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDO1lBQ3pELENBQUMsQ0FBQyxJQUFJO1lBQ04sQ0FBQyxDQUFDLEVBQUUsaUJBQWlCLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDbEMsQ0FBQztJQUVEOzs7Ozs7Ozs7T0FTRztJQUNJLG9DQUFlLEdBQXRCLFVBQXVCLE9BQXdCO1FBQzdDLElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQyxLQUFlLENBQUM7UUFFdkMsT0FBTyxNQUFNLElBQUksQ0FBQyxJQUFJLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxpQkFBaUIsRUFBRSxJQUFJLEVBQUUsQ0FBQztJQUN6RSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNJLHVDQUFrQixHQUF6QixVQUNFLFFBQWdCLEVBQ2hCLG9CQUE0QjtRQUU1QixJQUFNLFNBQVMsR0FBRyxVQUFDLFNBQW9CO1lBQ3JDLE9BQUEsaUJBQWlCLENBQ2YsU0FBUyxFQUNULFFBQVEsRUFDUixvQkFBb0IsRUFDcEIsc0JBQXNCLENBQ3ZCO1FBTEQsQ0FLQyxDQUFDO1FBRUosT0FBTyxTQUFTLENBQUM7SUFDbkIsQ0FBQztJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSSxvQ0FBZSxHQUF0QixVQUF1QixLQUFhLEVBQUUsaUJBQXlCO1FBQzdELElBQU0sU0FBUyxHQUFHLFVBQUMsU0FBb0I7WUFDckMsT0FBQSxpQkFBaUIsQ0FDZixTQUFTLEVBQ1QsS0FBSyxFQUNMLGlCQUFpQixFQUNqQixtQkFBbUIsQ0FDcEI7UUFMRCxDQUtDLENBQUM7UUFFSixPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBQ0gsMkJBQUM7QUFBRCxDQUFDLEFBckdELElBcUdDOztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQy9CLFNBQW9CLEVBQ3BCLGdCQUF3QixFQUN4QixpQkFBeUIsRUFDekIsU0FBaUI7O0lBRWpCLElBQU0sWUFBWSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUMxRCxJQUFNLGFBQWEsR0FBRyxTQUFTLENBQUMsUUFBUSxDQUFDLGlCQUFpQixDQUFDLENBQUM7SUFFNUQsSUFBSSxhQUFhLENBQUMsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUM1RCxPQUFPO0tBQ1I7SUFFRCxhQUFhLENBQUMsU0FBUyxDQUNyQixZQUFZLENBQUMsS0FBSyxLQUFLLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFHLEdBQUMsU0FBUyxJQUFHLElBQUksTUFBRyxDQUFDLENBQUMsSUFBSSxDQUMxRSxDQUFDO0FBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFic3RyYWN0Q29udHJvbCwgVmFsaWRhdGlvbkVycm9ycywgRm9ybUdyb3VwIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBFTUFJTF9QQVRURVJOLCBQQVNTV09SRF9QQVRURVJOIH0gZnJvbSAnQHNwYXJ0YWN1cy9jb3JlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBDdXN0b21Gb3JtVmFsaWRhdG9ycyB7XHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGNvbnRyb2wncyB2YWx1ZSB3aXRoIHByZWRlZmluZWQgZW1haWwgcmVnZXhwXHJcbiAgICpcclxuICAgKiBOT1RFOiBVc2UgaXQgYXMgYSBjb250cm9sIHZhbGlkYXRvclxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RDb250cm9sfSBjb250cm9sXHJcbiAgICogQHJldHVybnMgeyhWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCl9IFVzZXMgJ2N4SW52YWxpZEVtYWlsJyB2YWxpZGF0b3IgZXJyb3JcclxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tRm9ybVZhbGlkYXRvcnNcclxuICAgKi9cclxuICBzdGF0aWMgZW1haWxWYWxpZGF0b3IoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xyXG4gICAgY29uc3QgZW1haWwgPSBjb250cm9sLnZhbHVlIGFzIHN0cmluZztcclxuXHJcbiAgICByZXR1cm4gIWVtYWlsLmxlbmd0aCB8fCBlbWFpbC5tYXRjaChFTUFJTF9QQVRURVJOKVxyXG4gICAgICA/IG51bGxcclxuICAgICAgOiB7IGN4SW52YWxpZEVtYWlsOiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgY29udHJvbCdzIHZhbHVlIHdpdGggcHJlZGVmaW5lZCBwYXNzd29yZCByZWdleHBcclxuICAgKlxyXG4gICAqIE5PVEU6IFVzZSBpdCBhcyBhIGNvbnRyb2wgdmFsaWRhdG9yXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdENvbnRyb2x9IGNvbnRyb2xcclxuICAgKiBAcmV0dXJucyB7KFZhbGlkYXRpb25FcnJvcnMgfCBudWxsKX0gVXNlcyAnY3hJbnZhbGlkUGFzc3dvcmQnIHZhbGlkYXRvciBlcnJvclxyXG4gICAqIEBtZW1iZXJvZiBDdXN0b21Gb3JtVmFsaWRhdG9yc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBwYXNzd29yZFZhbGlkYXRvcihjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XHJcbiAgICBjb25zdCBwYXNzd29yZCA9IGNvbnRyb2wudmFsdWUgYXMgc3RyaW5nO1xyXG5cclxuICAgIHJldHVybiAhcGFzc3dvcmQubGVuZ3RoIHx8IHBhc3N3b3JkLm1hdGNoKFBBU1NXT1JEX1BBVFRFUk4pXHJcbiAgICAgID8gbnVsbFxyXG4gICAgICA6IHsgY3hJbnZhbGlkUGFzc3dvcmQ6IHRydWUgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBjb250cm9sJ3MgdmFsdWUgaXMgYmV0d2VlbiAxIGFuZCA1XHJcbiAgICpcclxuICAgKiBOT1RFOiBVc2UgaXQgYXMgYSBjb250cm9sIHZhbGlkYXRvclxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RDb250cm9sfSBjb250cm9sXHJcbiAgICogQHJldHVybnMgeyhWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCl9IFVzZXMgJ2N4U3RhclJhdGluZ0VtcHR5JyB2YWxpZGF0b3IgZXJyb3JcclxuICAgKiBAbWVtYmVyb2YgQ3VzdG9tRm9ybVZhbGlkYXRvcnNcclxuICAgKi9cclxuICBzdGF0aWMgc3RhclJhdGluZ0VtcHR5KGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcclxuICAgIGNvbnN0IHJhdGluZyA9IGNvbnRyb2wudmFsdWUgYXMgbnVtYmVyO1xyXG5cclxuICAgIHJldHVybiByYXRpbmcgPj0gMSAmJiByYXRpbmcgPD0gNSA/IG51bGwgOiB7IGN4U3RhclJhdGluZ0VtcHR5OiB0cnVlIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgdHdvIHBhc3N3b3JkIGNvbnRyb2xzIG1hdGNoXHJcbiAgICpcclxuICAgKiBOT1RFOiBVc2UgaXQgYXMgYSBmb3JtIHZhbGlkYXRvciBhbmQgcGFzcyBwYXNzd29yZCBjb250cm9sIG5hbWVzIGFzIHBhcmFtZXRlcnNcclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgRmlyc3QgcGFzc3dvcmQgY29udHJvbCBuYW1lXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkQ29uZmlybWF0aW9uIFNlY29uZCBwYXNzd29yZCBjb250cm9sIG5hbWVcclxuICAgKiBAcmV0dXJucyBVc2VzICdjeFBhc3N3b3Jkc011c3RNYXRjaCcgdmFsaWRhdG9yIGVycm9yXHJcbiAgICogQG1lbWJlcm9mIEN1c3RvbUZvcm1WYWxpZGF0b3JzXHJcbiAgICovXHJcbiAgc3RhdGljIHBhc3N3b3Jkc011c3RNYXRjaChcclxuICAgIHBhc3N3b3JkOiBzdHJpbmcsXHJcbiAgICBwYXNzd29yZENvbmZpcm1hdGlvbjogc3RyaW5nXHJcbiAgKTogYW55IHtcclxuICAgIGNvbnN0IHZhbGlkYXRvciA9IChmb3JtR3JvdXA6IEZvcm1Hcm91cCkgPT5cclxuICAgICAgY29udHJvbHNNdXN0TWF0Y2goXHJcbiAgICAgICAgZm9ybUdyb3VwLFxyXG4gICAgICAgIHBhc3N3b3JkLFxyXG4gICAgICAgIHBhc3N3b3JkQ29uZmlybWF0aW9uLFxyXG4gICAgICAgICdjeFBhc3N3b3Jkc011c3RNYXRjaCdcclxuICAgICAgKTtcclxuXHJcbiAgICByZXR1cm4gdmFsaWRhdG9yO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHR3byBlbWFpbCBjb250cm9scyBtYXRjaFxyXG4gICAqXHJcbiAgICogTk9URTogVXNlIGl0IGFzIGEgZm9ybSB2YWxpZGF0b3IgYW5kIHBhc3MgZW1haWwgY29udHJvbCBuYW1lcyBhcyBwYXJhbWV0ZXJzXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVtYWlsIEZpcnN0IGVtYWlsIGNvbnRyb2wgbmFtZVxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbWFpbENvbmZpcm1hdGlvbiBTZWNvbmQgZW1haWwgY29udHJvbCBuYW1lXHJcbiAgICogQHJldHVybnMgVXNlcyAnY3hFbWFpbHNNdXN0TWF0Y2gnIHZhbGlkYXRvciBlcnJvclxyXG4gICAqIEBtZW1iZXJvZiBDdXN0b21Gb3JtVmFsaWRhdG9yc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBlbWFpbHNNdXN0TWF0Y2goZW1haWw6IHN0cmluZywgZW1haWxDb25maXJtYXRpb246IHN0cmluZyk6IGFueSB7XHJcbiAgICBjb25zdCB2YWxpZGF0b3IgPSAoZm9ybUdyb3VwOiBGb3JtR3JvdXApID0+XHJcbiAgICAgIGNvbnRyb2xzTXVzdE1hdGNoKFxyXG4gICAgICAgIGZvcm1Hcm91cCxcclxuICAgICAgICBlbWFpbCxcclxuICAgICAgICBlbWFpbENvbmZpcm1hdGlvbixcclxuICAgICAgICAnY3hFbWFpbHNNdXN0TWF0Y2gnXHJcbiAgICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHZhbGlkYXRvcjtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHZW5lcmljIGZ1bmN0aW9uIGZvciB2YWxpZGF0b3JzLCB3aGljaCBjaGVja3MgaWYgdHdvIHBhc3NlZCBjb250cm9scyBtYXRjaC5cclxuICpcclxuICogQHBhcmFtIGZvcm1Hcm91cFxyXG4gKiBAcGFyYW0gZmlyc3RDb250cm9sTmFtZSBGaXJzdCBjb250cm9sIHRvIGNoZWNrXHJcbiAqIEBwYXJhbSBzZWNvbmRDb250cm9sTmFtZSBTZWNvbmQgY29udHJvbCB0byBjaGVja1xyXG4gKiBAcGFyYW0gZXJyb3JOYW1lIEVycm9yIHdoaWNoIHdpbGwgYmUgcmV0dXJuZWQgYnkgdmFsaWRhdG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udHJvbHNNdXN0TWF0Y2goXHJcbiAgZm9ybUdyb3VwOiBGb3JtR3JvdXAsXHJcbiAgZmlyc3RDb250cm9sTmFtZTogc3RyaW5nLFxyXG4gIHNlY29uZENvbnRyb2xOYW1lOiBzdHJpbmcsXHJcbiAgZXJyb3JOYW1lOiBzdHJpbmdcclxuKTogdm9pZCB7XHJcbiAgY29uc3QgZmlyc3RDb250cm9sID0gZm9ybUdyb3VwLmNvbnRyb2xzW2ZpcnN0Q29udHJvbE5hbWVdO1xyXG4gIGNvbnN0IHNlY29uZENvbnRyb2wgPSBmb3JtR3JvdXAuY29udHJvbHNbc2Vjb25kQ29udHJvbE5hbWVdO1xyXG5cclxuICBpZiAoc2Vjb25kQ29udHJvbC5lcnJvcnMgJiYgIXNlY29uZENvbnRyb2wuZXJyb3JzW2Vycm9yTmFtZV0pIHtcclxuICAgIHJldHVybjtcclxuICB9XHJcblxyXG4gIHNlY29uZENvbnRyb2wuc2V0RXJyb3JzKFxyXG4gICAgZmlyc3RDb250cm9sLnZhbHVlICE9PSBzZWNvbmRDb250cm9sLnZhbHVlID8geyBbZXJyb3JOYW1lXTogdHJ1ZSB9IDogbnVsbFxyXG4gICk7XHJcbn1cclxuIl19