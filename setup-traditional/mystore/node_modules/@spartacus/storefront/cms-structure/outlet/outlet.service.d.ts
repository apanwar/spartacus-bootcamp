import { TemplateRef } from '@angular/core';
import { OutletPosition } from './outlet.model';
import * as ɵngcc0 from '@angular/core';
export declare class OutletService<T = TemplateRef<any>> {
    private templatesRefs;
    private templatesRefsBefore;
    private templatesRefsAfter;
    /**
     * Adds a template or ComponentFactory, so that UI outlets can be replaced dynamically.
     * The UI position where this template or ComponentFactory is inserted is given by a
     * string reference (called `outlet`) and optional `OutletPosition`. The `OutletPosition`
     * is either before or after, or replaces the entire UI.
     *
     * @param outlet the UI location represented by a string
     * @param template the `TemplateRef` that will be used to insert UI
     * @param position the `OutletPosition` in the UI
     */
    add(outlet: string, template: T, position?: OutletPosition): void;
    /**
     * @param factory The `ComponentFactory` that will be dynamically added to the outlet UI
     */
    add(outlet: string, factory: T, position?: OutletPosition): void;
    /**
     *
     * Returns a single object or multiple objects for the given outlet reference,
     * depending on the `stacked` argument.
     *
     * @param outlet The outlet reference
     * @param position the outlet position, `OutletPosition.before`, `OutletPosition.AFTER` or `OutletPosition.REPLACE`
     * @param stacked Indicates whether an array of outlet components is returned
     */
    get(outlet: string, position?: OutletPosition, stacked?: boolean): T[] | T;
    remove(outlet: string, position?: OutletPosition, value?: T): void;
    private store;
    protected removeValueOrAll(store: Map<string, T[]>, outlet: string, value?: T): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<OutletService<any>, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3V0bGV0LnNlcnZpY2UuZC50cyIsInNvdXJjZXMiOlsib3V0bGV0LnNlcnZpY2UuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZW1wbGF0ZVJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPdXRsZXRQb3NpdGlvbiB9IGZyb20gJy4vb3V0bGV0Lm1vZGVsJztcclxuZXhwb3J0IGRlY2xhcmUgY2xhc3MgT3V0bGV0U2VydmljZTxUID0gVGVtcGxhdGVSZWY8YW55Pj4ge1xyXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZXNSZWZzO1xyXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZXNSZWZzQmVmb3JlO1xyXG4gICAgcHJpdmF0ZSB0ZW1wbGF0ZXNSZWZzQWZ0ZXI7XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0ZW1wbGF0ZSBvciBDb21wb25lbnRGYWN0b3J5LCBzbyB0aGF0IFVJIG91dGxldHMgY2FuIGJlIHJlcGxhY2VkIGR5bmFtaWNhbGx5LlxyXG4gICAgICogVGhlIFVJIHBvc2l0aW9uIHdoZXJlIHRoaXMgdGVtcGxhdGUgb3IgQ29tcG9uZW50RmFjdG9yeSBpcyBpbnNlcnRlZCBpcyBnaXZlbiBieSBhXHJcbiAgICAgKiBzdHJpbmcgcmVmZXJlbmNlIChjYWxsZWQgYG91dGxldGApIGFuZCBvcHRpb25hbCBgT3V0bGV0UG9zaXRpb25gLiBUaGUgYE91dGxldFBvc2l0aW9uYFxyXG4gICAgICogaXMgZWl0aGVyIGJlZm9yZSBvciBhZnRlciwgb3IgcmVwbGFjZXMgdGhlIGVudGlyZSBVSS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3V0bGV0IHRoZSBVSSBsb2NhdGlvbiByZXByZXNlbnRlZCBieSBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlIHRoZSBgVGVtcGxhdGVSZWZgIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGluc2VydCBVSVxyXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIHRoZSBgT3V0bGV0UG9zaXRpb25gIGluIHRoZSBVSVxyXG4gICAgICovXHJcbiAgICBhZGQob3V0bGV0OiBzdHJpbmcsIHRlbXBsYXRlOiBULCBwb3NpdGlvbj86IE91dGxldFBvc2l0aW9uKTogdm9pZDtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZhY3RvcnkgVGhlIGBDb21wb25lbnRGYWN0b3J5YCB0aGF0IHdpbGwgYmUgZHluYW1pY2FsbHkgYWRkZWQgdG8gdGhlIG91dGxldCBVSVxyXG4gICAgICovXHJcbiAgICBhZGQob3V0bGV0OiBzdHJpbmcsIGZhY3Rvcnk6IFQsIHBvc2l0aW9uPzogT3V0bGV0UG9zaXRpb24pOiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJucyBhIHNpbmdsZSBvYmplY3Qgb3IgbXVsdGlwbGUgb2JqZWN0cyBmb3IgdGhlIGdpdmVuIG91dGxldCByZWZlcmVuY2UsXHJcbiAgICAgKiBkZXBlbmRpbmcgb24gdGhlIGBzdGFja2VkYCBhcmd1bWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3V0bGV0IFRoZSBvdXRsZXQgcmVmZXJlbmNlXHJcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gdGhlIG91dGxldCBwb3NpdGlvbiwgYE91dGxldFBvc2l0aW9uLmJlZm9yZWAsIGBPdXRsZXRQb3NpdGlvbi5BRlRFUmAgb3IgYE91dGxldFBvc2l0aW9uLlJFUExBQ0VgXHJcbiAgICAgKiBAcGFyYW0gc3RhY2tlZCBJbmRpY2F0ZXMgd2hldGhlciBhbiBhcnJheSBvZiBvdXRsZXQgY29tcG9uZW50cyBpcyByZXR1cm5lZFxyXG4gICAgICovXHJcbiAgICBnZXQob3V0bGV0OiBzdHJpbmcsIHBvc2l0aW9uPzogT3V0bGV0UG9zaXRpb24sIHN0YWNrZWQ/OiBib29sZWFuKTogVFtdIHwgVDtcclxuICAgIHJlbW92ZShvdXRsZXQ6IHN0cmluZywgcG9zaXRpb24/OiBPdXRsZXRQb3NpdGlvbiwgdmFsdWU/OiBUKTogdm9pZDtcclxuICAgIHByaXZhdGUgc3RvcmU7XHJcbiAgICBwcm90ZWN0ZWQgcmVtb3ZlVmFsdWVPckFsbChzdG9yZTogTWFwPHN0cmluZywgVFtdPiwgb3V0bGV0OiBzdHJpbmcsIHZhbHVlPzogVCk6IHZvaWQ7XHJcbn1cclxuIl19