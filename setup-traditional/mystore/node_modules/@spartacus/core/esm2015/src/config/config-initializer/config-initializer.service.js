import { __awaiter, __decorate, __param } from "tslib";
import { Inject, Injectable, isDevMode, Optional } from '@angular/core';
import { CONFIG_INITIALIZER_FORROOT_GUARD, } from './config-initializer';
import { Config } from '../config.module';
import { BehaviorSubject } from 'rxjs';
import { filter, mapTo, take } from 'rxjs/operators';
import { deepMerge } from '../utils/deep-merge';
import * as i0 from "@angular/core";
import * as i1 from "../config.module";
import * as i2 from "./config-initializer";
/**
 * Provides support for CONFIG_INITIALIZERS
 */
let ConfigInitializerService = class ConfigInitializerService {
    constructor(config, initializerGuard) {
        this.config = config;
        this.initializerGuard = initializerGuard;
        this.ongoingScopes$ = new BehaviorSubject(undefined);
    }
    /**
     * Returns true if config is stable, i.e. all CONFIG_INITIALIZERS resolved correctly
     */
    get isStable() {
        return (!this.initializerGuard ||
            (this.ongoingScopes$.value && this.ongoingScopes$.value.length === 0));
    }
    /**
     * Recommended way to get config for code that can run before app will finish
     * initialization (APP_INITIALIZERS, selected service constructors)
     *
     * Used without parameters waits for the whole config to become stable
     *
     * Parameters allow to describe which part of the config should be stable using
     * string describing config part, e.g.:
     * 'siteContext', 'siteContext.language', etc.
     *
     * @param scopes String describing parts of the config we want to be sure are stable
     */
    getStableConfig(...scopes) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isStable) {
                return this.config;
            }
            return this.ongoingScopes$
                .pipe(filter((ongoingScopes) => ongoingScopes && this.areReady(scopes, ongoingScopes)), take(1), mapTo(this.config))
                .toPromise();
        });
    }
    /**
     * Removes provided scopes from currently ongoingScopes
     *
     * @param scopes
     */
    finishScopes(scopes) {
        const newScopes = [...this.ongoingScopes$.value];
        for (const scope of scopes) {
            newScopes.splice(newScopes.indexOf(scope), 1);
        }
        this.ongoingScopes$.next(newScopes);
    }
    /**
     * Return true if provided scopes are not part of ongoingScopes
     *
     * @param scopes
     * @param ongoingScopes
     */
    areReady(scopes, ongoingScopes) {
        if (!scopes.length) {
            return !ongoingScopes.length;
        }
        for (const scope of scopes) {
            for (const ongoingScope of ongoingScopes) {
                if (this.scopesOverlap(scope, ongoingScope)) {
                    return false;
                }
            }
        }
        return true;
    }
    /**
     * Check if two scopes overlap.
     *
     * Example of scopes that overlap:
     * 'test' and 'test', 'test.a' and 'test', 'test' and 'test.a'
     *
     * Example of scopes that do not overlap:
     * 'test' and 'testA', 'test.a' and 'test.b', 'test.nested' and 'test.nest'
     *
     * @param a ScopeA
     * @param b ScopeB
     */
    scopesOverlap(a, b) {
        if (b.length > a.length) {
            [a, b] = [b, a];
        }
        return a.startsWith(b) && (a[b.length] || '.') === '.';
    }
    /**
     * @internal
     *
     * Not a part of a public API, used by APP_INITIALIZER to initialize all provided CONFIG_INITIALIZERS
     *
     */
    initialize(initializers) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ongoingScopes$.value) {
                // guard for double initialization
                return;
            }
            const ongoingScopes = [];
            const asyncConfigs = [];
            for (const initializer of initializers || []) {
                if (!initializer) {
                    continue;
                }
                if (!initializer.scopes || !initializer.scopes.length) {
                    throw new Error('CONFIG_INITIALIZER should provide scope!');
                }
                if (isDevMode() && !this.areReady(initializer.scopes, ongoingScopes)) {
                    console.warn('More than one CONFIG_INITIALIZER is initializing the same config scope.');
                }
                ongoingScopes.push(...initializer.scopes);
                asyncConfigs.push((() => __awaiter(this, void 0, void 0, function* () {
                    deepMerge(this.config, yield initializer.configFactory());
                    this.finishScopes(initializer.scopes);
                }))());
            }
            this.ongoingScopes$.next(ongoingScopes);
            if (asyncConfigs.length) {
                yield Promise.all(asyncConfigs);
            }
        });
    }
};
ConfigInitializerService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [Config,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONFIG_INITIALIZER_FORROOT_GUARD,] }] }
];
ConfigInitializerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ConfigInitializerService_Factory() { return new ConfigInitializerService(i0.ɵɵinject(i1.Config), i0.ɵɵinject(i2.CONFIG_INITIALIZER_FORROOT_GUARD, 8)); }, token: ConfigInitializerService, providedIn: "root" });
ConfigInitializerService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __param(0, Inject(Config)),
    __param(1, Optional()),
    __param(1, Inject(CONFIG_INITIALIZER_FORROOT_GUARD))
], ConfigInitializerService);
export { ConfigInitializerService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLWluaXRpYWxpemVyLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL2NvcmUvIiwic291cmNlcyI6WyJzcmMvY29uZmlnL2NvbmZpZy1pbml0aWFsaXplci9jb25maWctaW5pdGlhbGl6ZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RSxPQUFPLEVBQ0wsZ0NBQWdDLEdBRWpDLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzFDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkMsT0FBTyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDckQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHFCQUFxQixDQUFDOzs7O0FBRWhEOztHQUVHO0FBSUgsSUFBYSx3QkFBd0IsR0FBckMsTUFBYSx3QkFBd0I7SUFDbkMsWUFDNEIsTUFBVyxFQUczQixnQkFBZ0I7UUFIQSxXQUFNLEdBQU4sTUFBTSxDQUFLO1FBRzNCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBQTtRQUdsQixtQkFBYyxHQUFHLElBQUksZUFBZSxDQUFXLFNBQVMsQ0FBQyxDQUFDO0lBRmpFLENBQUM7SUFJSjs7T0FFRztJQUNILElBQUksUUFBUTtRQUNWLE9BQU8sQ0FDTCxDQUFDLElBQUksQ0FBQyxnQkFBZ0I7WUFDdEIsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxDQUFDLENBQ3RFLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDRyxlQUFlLENBQUMsR0FB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LElBQUksQ0FDZixDQUFDLEdBQVMsRUFBRTtvQkFDVixTQUFTLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxNQUFNLFdBQVcsQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDO29CQUMxRCxJQUFJLENBQUMsWUFBWSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDeEMsQ0FBQyxDQUFBLENBQUMsRUFBRSxDQUNMLENBQUM7YUFDSDtZQUNELElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBRXhDLElBQUksWUFBWSxDQUFDLE1BQU0sRUFBRTtnQkFDdkIsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDO2FBQ2pDO1FBQ0gsQ0FBQztLQUFBO0NBQ0YsQ0FBQTs7NENBL0lJLE1BQU0sU0FBQyxNQUFNOzRDQUNiLFFBQVEsWUFDUixNQUFNLFNBQUMsZ0NBQWdDOzs7QUFKL0Isd0JBQXdCO0lBSHBDLFVBQVUsQ0FBQztRQUNWLFVBQVUsRUFBRSxNQUFNO0tBQ25CLENBQUM7SUFHRyxXQUFBLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNkLFdBQUEsUUFBUSxFQUFFLENBQUE7SUFDVixXQUFBLE1BQU0sQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFBO0dBSmhDLHdCQUF3QixDQWlKcEM7U0FqSlksd0JBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBpc0Rldk1vZGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7XHJcbiAgQ09ORklHX0lOSVRJQUxJWkVSX0ZPUlJPT1RfR1VBUkQsXHJcbiAgQ29uZmlnSW5pdGlhbGl6ZXIsXHJcbn0gZnJvbSAnLi9jb25maWctaW5pdGlhbGl6ZXInO1xyXG5pbXBvcnQgeyBDb25maWcgfSBmcm9tICcuLi9jb25maWcubW9kdWxlJztcclxuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IGZpbHRlciwgbWFwVG8sIHRha2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gJy4uL3V0aWxzL2RlZXAtbWVyZ2UnO1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIHN1cHBvcnQgZm9yIENPTkZJR19JTklUSUFMSVpFUlNcclxuICovXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDb25maWdJbml0aWFsaXplclNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChDb25maWcpIHByb3RlY3RlZCBjb25maWc6IGFueSxcclxuICAgIEBPcHRpb25hbCgpXHJcbiAgICBASW5qZWN0KENPTkZJR19JTklUSUFMSVpFUl9GT1JST09UX0dVQVJEKVxyXG4gICAgcHJvdGVjdGVkIGluaXRpYWxpemVyR3VhcmRcclxuICApIHt9XHJcblxyXG4gIHByb3RlY3RlZCBvbmdvaW5nU2NvcGVzJCA9IG5ldyBCZWhhdmlvclN1YmplY3Q8c3RyaW5nW10+KHVuZGVmaW5lZCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBjb25maWcgaXMgc3RhYmxlLCBpLmUuIGFsbCBDT05GSUdfSU5JVElBTElaRVJTIHJlc29sdmVkIGNvcnJlY3RseVxyXG4gICAqL1xyXG4gIGdldCBpc1N0YWJsZSgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICF0aGlzLmluaXRpYWxpemVyR3VhcmQgfHxcclxuICAgICAgKHRoaXMub25nb2luZ1Njb3BlcyQudmFsdWUgJiYgdGhpcy5vbmdvaW5nU2NvcGVzJC52YWx1ZS5sZW5ndGggPT09IDApXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVjb21tZW5kZWQgd2F5IHRvIGdldCBjb25maWcgZm9yIGNvZGUgdGhhdCBjYW4gcnVuIGJlZm9yZSBhcHAgd2lsbCBmaW5pc2hcclxuICAgKiBpbml0aWFsaXphdGlvbiAoQVBQX0lOSVRJQUxJWkVSUywgc2VsZWN0ZWQgc2VydmljZSBjb25zdHJ1Y3RvcnMpXHJcbiAgICpcclxuICAgKiBVc2VkIHdpdGhvdXQgcGFyYW1ldGVycyB3YWl0cyBmb3IgdGhlIHdob2xlIGNvbmZpZyB0byBiZWNvbWUgc3RhYmxlXHJcbiAgICpcclxuICAgKiBQYXJhbWV0ZXJzIGFsbG93IHRvIGRlc2NyaWJlIHdoaWNoIHBhcnQgb2YgdGhlIGNvbmZpZyBzaG91bGQgYmUgc3RhYmxlIHVzaW5nXHJcbiAgICogc3RyaW5nIGRlc2NyaWJpbmcgY29uZmlnIHBhcnQsIGUuZy46XHJcbiAgICogJ3NpdGVDb250ZXh0JywgJ3NpdGVDb250ZXh0Lmxhbmd1YWdlJywgZXRjLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHNjb3BlcyBTdHJpbmcgZGVzY3JpYmluZyBwYXJ0cyBvZiB0aGUgY29uZmlnIHdlIHdhbnQgdG8gYmUgc3VyZSBhcmUgc3RhYmxlXHJcbiAgICovXHJcbiAgYXN5bmMgZ2V0U3RhYmxlQ29uZmlnKC4uLnNjb3Blczogc3RyaW5nW10pOiBQcm9taXNlPGFueT4ge1xyXG4gICAgaWYgKHRoaXMuaXNTdGFibGUpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuY29uZmlnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXMub25nb2luZ1Njb3BlcyRcclxuICAgICAgLnBpcGUoXHJcbiAgICAgICAgZmlsdGVyKFxyXG4gICAgICAgICAgKG9uZ29pbmdTY29wZXMpID0+XHJcbiAgICAgICAgICAgIG9uZ29pbmdTY29wZXMgJiYgdGhpcy5hcmVSZWFkeShzY29wZXMsIG9uZ29pbmdTY29wZXMpXHJcbiAgICAgICAgKSxcclxuICAgICAgICB0YWtlKDEpLFxyXG4gICAgICAgIG1hcFRvKHRoaXMuY29uZmlnKVxyXG4gICAgICApXHJcbiAgICAgIC50b1Byb21pc2UoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgcHJvdmlkZWQgc2NvcGVzIGZyb20gY3VycmVudGx5IG9uZ29pbmdTY29wZXNcclxuICAgKlxyXG4gICAqIEBwYXJhbSBzY29wZXNcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZmluaXNoU2NvcGVzKHNjb3Blczogc3RyaW5nW10pIHtcclxuICAgIGNvbnN0IG5ld1Njb3BlcyA9IFsuLi50aGlzLm9uZ29pbmdTY29wZXMkLnZhbHVlXTtcclxuICAgIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKSB7XHJcbiAgICAgIG5ld1Njb3Blcy5zcGxpY2UobmV3U2NvcGVzLmluZGV4T2Yoc2NvcGUpLCAxKTtcclxuICAgIH1cclxuICAgIHRoaXMub25nb2luZ1Njb3BlcyQubmV4dChuZXdTY29wZXMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRydWUgaWYgcHJvdmlkZWQgc2NvcGVzIGFyZSBub3QgcGFydCBvZiBvbmdvaW5nU2NvcGVzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc2NvcGVzXHJcbiAgICogQHBhcmFtIG9uZ29pbmdTY29wZXNcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgYXJlUmVhZHkoc2NvcGVzOiBzdHJpbmdbXSwgb25nb2luZ1Njb3Blczogc3RyaW5nW10pOiBib29sZWFuIHtcclxuICAgIGlmICghc2NvcGVzLmxlbmd0aCkge1xyXG4gICAgICByZXR1cm4gIW9uZ29pbmdTY29wZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcclxuICAgICAgZm9yIChjb25zdCBvbmdvaW5nU2NvcGUgb2Ygb25nb2luZ1Njb3Blcykge1xyXG4gICAgICAgIGlmICh0aGlzLnNjb3Blc092ZXJsYXAoc2NvcGUsIG9uZ29pbmdTY29wZSkpIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdHdvIHNjb3BlcyBvdmVybGFwLlxyXG4gICAqXHJcbiAgICogRXhhbXBsZSBvZiBzY29wZXMgdGhhdCBvdmVybGFwOlxyXG4gICAqICd0ZXN0JyBhbmQgJ3Rlc3QnLCAndGVzdC5hJyBhbmQgJ3Rlc3QnLCAndGVzdCcgYW5kICd0ZXN0LmEnXHJcbiAgICpcclxuICAgKiBFeGFtcGxlIG9mIHNjb3BlcyB0aGF0IGRvIG5vdCBvdmVybGFwOlxyXG4gICAqICd0ZXN0JyBhbmQgJ3Rlc3RBJywgJ3Rlc3QuYScgYW5kICd0ZXN0LmInLCAndGVzdC5uZXN0ZWQnIGFuZCAndGVzdC5uZXN0J1xyXG4gICAqXHJcbiAgICogQHBhcmFtIGEgU2NvcGVBXHJcbiAgICogQHBhcmFtIGIgU2NvcGVCXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIHNjb3Blc092ZXJsYXAoYTogc3RyaW5nLCBiOiBzdHJpbmcpOiBib29sZWFuIHtcclxuICAgIGlmIChiLmxlbmd0aCA+IGEubGVuZ3RoKSB7XHJcbiAgICAgIFthLCBiXSA9IFtiLCBhXTtcclxuICAgIH1cclxuICAgIHJldHVybiBhLnN0YXJ0c1dpdGgoYikgJiYgKGFbYi5sZW5ndGhdIHx8ICcuJykgPT09ICcuJztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqXHJcbiAgICogTm90IGEgcGFydCBvZiBhIHB1YmxpYyBBUEksIHVzZWQgYnkgQVBQX0lOSVRJQUxJWkVSIHRvIGluaXRpYWxpemUgYWxsIHByb3ZpZGVkIENPTkZJR19JTklUSUFMSVpFUlNcclxuICAgKlxyXG4gICAqL1xyXG4gIGFzeW5jIGluaXRpYWxpemUoaW5pdGlhbGl6ZXJzPzogQ29uZmlnSW5pdGlhbGl6ZXJbXSkge1xyXG4gICAgaWYgKHRoaXMub25nb2luZ1Njb3BlcyQudmFsdWUpIHtcclxuICAgICAgLy8gZ3VhcmQgZm9yIGRvdWJsZSBpbml0aWFsaXphdGlvblxyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25nb2luZ1Njb3Blczogc3RyaW5nW10gPSBbXTtcclxuXHJcbiAgICBjb25zdCBhc3luY0NvbmZpZ3M6IFByb21pc2U8dm9pZD5bXSA9IFtdO1xyXG5cclxuICAgIGZvciAoY29uc3QgaW5pdGlhbGl6ZXIgb2YgaW5pdGlhbGl6ZXJzIHx8IFtdKSB7XHJcbiAgICAgIGlmICghaW5pdGlhbGl6ZXIpIHtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWluaXRpYWxpemVyLnNjb3BlcyB8fCAhaW5pdGlhbGl6ZXIuc2NvcGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ09ORklHX0lOSVRJQUxJWkVSIHNob3VsZCBwcm92aWRlIHNjb3BlIScpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNEZXZNb2RlKCkgJiYgIXRoaXMuYXJlUmVhZHkoaW5pdGlhbGl6ZXIuc2NvcGVzLCBvbmdvaW5nU2NvcGVzKSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICdNb3JlIHRoYW4gb25lIENPTkZJR19JTklUSUFMSVpFUiBpcyBpbml0aWFsaXppbmcgdGhlIHNhbWUgY29uZmlnIHNjb3BlLidcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBvbmdvaW5nU2NvcGVzLnB1c2goLi4uaW5pdGlhbGl6ZXIuc2NvcGVzKTtcclxuXHJcbiAgICAgIGFzeW5jQ29uZmlncy5wdXNoKFxyXG4gICAgICAgIChhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICBkZWVwTWVyZ2UodGhpcy5jb25maWcsIGF3YWl0IGluaXRpYWxpemVyLmNvbmZpZ0ZhY3RvcnkoKSk7XHJcbiAgICAgICAgICB0aGlzLmZpbmlzaFNjb3Blcyhpbml0aWFsaXplci5zY29wZXMpO1xyXG4gICAgICAgIH0pKClcclxuICAgICAgKTtcclxuICAgIH1cclxuICAgIHRoaXMub25nb2luZ1Njb3BlcyQubmV4dChvbmdvaW5nU2NvcGVzKTtcclxuXHJcbiAgICBpZiAoYXN5bmNDb25maWdzLmxlbmd0aCkge1xyXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChhc3luY0NvbmZpZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=