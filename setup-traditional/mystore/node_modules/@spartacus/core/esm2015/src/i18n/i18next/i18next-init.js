import i18next from 'i18next';
import i18nextXhrBackend from 'i18next-xhr-backend';
export function i18nextInit(configInit, languageService, httpClient, serverRequestOrigin) {
    return () => configInit.getStableConfig('i18n').then((config) => {
        let i18nextConfig = {
            ns: [],
            fallbackLng: config.i18n.fallbackLang,
            debug: config.i18n.debug,
            interpolation: {
                escapeValue: false,
            },
        };
        if (config.i18n.backend) {
            i18next.use(i18nextXhrBackend);
            const loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);
            const backend = {
                loadPath,
                ajax: i18nextGetHttpClient(httpClient),
            };
            i18nextConfig = Object.assign(Object.assign({}, i18nextConfig), { backend });
        }
        return i18next.init(i18nextConfig, () => {
            // Don't use i18next's 'resources' config key for adding static translations,
            // because it will disable loading chunks from backend. We add resources here, in the init's callback.
            i18nextAddTranslations(config.i18n.resources);
            syncI18nextWithSiteContext(languageService);
        });
    });
}
export function i18nextAddTranslations(resources = {}) {
    Object.keys(resources).forEach((lang) => {
        Object.keys(resources[lang]).forEach((chunkName) => {
            i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);
        });
    });
}
export function syncI18nextWithSiteContext(language) {
    // always update language of i18next on site context (language) change
    language.getActive().subscribe((lang) => i18next.changeLanguage(lang));
}
/**
 * Returns a function appropriate for i18next to make http calls for JSON files.
 * See docs for `i18next-xhr-backend`: https://github.com/i18next/i18next-xhr-backend#backend-options
 *
 * It uses Angular HttpClient under the hood, so it works in SSR.
 * @param httpClient Angular http client
 */
export function i18nextGetHttpClient(httpClient) {
    return (url, _options, callback, _data) => {
        httpClient.get(url, { responseType: 'text' }).subscribe((data) => callback(data, { status: 200 }), (error) => callback(null, { status: error.status }));
    };
}
/**
 * Resolves the relative path to the absolute one in SSR, using the server request's origin.
 * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:
 * - https://github.com/angular/angular/issues/19224
 * - https://github.com/angular/universal/issues/858
 */
export function getLoadPath(path, serverRequestOrigin) {
    if (!path) {
        return undefined;
    }
    if (serverRequestOrigin && !path.match(/^http(s)?:\/\//)) {
        if (path.startsWith('/')) {
            path = path.slice(1);
        }
        if (path.startsWith('./')) {
            path = path.slice(2);
        }
        const result = `${serverRequestOrigin}/${path}`;
        return result;
    }
    return path;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaTE4bmV4dC1pbml0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2kxOG4vaTE4bmV4dC9pMThuZXh0LWluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxPQUF3QixNQUFNLFNBQVMsQ0FBQztBQUMvQyxPQUFPLGlCQUFpQixNQUFNLHFCQUFxQixDQUFDO0FBS3BELE1BQU0sVUFBVSxXQUFXLENBQ3pCLFVBQW9DLEVBQ3BDLGVBQWdDLEVBQ2hDLFVBQXNCLEVBQ3RCLG1CQUEyQjtJQUUzQixPQUFPLEdBQUcsRUFBRSxDQUNWLFVBQVUsQ0FBQyxlQUFlLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7UUFDakQsSUFBSSxhQUFhLEdBQWdCO1lBQy9CLEVBQUUsRUFBRSxFQUFFO1lBQ04sV0FBVyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWTtZQUNyQyxLQUFLLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLO1lBQ3hCLGFBQWEsRUFBRTtnQkFDYixXQUFXLEVBQUUsS0FBSzthQUNuQjtTQUNGLENBQUM7UUFDRixJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO1lBQ3ZCLE9BQU8sQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztZQUMvQixNQUFNLFFBQVEsR0FBRyxXQUFXLENBQzFCLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFDNUIsbUJBQW1CLENBQ3BCLENBQUM7WUFDRixNQUFNLE9BQU8sR0FBRztnQkFDZCxRQUFRO2dCQUNSLElBQUksRUFBRSxvQkFBb0IsQ0FBQyxVQUFVLENBQUM7YUFDdkMsQ0FBQztZQUNGLGFBQWEsbUNBQVEsYUFBYSxLQUFFLE9BQU8sR0FBRSxDQUFDO1NBQy9DO1FBRUQsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRSxHQUFHLEVBQUU7WUFDdEMsNkVBQTZFO1lBQzdFLHNHQUFzRztZQUN0RyxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQzlDLDBCQUEwQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQzlDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDUCxDQUFDO0FBRUQsTUFBTSxVQUFVLHNCQUFzQixDQUFDLFlBQWtDLEVBQUU7SUFDekUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUN0QyxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFO1lBQ2pELE9BQU8sQ0FBQyxpQkFBaUIsQ0FDdkIsSUFBSSxFQUNKLFNBQVMsRUFDVCxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsU0FBUyxDQUFDLEVBQzFCLElBQUksRUFDSixJQUFJLENBQ0wsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQsTUFBTSxVQUFVLDBCQUEwQixDQUFDLFFBQXlCO0lBQ2xFLHNFQUFzRTtJQUN0RSxRQUFRLENBQUMsU0FBUyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7QUFDekUsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FDbEMsVUFBc0I7SUFFdEIsT0FBTyxDQUFDLEdBQVcsRUFBRSxRQUFnQixFQUFFLFFBQWtCLEVBQUUsS0FBYSxFQUFFLEVBQUU7UUFDMUUsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQ3JELENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQ3pDLENBQUMsS0FBSyxFQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUNwRCxDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxJQUFZLEVBQUUsbUJBQTJCO0lBQ25FLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDVCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELElBQUksbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDeEQsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3hCLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RCO1FBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3pCLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RCO1FBQ0QsTUFBTSxNQUFNLEdBQUcsR0FBRyxtQkFBbUIsSUFBSSxJQUFJLEVBQUUsQ0FBQztRQUNoRCxPQUFPLE1BQU0sQ0FBQztLQUNmO0lBQ0QsT0FBTyxJQUFJLENBQUM7QUFDZCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuaW1wb3J0IGkxOG5leHQsIHsgSW5pdE9wdGlvbnMgfSBmcm9tICdpMThuZXh0JztcclxuaW1wb3J0IGkxOG5leHRYaHJCYWNrZW5kIGZyb20gJ2kxOG5leHQteGhyLWJhY2tlbmQnO1xyXG5pbXBvcnQgeyBDb25maWdJbml0aWFsaXplclNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb25maWcvY29uZmlnLWluaXRpYWxpemVyL2NvbmZpZy1pbml0aWFsaXplci5zZXJ2aWNlJztcclxuaW1wb3J0IHsgTGFuZ3VhZ2VTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2l0ZS1jb250ZXh0L2ZhY2FkZS9sYW5ndWFnZS5zZXJ2aWNlJztcclxuaW1wb3J0IHsgVHJhbnNsYXRpb25SZXNvdXJjZXMgfSBmcm9tICcuLi90cmFuc2xhdGlvbi1yZXNvdXJjZXMnO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGkxOG5leHRJbml0KFxyXG4gIGNvbmZpZ0luaXQ6IENvbmZpZ0luaXRpYWxpemVyU2VydmljZSxcclxuICBsYW5ndWFnZVNlcnZpY2U6IExhbmd1YWdlU2VydmljZSxcclxuICBodHRwQ2xpZW50OiBIdHRwQ2xpZW50LFxyXG4gIHNlcnZlclJlcXVlc3RPcmlnaW46IHN0cmluZ1xyXG4pOiAoKSA9PiBQcm9taXNlPGFueT4ge1xyXG4gIHJldHVybiAoKSA9PlxyXG4gICAgY29uZmlnSW5pdC5nZXRTdGFibGVDb25maWcoJ2kxOG4nKS50aGVuKChjb25maWcpID0+IHtcclxuICAgICAgbGV0IGkxOG5leHRDb25maWc6IEluaXRPcHRpb25zID0ge1xyXG4gICAgICAgIG5zOiBbXSwgLy8gZG9uJ3QgcHJlbG9hZCBhbnkgbmFtZXNwYWNlc1xyXG4gICAgICAgIGZhbGxiYWNrTG5nOiBjb25maWcuaTE4bi5mYWxsYmFja0xhbmcsXHJcbiAgICAgICAgZGVidWc6IGNvbmZpZy5pMThuLmRlYnVnLFxyXG4gICAgICAgIGludGVycG9sYXRpb246IHtcclxuICAgICAgICAgIGVzY2FwZVZhbHVlOiBmYWxzZSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgICBpZiAoY29uZmlnLmkxOG4uYmFja2VuZCkge1xyXG4gICAgICAgIGkxOG5leHQudXNlKGkxOG5leHRYaHJCYWNrZW5kKTtcclxuICAgICAgICBjb25zdCBsb2FkUGF0aCA9IGdldExvYWRQYXRoKFxyXG4gICAgICAgICAgY29uZmlnLmkxOG4uYmFja2VuZC5sb2FkUGF0aCxcclxuICAgICAgICAgIHNlcnZlclJlcXVlc3RPcmlnaW5cclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IGJhY2tlbmQgPSB7XHJcbiAgICAgICAgICBsb2FkUGF0aCxcclxuICAgICAgICAgIGFqYXg6IGkxOG5leHRHZXRIdHRwQ2xpZW50KGh0dHBDbGllbnQpLFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaTE4bmV4dENvbmZpZyA9IHsgLi4uaTE4bmV4dENvbmZpZywgYmFja2VuZCB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaTE4bmV4dC5pbml0KGkxOG5leHRDb25maWcsICgpID0+IHtcclxuICAgICAgICAvLyBEb24ndCB1c2UgaTE4bmV4dCdzICdyZXNvdXJjZXMnIGNvbmZpZyBrZXkgZm9yIGFkZGluZyBzdGF0aWMgdHJhbnNsYXRpb25zLFxyXG4gICAgICAgIC8vIGJlY2F1c2UgaXQgd2lsbCBkaXNhYmxlIGxvYWRpbmcgY2h1bmtzIGZyb20gYmFja2VuZC4gV2UgYWRkIHJlc291cmNlcyBoZXJlLCBpbiB0aGUgaW5pdCdzIGNhbGxiYWNrLlxyXG4gICAgICAgIGkxOG5leHRBZGRUcmFuc2xhdGlvbnMoY29uZmlnLmkxOG4ucmVzb3VyY2VzKTtcclxuICAgICAgICBzeW5jSTE4bmV4dFdpdGhTaXRlQ29udGV4dChsYW5ndWFnZVNlcnZpY2UpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaTE4bmV4dEFkZFRyYW5zbGF0aW9ucyhyZXNvdXJjZXM6IFRyYW5zbGF0aW9uUmVzb3VyY2VzID0ge30pIHtcclxuICBPYmplY3Qua2V5cyhyZXNvdXJjZXMpLmZvckVhY2goKGxhbmcpID0+IHtcclxuICAgIE9iamVjdC5rZXlzKHJlc291cmNlc1tsYW5nXSkuZm9yRWFjaCgoY2h1bmtOYW1lKSA9PiB7XHJcbiAgICAgIGkxOG5leHQuYWRkUmVzb3VyY2VCdW5kbGUoXHJcbiAgICAgICAgbGFuZyxcclxuICAgICAgICBjaHVua05hbWUsXHJcbiAgICAgICAgcmVzb3VyY2VzW2xhbmddW2NodW5rTmFtZV0sXHJcbiAgICAgICAgdHJ1ZSxcclxuICAgICAgICB0cnVlXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHN5bmNJMThuZXh0V2l0aFNpdGVDb250ZXh0KGxhbmd1YWdlOiBMYW5ndWFnZVNlcnZpY2UpIHtcclxuICAvLyBhbHdheXMgdXBkYXRlIGxhbmd1YWdlIG9mIGkxOG5leHQgb24gc2l0ZSBjb250ZXh0IChsYW5ndWFnZSkgY2hhbmdlXHJcbiAgbGFuZ3VhZ2UuZ2V0QWN0aXZlKCkuc3Vic2NyaWJlKChsYW5nKSA9PiBpMThuZXh0LmNoYW5nZUxhbmd1YWdlKGxhbmcpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiBhcHByb3ByaWF0ZSBmb3IgaTE4bmV4dCB0byBtYWtlIGh0dHAgY2FsbHMgZm9yIEpTT04gZmlsZXMuXHJcbiAqIFNlZSBkb2NzIGZvciBgaTE4bmV4dC14aHItYmFja2VuZGA6IGh0dHBzOi8vZ2l0aHViLmNvbS9pMThuZXh0L2kxOG5leHQteGhyLWJhY2tlbmQjYmFja2VuZC1vcHRpb25zXHJcbiAqXHJcbiAqIEl0IHVzZXMgQW5ndWxhciBIdHRwQ2xpZW50IHVuZGVyIHRoZSBob29kLCBzbyBpdCB3b3JrcyBpbiBTU1IuXHJcbiAqIEBwYXJhbSBodHRwQ2xpZW50IEFuZ3VsYXIgaHR0cCBjbGllbnRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpMThuZXh0R2V0SHR0cENsaWVudChcclxuICBodHRwQ2xpZW50OiBIdHRwQ2xpZW50XHJcbik6ICh1cmw6IHN0cmluZywgb3B0aW9uczogb2JqZWN0LCBjYWxsYmFjazogRnVuY3Rpb24sIGRhdGE6IG9iamVjdCkgPT4gdm9pZCB7XHJcbiAgcmV0dXJuICh1cmw6IHN0cmluZywgX29wdGlvbnM6IG9iamVjdCwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBfZGF0YTogb2JqZWN0KSA9PiB7XHJcbiAgICBodHRwQ2xpZW50LmdldCh1cmwsIHsgcmVzcG9uc2VUeXBlOiAndGV4dCcgfSkuc3Vic2NyaWJlKFxyXG4gICAgICAoZGF0YSkgPT4gY2FsbGJhY2soZGF0YSwgeyBzdGF0dXM6IDIwMCB9KSxcclxuICAgICAgKGVycm9yKSA9PiBjYWxsYmFjayhudWxsLCB7IHN0YXR1czogZXJyb3Iuc3RhdHVzIH0pXHJcbiAgICApO1xyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXNvbHZlcyB0aGUgcmVsYXRpdmUgcGF0aCB0byB0aGUgYWJzb2x1dGUgb25lIGluIFNTUiwgdXNpbmcgdGhlIHNlcnZlciByZXF1ZXN0J3Mgb3JpZ2luLlxyXG4gKiBJdCdzIG5lZWRlZCwgYmVjYXVzZSBBbmd1bGFyIFVuaXZlcnNhbCBkb2Vzbid0IHN1cHBvcnQgcmVsYXRpdmUgVVJMcyBpbiBIdHRwQ2xpZW50LiBTZWUgQW5ndWxhciBpc3N1ZXM6XHJcbiAqIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTkyMjRcclxuICogLSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci91bml2ZXJzYWwvaXNzdWVzLzg1OFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldExvYWRQYXRoKHBhdGg6IHN0cmluZywgc2VydmVyUmVxdWVzdE9yaWdpbjogc3RyaW5nKTogc3RyaW5nIHtcclxuICBpZiAoIXBhdGgpIHtcclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgfVxyXG4gIGlmIChzZXJ2ZXJSZXF1ZXN0T3JpZ2luICYmICFwYXRoLm1hdGNoKC9eaHR0cChzKT86XFwvXFwvLykpIHtcclxuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xyXG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgxKTtcclxuICAgIH1cclxuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcclxuICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMik7XHJcbiAgICB9XHJcbiAgICBjb25zdCByZXN1bHQgPSBgJHtzZXJ2ZXJSZXF1ZXN0T3JpZ2lufS8ke3BhdGh9YDtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIHJldHVybiBwYXRoO1xyXG59XHJcbiJdfQ==