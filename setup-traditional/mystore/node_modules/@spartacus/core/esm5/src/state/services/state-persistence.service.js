import { __decorate, __read } from "tslib";
import { Injectable } from '@angular/core';
import { of, Subscription } from 'rxjs';
import { map, tap, withLatestFrom } from 'rxjs/operators';
import { StorageSyncType } from '../../state/config/state-config';
import { getStorage, persistToStorage, readFromStorage, } from '../../state/reducers/storage-sync.reducer';
import { WindowRef } from '../../window/window-ref';
import * as i0 from "@angular/core";
import * as i1 from "../../window/window-ref";
var StatePersistenceService = /** @class */ (function () {
    function StatePersistenceService(winRef) {
        this.winRef = winRef;
    }
    /**
     * Helper to synchronize state to more persistent storage (localStorage, sessionStorage).
     * It is context aware, so you can keep different state for te same feature based on specified context.
     *
     * Eg. cart is valid only under the same base site. So you want to synchronize cart only with the same base site.
     * Usage for that case: `syncWithStorage({ key: 'cart', state$: activeCartSelector$, context$: this.siteContextParamsService.getValues([BASE_SITE_CONTEXT_ID]), onRead: (state) => setCorrectStateInStore(state) })`.
     * Active cart for the `electronics` base site will be stored under `spartacus⚿electronics⚿cart` and for apparel under `spartacus⚿apparel⚿cart`.
     *
     * On each context change onRead function will be executed with state from storage provided as a parameter.
     *
     * Omitting context$ will trigger onRead only once at initialization.
     *
     * @param key Key to use in storage for the synchronized state. Should be unique for each feature.
     * @param state$ State to be saved and later restored.
     * @param context$ Context for state
     * @param storageType Storage type to be used to persist state
     * @param onRead Function to be executed on each storage read after context change
     *
     * @returns Subscriptions for reading/writing in storage on context/state change
     */
    StatePersistenceService.prototype.syncWithStorage = function (_a) {
        var _this = this;
        var key = _a.key, state$ = _a.state$, _b = _a.context$, context$ = _b === void 0 ? of('') : _b, _c = _a.storageType, storageType = _c === void 0 ? StorageSyncType.LOCAL_STORAGE : _c, _d = _a.onRead, onRead = _d === void 0 ? function () { } : _d;
        var storage = getStorage(storageType, this.winRef);
        var subscriptions = new Subscription();
        // Do not change order of subscription! Read should happen before write on context change.
        subscriptions.add(context$
            .pipe(map(function (context) {
            return readFromStorage(storage, _this.generateKeyWithContext(context, key));
        }), tap(function (state) { return onRead(state); }))
            .subscribe());
        subscriptions.add(state$.pipe(withLatestFrom(context$)).subscribe(function (_a) {
            var _b = __read(_a, 2), state = _b[0], context = _b[1];
            persistToStorage(_this.generateKeyWithContext(context, key), state, storage);
        }));
        return subscriptions;
    };
    StatePersistenceService.prototype.generateKeyWithContext = function (context, key) {
        return "spartacus\u26BF" + [].concat(context).join('⚿') + "\u26BF" + key;
    };
    StatePersistenceService.ctorParameters = function () { return [
        { type: WindowRef }
    ]; };
    StatePersistenceService.ɵprov = i0.ɵɵdefineInjectable({ factory: function StatePersistenceService_Factory() { return new StatePersistenceService(i0.ɵɵinject(i1.WindowRef)); }, token: StatePersistenceService, providedIn: "root" });
    StatePersistenceService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], StatePersistenceService);
    return StatePersistenceService;
}());
export { StatePersistenceService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtcGVyc2lzdGVuY2Uuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9zdGF0ZS9zZXJ2aWNlcy9zdGF0ZS1wZXJzaXN0ZW5jZS5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBYyxFQUFFLEVBQUUsWUFBWSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ3BELE9BQU8sRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzFELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxpQ0FBaUMsQ0FBQztBQUNsRSxPQUFPLEVBQ0wsVUFBVSxFQUNWLGdCQUFnQixFQUNoQixlQUFlLEdBQ2hCLE1BQU0sMkNBQTJDLENBQUM7QUFDbkQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7QUFLcEQ7SUFDRSxpQ0FBc0IsTUFBaUI7UUFBakIsV0FBTSxHQUFOLE1BQU0sQ0FBVztJQUFHLENBQUM7SUFFM0M7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FtQkc7SUFDSCxpREFBZSxHQUFmLFVBQW1CLEVBWWxCO1FBWkQsaUJBMkNDO1lBMUNDLFlBQUcsRUFDSCxrQkFBTSxFQUNOLGdCQUFpQixFQUFqQixzQ0FBaUIsRUFDakIsbUJBQTJDLEVBQTNDLGdFQUEyQyxFQUMzQyxjQUFpQixFQUFqQiw2Q0FBaUI7UUFRakIsSUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFckQsSUFBTSxhQUFhLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUV6QywwRkFBMEY7UUFDMUYsYUFBYSxDQUFDLEdBQUcsQ0FDZixRQUFRO2FBQ0wsSUFBSSxDQUNILEdBQUcsQ0FBQyxVQUFDLE9BQU87WUFDVixPQUFPLGVBQWUsQ0FDcEIsT0FBTyxFQUNQLEtBQUksQ0FBQyxzQkFBc0IsQ0FBQyxPQUFPLEVBQUUsR0FBRyxDQUFDLENBQ3JDLENBQUM7UUFDVCxDQUFDLENBQUMsRUFDRixHQUFHLENBQUMsVUFBQyxLQUFLLElBQUssT0FBQSxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQWIsQ0FBYSxDQUFDLENBQzlCO2FBQ0EsU0FBUyxFQUFFLENBQ2YsQ0FBQztRQUVGLGFBQWEsQ0FBQyxHQUFHLENBQ2YsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsVUFBQyxFQUFnQjtnQkFBaEIsa0JBQWdCLEVBQWYsYUFBSyxFQUFFLGVBQU87WUFDOUQsZ0JBQWdCLENBQ2QsS0FBSSxDQUFDLHNCQUFzQixDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsRUFDekMsS0FBSyxFQUNMLE9BQU8sQ0FDUixDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQ0gsQ0FBQztRQUVGLE9BQU8sYUFBYSxDQUFDO0lBQ3ZCLENBQUM7SUFFUyx3REFBc0IsR0FBaEMsVUFDRSxPQUErQixFQUMvQixHQUFXO1FBRVgsT0FBTyxvQkFBYSxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBSSxHQUFLLENBQUM7SUFDNUQsQ0FBQzs7Z0JBeEU2QixTQUFTOzs7SUFENUIsdUJBQXVCO1FBSG5DLFVBQVUsQ0FBQztZQUNWLFVBQVUsRUFBRSxNQUFNO1NBQ25CLENBQUM7T0FDVyx1QkFBdUIsQ0EwRW5DO2tDQXhGRDtDQXdGQyxBQTFFRCxJQTBFQztTQTFFWSx1QkFBdUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgbWFwLCB0YXAsIHdpdGhMYXRlc3RGcm9tIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBTdG9yYWdlU3luY1R5cGUgfSBmcm9tICcuLi8uLi9zdGF0ZS9jb25maWcvc3RhdGUtY29uZmlnJztcclxuaW1wb3J0IHtcclxuICBnZXRTdG9yYWdlLFxyXG4gIHBlcnNpc3RUb1N0b3JhZ2UsXHJcbiAgcmVhZEZyb21TdG9yYWdlLFxyXG59IGZyb20gJy4uLy4uL3N0YXRlL3JlZHVjZXJzL3N0b3JhZ2Utc3luYy5yZWR1Y2VyJztcclxuaW1wb3J0IHsgV2luZG93UmVmIH0gZnJvbSAnLi4vLi4vd2luZG93L3dpbmRvdy1yZWYnO1xyXG5cclxuQEluamVjdGFibGUoe1xyXG4gIHByb3ZpZGVkSW46ICdyb290JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFN0YXRlUGVyc2lzdGVuY2VTZXJ2aWNlIHtcclxuICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgd2luUmVmOiBXaW5kb3dSZWYpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEhlbHBlciB0byBzeW5jaHJvbml6ZSBzdGF0ZSB0byBtb3JlIHBlcnNpc3RlbnQgc3RvcmFnZSAobG9jYWxTdG9yYWdlLCBzZXNzaW9uU3RvcmFnZSkuXHJcbiAgICogSXQgaXMgY29udGV4dCBhd2FyZSwgc28geW91IGNhbiBrZWVwIGRpZmZlcmVudCBzdGF0ZSBmb3IgdGUgc2FtZSBmZWF0dXJlIGJhc2VkIG9uIHNwZWNpZmllZCBjb250ZXh0LlxyXG4gICAqXHJcbiAgICogRWcuIGNhcnQgaXMgdmFsaWQgb25seSB1bmRlciB0aGUgc2FtZSBiYXNlIHNpdGUuIFNvIHlvdSB3YW50IHRvIHN5bmNocm9uaXplIGNhcnQgb25seSB3aXRoIHRoZSBzYW1lIGJhc2Ugc2l0ZS5cclxuICAgKiBVc2FnZSBmb3IgdGhhdCBjYXNlOiBgc3luY1dpdGhTdG9yYWdlKHsga2V5OiAnY2FydCcsIHN0YXRlJDogYWN0aXZlQ2FydFNlbGVjdG9yJCwgY29udGV4dCQ6IHRoaXMuc2l0ZUNvbnRleHRQYXJhbXNTZXJ2aWNlLmdldFZhbHVlcyhbQkFTRV9TSVRFX0NPTlRFWFRfSURdKSwgb25SZWFkOiAoc3RhdGUpID0+IHNldENvcnJlY3RTdGF0ZUluU3RvcmUoc3RhdGUpIH0pYC5cclxuICAgKiBBY3RpdmUgY2FydCBmb3IgdGhlIGBlbGVjdHJvbmljc2AgYmFzZSBzaXRlIHdpbGwgYmUgc3RvcmVkIHVuZGVyIGBzcGFydGFjdXPimr9lbGVjdHJvbmljc+Kav2NhcnRgIGFuZCBmb3IgYXBwYXJlbCB1bmRlciBgc3BhcnRhY3Vz4pq/YXBwYXJlbOKav2NhcnRgLlxyXG4gICAqXHJcbiAgICogT24gZWFjaCBjb250ZXh0IGNoYW5nZSBvblJlYWQgZnVuY3Rpb24gd2lsbCBiZSBleGVjdXRlZCB3aXRoIHN0YXRlIGZyb20gc3RvcmFnZSBwcm92aWRlZCBhcyBhIHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIE9taXR0aW5nIGNvbnRleHQkIHdpbGwgdHJpZ2dlciBvblJlYWQgb25seSBvbmNlIGF0IGluaXRpYWxpemF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGtleSBLZXkgdG8gdXNlIGluIHN0b3JhZ2UgZm9yIHRoZSBzeW5jaHJvbml6ZWQgc3RhdGUuIFNob3VsZCBiZSB1bmlxdWUgZm9yIGVhY2ggZmVhdHVyZS5cclxuICAgKiBAcGFyYW0gc3RhdGUkIFN0YXRlIHRvIGJlIHNhdmVkIGFuZCBsYXRlciByZXN0b3JlZC5cclxuICAgKiBAcGFyYW0gY29udGV4dCQgQ29udGV4dCBmb3Igc3RhdGVcclxuICAgKiBAcGFyYW0gc3RvcmFnZVR5cGUgU3RvcmFnZSB0eXBlIHRvIGJlIHVzZWQgdG8gcGVyc2lzdCBzdGF0ZVxyXG4gICAqIEBwYXJhbSBvblJlYWQgRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgb24gZWFjaCBzdG9yYWdlIHJlYWQgYWZ0ZXIgY29udGV4dCBjaGFuZ2VcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIFN1YnNjcmlwdGlvbnMgZm9yIHJlYWRpbmcvd3JpdGluZyBpbiBzdG9yYWdlIG9uIGNvbnRleHQvc3RhdGUgY2hhbmdlXHJcbiAgICovXHJcbiAgc3luY1dpdGhTdG9yYWdlPFQ+KHtcclxuICAgIGtleSxcclxuICAgIHN0YXRlJCxcclxuICAgIGNvbnRleHQkID0gb2YoJycpLFxyXG4gICAgc3RvcmFnZVR5cGUgPSBTdG9yYWdlU3luY1R5cGUuTE9DQUxfU1RPUkFHRSxcclxuICAgIG9uUmVhZCA9ICgpID0+IHt9LFxyXG4gIH06IHtcclxuICAgIGtleTogc3RyaW5nO1xyXG4gICAgc3RhdGUkOiBPYnNlcnZhYmxlPFQ+O1xyXG4gICAgY29udGV4dCQ/OiBPYnNlcnZhYmxlPHN0cmluZyB8IEFycmF5PHN0cmluZz4+O1xyXG4gICAgc3RvcmFnZVR5cGU/OiBTdG9yYWdlU3luY1R5cGU7XHJcbiAgICBvblJlYWQ/OiAoc3RhdGVGcm9tU3RvcmFnZTogVCkgPT4gdm9pZDtcclxuICB9KTogU3Vic2NyaXB0aW9uIHtcclxuICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHN0b3JhZ2VUeXBlLCB0aGlzLndpblJlZik7XHJcblxyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcclxuXHJcbiAgICAvLyBEbyBub3QgY2hhbmdlIG9yZGVyIG9mIHN1YnNjcmlwdGlvbiEgUmVhZCBzaG91bGQgaGFwcGVuIGJlZm9yZSB3cml0ZSBvbiBjb250ZXh0IGNoYW5nZS5cclxuICAgIHN1YnNjcmlwdGlvbnMuYWRkKFxyXG4gICAgICBjb250ZXh0JFxyXG4gICAgICAgIC5waXBlKFxyXG4gICAgICAgICAgbWFwKChjb250ZXh0KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiByZWFkRnJvbVN0b3JhZ2UoXHJcbiAgICAgICAgICAgICAgc3RvcmFnZSxcclxuICAgICAgICAgICAgICB0aGlzLmdlbmVyYXRlS2V5V2l0aENvbnRleHQoY29udGV4dCwga2V5KVxyXG4gICAgICAgICAgICApIGFzIFQ7XHJcbiAgICAgICAgICB9KSxcclxuICAgICAgICAgIHRhcCgoc3RhdGUpID0+IG9uUmVhZChzdGF0ZSkpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIC5zdWJzY3JpYmUoKVxyXG4gICAgKTtcclxuXHJcbiAgICBzdWJzY3JpcHRpb25zLmFkZChcclxuICAgICAgc3RhdGUkLnBpcGUod2l0aExhdGVzdEZyb20oY29udGV4dCQpKS5zdWJzY3JpYmUoKFtzdGF0ZSwgY29udGV4dF0pID0+IHtcclxuICAgICAgICBwZXJzaXN0VG9TdG9yYWdlKFxyXG4gICAgICAgICAgdGhpcy5nZW5lcmF0ZUtleVdpdGhDb250ZXh0KGNvbnRleHQsIGtleSksXHJcbiAgICAgICAgICBzdGF0ZSxcclxuICAgICAgICAgIHN0b3JhZ2VcclxuICAgICAgICApO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gc3Vic2NyaXB0aW9ucztcclxuICB9XHJcblxyXG4gIHByb3RlY3RlZCBnZW5lcmF0ZUtleVdpdGhDb250ZXh0KFxyXG4gICAgY29udGV4dDogc3RyaW5nIHwgQXJyYXk8c3RyaW5nPixcclxuICAgIGtleTogc3RyaW5nXHJcbiAgKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBgc3BhcnRhY3Vz4pq/JHtbXS5jb25jYXQoY29udGV4dCkuam9pbign4pq/Jyl94pq/JHtrZXl9YDtcclxuICB9XHJcbn1cclxuIl19