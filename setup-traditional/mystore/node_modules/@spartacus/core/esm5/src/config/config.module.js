import { __decorate, __read, __spread } from "tslib";
import { CommonModule } from '@angular/common';
import { InjectionToken, NgModule, Optional, } from '@angular/core';
import { deepMerge } from './utils/deep-merge';
/**
 * Global Configuration injection token, can be used to inject configuration to any part of the app
 */
export var Config = new InjectionToken('Configuration');
/**
 * Config chunk token, can be used to provide configuration chunk and contribute to the global configuration object.
 * Should not be used directly, use `provideConfig` or import `ConfigModule.withConfig` instead.
 */
export var ConfigChunk = new InjectionToken('ConfigurationChunk');
/**
 * Config chunk token, can be used to provide configuration chunk and contribute to the default configuration.
 * Should not be used directly, use `provideDefaultConfig` or `provideDefaultConfigFactory` instead.
 *
 * General rule is, that all config provided in libraries should be provided as default config.
 */
export var DefaultConfigChunk = new InjectionToken('DefaultConfigurationChunk');
/**
 * Helper function to provide configuration chunk using ConfigChunk token
 *
 * To provide default configuration in libraries provideDefaultConfig should be used instead.
 *
 * @param config Config object to merge with the global configuration
 */
export function provideConfig(config, defaultConfig) {
    if (config === void 0) { config = {}; }
    if (defaultConfig === void 0) { defaultConfig = false; }
    return {
        provide: defaultConfig ? DefaultConfigChunk : ConfigChunk,
        useValue: config,
        multi: true,
    };
}
/**
 * Helper function to provide configuration with factory function, using ConfigChunk token
 *
 * To provide default configuration in libraries provideDefaultConfigFactory should be used instead.
 *
 * @param configFactory Factory Function that will generate config object
 * @param deps Optional dependencies to a factory function
 */
export function provideConfigFactory(configFactory, deps, defaultConfig) {
    if (defaultConfig === void 0) { defaultConfig = false; }
    return {
        provide: defaultConfig ? DefaultConfigChunk : ConfigChunk,
        useFactory: configFactory,
        multi: true,
        deps: deps,
    };
}
/**
 * Helper function to provide default configuration chunk using DefaultConfigChunk token
 *
 * @param config Config object to merge with the default configuration
 */
export function provideDefaultConfig(config) {
    if (config === void 0) { config = {}; }
    return {
        provide: DefaultConfigChunk,
        useValue: config,
        multi: true,
    };
}
/**
 * Helper function to provide default configuration with factory function, using DefaultConfigChunk token
 *
 * @param configFactory Factory Function that will generate config object
 * @param deps Optional dependencies to a factory function
 */
export function provideDefaultConfigFactory(configFactory, deps) {
    return {
        provide: DefaultConfigChunk,
        useFactory: configFactory,
        multi: true,
        deps: deps,
    };
}
/**
 * Factory function that merges all configurations chunks. Should not be used directly without explicit reason.
 *
 */
export function configurationFactory(configChunks, defaultConfigChunks) {
    if (configChunks === void 0) { configChunks = []; }
    if (defaultConfigChunks === void 0) { defaultConfigChunks = []; }
    var config = deepMerge.apply(void 0, __spread([{}], (defaultConfigChunks !== null && defaultConfigChunks !== void 0 ? defaultConfigChunks : []), (configChunks !== null && configChunks !== void 0 ? configChunks : [])));
    return config;
}
var ConfigModule = /** @class */ (function () {
    function ConfigModule() {
    }
    ConfigModule_1 = ConfigModule;
    /**
     * Import ConfigModule and contribute config to the global configuration
     *
     * To provide default configuration in libraries provideDefaultConfig should be used instead.
     *
     * @param config Config object to merge with the global configuration
     */
    ConfigModule.withConfig = function (config) {
        return {
            ngModule: ConfigModule_1,
            providers: [provideConfig(config)],
        };
    };
    /**
     * Import ConfigModule and contribute config to the global configuration using factory function
     *
     * To provide default configuration in libraries provideDefaultConfigFactory should be used instead.
     *
     * @param configFactory Factory function that will generate configuration
     * @param deps Optional dependencies to factory function
     */
    ConfigModule.withConfigFactory = function (configFactory, deps) {
        return {
            ngModule: ConfigModule_1,
            providers: [provideConfigFactory(configFactory, deps)],
        };
    };
    /**
     * Module with providers, should be imported only once, if possible, at the root of the app.
     *
     * @param config
     */
    ConfigModule.forRoot = function (config) {
        if (config === void 0) { config = {}; }
        return {
            ngModule: ConfigModule_1,
            providers: [
                provideConfig(config),
                {
                    provide: Config,
                    useFactory: configurationFactory,
                    deps: [
                        [new Optional(), ConfigChunk],
                        [new Optional(), DefaultConfigChunk],
                    ],
                },
            ],
        };
    };
    var ConfigModule_1;
    ConfigModule = ConfigModule_1 = __decorate([
        NgModule({
            imports: [CommonModule],
            declarations: [],
        })
    ], ConfigModule);
    return ConfigModule;
}());
export { ConfigModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlnLm1vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9jb25maWcvY29uZmlnLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFDTCxjQUFjLEVBRWQsUUFBUSxFQUNSLFFBQVEsR0FFVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFFL0M7O0dBRUc7QUFDSCxNQUFNLENBQUMsSUFBTSxNQUFNLEdBQUcsSUFBSSxjQUFjLENBQUMsZUFBZSxDQUFDLENBQUM7QUFFMUQ7OztHQUdHO0FBQ0gsTUFBTSxDQUFDLElBQU0sV0FBVyxHQUFHLElBQUksY0FBYyxDQUFDLG9CQUFvQixDQUFDLENBQUM7QUFFcEU7Ozs7O0dBS0c7QUFDSCxNQUFNLENBQUMsSUFBTSxrQkFBa0IsR0FBRyxJQUFJLGNBQWMsQ0FDbEQsMkJBQTJCLENBQzVCLENBQUM7QUFFRjs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsYUFBYSxDQUMzQixNQUFnQixFQUNoQixhQUFxQjtJQURyQix1QkFBQSxFQUFBLFdBQWdCO0lBQ2hCLDhCQUFBLEVBQUEscUJBQXFCO0lBRXJCLE9BQU87UUFDTCxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsV0FBVztRQUN6RCxRQUFRLEVBQUUsTUFBTTtRQUNoQixLQUFLLEVBQUUsSUFBSTtLQUNaLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FDbEMsYUFBdUIsRUFDdkIsSUFBWSxFQUNaLGFBQXFCO0lBQXJCLDhCQUFBLEVBQUEscUJBQXFCO0lBRXJCLE9BQU87UUFDTCxPQUFPLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsV0FBVztRQUN6RCxVQUFVLEVBQUUsYUFBYTtRQUN6QixLQUFLLEVBQUUsSUFBSTtRQUNYLElBQUksRUFBRSxJQUFJO0tBQ1gsQ0FBQztBQUNKLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUFDLE1BQWdCO0lBQWhCLHVCQUFBLEVBQUEsV0FBZ0I7SUFDbkQsT0FBTztRQUNMLE9BQU8sRUFBRSxrQkFBa0I7UUFDM0IsUUFBUSxFQUFFLE1BQU07UUFDaEIsS0FBSyxFQUFFLElBQUk7S0FDWixDQUFDO0FBQ0osQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLDJCQUEyQixDQUN6QyxhQUF1QixFQUN2QixJQUFZO0lBRVosT0FBTztRQUNMLE9BQU8sRUFBRSxrQkFBa0I7UUFDM0IsVUFBVSxFQUFFLGFBQWE7UUFDekIsS0FBSyxFQUFFLElBQUk7UUFDWCxJQUFJLEVBQUUsSUFBSTtLQUNYLENBQUM7QUFDSixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUNsQyxZQUF3QixFQUN4QixtQkFBK0I7SUFEL0IsNkJBQUEsRUFBQSxpQkFBd0I7SUFDeEIsb0NBQUEsRUFBQSx3QkFBK0I7SUFFL0IsSUFBTSxNQUFNLEdBQUcsU0FBUyx5QkFDdEIsRUFBRSxHQUNDLENBQUMsbUJBQW1CLGFBQW5CLG1CQUFtQixjQUFuQixtQkFBbUIsR0FBSSxFQUFFLENBQUMsRUFDM0IsQ0FBQyxZQUFZLGFBQVosWUFBWSxjQUFaLFlBQVksR0FBSSxFQUFFLENBQUMsRUFDeEIsQ0FBQztJQUNGLE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFNRDtJQUFBO0lBc0RBLENBQUM7cUJBdERZLFlBQVk7SUFDdkI7Ozs7OztPQU1HO0lBQ0ksdUJBQVUsR0FBakIsVUFBa0IsTUFBYztRQUM5QixPQUFPO1lBQ0wsUUFBUSxFQUFFLGNBQVk7WUFDdEIsU0FBUyxFQUFFLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ25DLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7T0FPRztJQUNJLDhCQUFpQixHQUF4QixVQUNFLGFBQXVCLEVBQ3ZCLElBQVk7UUFFWixPQUFPO1lBQ0wsUUFBUSxFQUFFLGNBQVk7WUFDdEIsU0FBUyxFQUFFLENBQUMsb0JBQW9CLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ3ZELENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNJLG9CQUFPLEdBQWQsVUFBZSxNQUFnQjtRQUFoQix1QkFBQSxFQUFBLFdBQWdCO1FBQzdCLE9BQU87WUFDTCxRQUFRLEVBQUUsY0FBWTtZQUN0QixTQUFTLEVBQUU7Z0JBQ1QsYUFBYSxDQUFDLE1BQU0sQ0FBQztnQkFDckI7b0JBQ0UsT0FBTyxFQUFFLE1BQU07b0JBQ2YsVUFBVSxFQUFFLG9CQUFvQjtvQkFDaEMsSUFBSSxFQUFFO3dCQUNKLENBQUMsSUFBSSxRQUFRLEVBQUUsRUFBRSxXQUFXLENBQUM7d0JBQzdCLENBQUMsSUFBSSxRQUFRLEVBQUUsRUFBRSxrQkFBa0IsQ0FBQztxQkFDckM7aUJBQ0Y7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDOztJQXJEVSxZQUFZO1FBSnhCLFFBQVEsQ0FBQztZQUNSLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQztZQUN2QixZQUFZLEVBQUUsRUFBRTtTQUNqQixDQUFDO09BQ1csWUFBWSxDQXNEeEI7SUFBRCxtQkFBQztDQUFBLEFBdERELElBc0RDO1NBdERZLFlBQVkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQge1xyXG4gIEluamVjdGlvblRva2VuLFxyXG4gIE1vZHVsZVdpdGhQcm92aWRlcnMsXHJcbiAgTmdNb2R1bGUsXHJcbiAgT3B0aW9uYWwsXHJcbiAgUHJvdmlkZXIsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IGRlZXBNZXJnZSB9IGZyb20gJy4vdXRpbHMvZGVlcC1tZXJnZSc7XHJcblxyXG4vKipcclxuICogR2xvYmFsIENvbmZpZ3VyYXRpb24gaW5qZWN0aW9uIHRva2VuLCBjYW4gYmUgdXNlZCB0byBpbmplY3QgY29uZmlndXJhdGlvbiB0byBhbnkgcGFydCBvZiB0aGUgYXBwXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ29uZmlnID0gbmV3IEluamVjdGlvblRva2VuKCdDb25maWd1cmF0aW9uJyk7XHJcblxyXG4vKipcclxuICogQ29uZmlnIGNodW5rIHRva2VuLCBjYW4gYmUgdXNlZCB0byBwcm92aWRlIGNvbmZpZ3VyYXRpb24gY2h1bmsgYW5kIGNvbnRyaWJ1dGUgdG8gdGhlIGdsb2JhbCBjb25maWd1cmF0aW9uIG9iamVjdC5cclxuICogU2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LCB1c2UgYHByb3ZpZGVDb25maWdgIG9yIGltcG9ydCBgQ29uZmlnTW9kdWxlLndpdGhDb25maWdgIGluc3RlYWQuXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQ29uZmlnQ2h1bmsgPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ0NvbmZpZ3VyYXRpb25DaHVuaycpO1xyXG5cclxuLyoqXHJcbiAqIENvbmZpZyBjaHVuayB0b2tlbiwgY2FuIGJlIHVzZWQgdG8gcHJvdmlkZSBjb25maWd1cmF0aW9uIGNodW5rIGFuZCBjb250cmlidXRlIHRvIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24uXHJcbiAqIFNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgdXNlIGBwcm92aWRlRGVmYXVsdENvbmZpZ2Agb3IgYHByb3ZpZGVEZWZhdWx0Q29uZmlnRmFjdG9yeWAgaW5zdGVhZC5cclxuICpcclxuICogR2VuZXJhbCBydWxlIGlzLCB0aGF0IGFsbCBjb25maWcgcHJvdmlkZWQgaW4gbGlicmFyaWVzIHNob3VsZCBiZSBwcm92aWRlZCBhcyBkZWZhdWx0IGNvbmZpZy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBEZWZhdWx0Q29uZmlnQ2h1bmsgPSBuZXcgSW5qZWN0aW9uVG9rZW4oXHJcbiAgJ0RlZmF1bHRDb25maWd1cmF0aW9uQ2h1bmsnXHJcbik7XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY29uZmlndXJhdGlvbiBjaHVuayB1c2luZyBDb25maWdDaHVuayB0b2tlblxyXG4gKlxyXG4gKiBUbyBwcm92aWRlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBpbiBsaWJyYXJpZXMgcHJvdmlkZURlZmF1bHRDb25maWcgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIGNvbmZpZyBDb25maWcgb2JqZWN0IHRvIG1lcmdlIHdpdGggdGhlIGdsb2JhbCBjb25maWd1cmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZUNvbmZpZyhcclxuICBjb25maWc6IGFueSA9IHt9LFxyXG4gIGRlZmF1bHRDb25maWcgPSBmYWxzZVxyXG4pOiBQcm92aWRlciB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHByb3ZpZGU6IGRlZmF1bHRDb25maWcgPyBEZWZhdWx0Q29uZmlnQ2h1bmsgOiBDb25maWdDaHVuayxcclxuICAgIHVzZVZhbHVlOiBjb25maWcsXHJcbiAgICBtdWx0aTogdHJ1ZSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHByb3ZpZGUgY29uZmlndXJhdGlvbiB3aXRoIGZhY3RvcnkgZnVuY3Rpb24sIHVzaW5nIENvbmZpZ0NodW5rIHRva2VuXHJcbiAqXHJcbiAqIFRvIHByb3ZpZGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGluIGxpYnJhcmllcyBwcm92aWRlRGVmYXVsdENvbmZpZ0ZhY3Rvcnkgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cclxuICpcclxuICogQHBhcmFtIGNvbmZpZ0ZhY3RvcnkgRmFjdG9yeSBGdW5jdGlvbiB0aGF0IHdpbGwgZ2VuZXJhdGUgY29uZmlnIG9iamVjdFxyXG4gKiBAcGFyYW0gZGVwcyBPcHRpb25hbCBkZXBlbmRlbmNpZXMgdG8gYSBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZUNvbmZpZ0ZhY3RvcnkoXHJcbiAgY29uZmlnRmFjdG9yeTogRnVuY3Rpb24sXHJcbiAgZGVwcz86IGFueVtdLFxyXG4gIGRlZmF1bHRDb25maWcgPSBmYWxzZVxyXG4pOiBQcm92aWRlciB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHByb3ZpZGU6IGRlZmF1bHRDb25maWcgPyBEZWZhdWx0Q29uZmlnQ2h1bmsgOiBDb25maWdDaHVuayxcclxuICAgIHVzZUZhY3Rvcnk6IGNvbmZpZ0ZhY3RvcnksXHJcbiAgICBtdWx0aTogdHJ1ZSxcclxuICAgIGRlcHM6IGRlcHMsXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBwcm92aWRlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBjaHVuayB1c2luZyBEZWZhdWx0Q29uZmlnQ2h1bmsgdG9rZW5cclxuICpcclxuICogQHBhcmFtIGNvbmZpZyBDb25maWcgb2JqZWN0IHRvIG1lcmdlIHdpdGggdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVEZWZhdWx0Q29uZmlnKGNvbmZpZzogYW55ID0ge30pOiBQcm92aWRlciB7XHJcbiAgcmV0dXJuIHtcclxuICAgIHByb3ZpZGU6IERlZmF1bHRDb25maWdDaHVuayxcclxuICAgIHVzZVZhbHVlOiBjb25maWcsXHJcbiAgICBtdWx0aTogdHJ1ZSxcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIHByb3ZpZGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIHdpdGggZmFjdG9yeSBmdW5jdGlvbiwgdXNpbmcgRGVmYXVsdENvbmZpZ0NodW5rIHRva2VuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb25maWdGYWN0b3J5IEZhY3RvcnkgRnVuY3Rpb24gdGhhdCB3aWxsIGdlbmVyYXRlIGNvbmZpZyBvYmplY3RcclxuICogQHBhcmFtIGRlcHMgT3B0aW9uYWwgZGVwZW5kZW5jaWVzIHRvIGEgZmFjdG9yeSBmdW5jdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVEZWZhdWx0Q29uZmlnRmFjdG9yeShcclxuICBjb25maWdGYWN0b3J5OiBGdW5jdGlvbixcclxuICBkZXBzPzogYW55W11cclxuKTogUHJvdmlkZXIge1xyXG4gIHJldHVybiB7XHJcbiAgICBwcm92aWRlOiBEZWZhdWx0Q29uZmlnQ2h1bmssXHJcbiAgICB1c2VGYWN0b3J5OiBjb25maWdGYWN0b3J5LFxyXG4gICAgbXVsdGk6IHRydWUsXHJcbiAgICBkZXBzOiBkZXBzLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgbWVyZ2VzIGFsbCBjb25maWd1cmF0aW9ucyBjaHVua3MuIFNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSB3aXRob3V0IGV4cGxpY2l0IHJlYXNvbi5cclxuICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmF0aW9uRmFjdG9yeShcclxuICBjb25maWdDaHVua3M6IGFueVtdID0gW10sXHJcbiAgZGVmYXVsdENvbmZpZ0NodW5rczogYW55W10gPSBbXVxyXG4pIHtcclxuICBjb25zdCBjb25maWcgPSBkZWVwTWVyZ2UoXHJcbiAgICB7fSxcclxuICAgIC4uLihkZWZhdWx0Q29uZmlnQ2h1bmtzID8/IFtdKSxcclxuICAgIC4uLihjb25maWdDaHVua3MgPz8gW10pXHJcbiAgKTtcclxuICByZXR1cm4gY29uZmlnO1xyXG59XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGltcG9ydHM6IFtDb21tb25Nb2R1bGVdLFxyXG4gIGRlY2xhcmF0aW9uczogW10sXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBDb25maWdNb2R1bGUge1xyXG4gIC8qKlxyXG4gICAqIEltcG9ydCBDb25maWdNb2R1bGUgYW5kIGNvbnRyaWJ1dGUgY29uZmlnIHRvIHRoZSBnbG9iYWwgY29uZmlndXJhdGlvblxyXG4gICAqXHJcbiAgICogVG8gcHJvdmlkZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gaW4gbGlicmFyaWVzIHByb3ZpZGVEZWZhdWx0Q29uZmlnIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZyBvYmplY3QgdG8gbWVyZ2Ugd2l0aCB0aGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb25cclxuICAgKi9cclxuICBzdGF0aWMgd2l0aENvbmZpZyhjb25maWc6IG9iamVjdCk6IE1vZHVsZVdpdGhQcm92aWRlcnM8Q29uZmlnTW9kdWxlPiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogQ29uZmlnTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtwcm92aWRlQ29uZmlnKGNvbmZpZyldLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEltcG9ydCBDb25maWdNb2R1bGUgYW5kIGNvbnRyaWJ1dGUgY29uZmlnIHRvIHRoZSBnbG9iYWwgY29uZmlndXJhdGlvbiB1c2luZyBmYWN0b3J5IGZ1bmN0aW9uXHJcbiAgICpcclxuICAgKiBUbyBwcm92aWRlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBpbiBsaWJyYXJpZXMgcHJvdmlkZURlZmF1bHRDb25maWdGYWN0b3J5IHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29uZmlnRmFjdG9yeSBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgd2lsbCBnZW5lcmF0ZSBjb25maWd1cmF0aW9uXHJcbiAgICogQHBhcmFtIGRlcHMgT3B0aW9uYWwgZGVwZW5kZW5jaWVzIHRvIGZhY3RvcnkgZnVuY3Rpb25cclxuICAgKi9cclxuICBzdGF0aWMgd2l0aENvbmZpZ0ZhY3RvcnkoXHJcbiAgICBjb25maWdGYWN0b3J5OiBGdW5jdGlvbixcclxuICAgIGRlcHM/OiBhbnlbXVxyXG4gICk6IE1vZHVsZVdpdGhQcm92aWRlcnM8Q29uZmlnTW9kdWxlPiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuZ01vZHVsZTogQ29uZmlnTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtwcm92aWRlQ29uZmlnRmFjdG9yeShjb25maWdGYWN0b3J5LCBkZXBzKV0sXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTW9kdWxlIHdpdGggcHJvdmlkZXJzLCBzaG91bGQgYmUgaW1wb3J0ZWQgb25seSBvbmNlLCBpZiBwb3NzaWJsZSwgYXQgdGhlIHJvb3Qgb2YgdGhlIGFwcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjb25maWdcclxuICAgKi9cclxuICBzdGF0aWMgZm9yUm9vdChjb25maWc6IGFueSA9IHt9KTogTW9kdWxlV2l0aFByb3ZpZGVyczxDb25maWdNb2R1bGU+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBDb25maWdNb2R1bGUsXHJcbiAgICAgIHByb3ZpZGVyczogW1xyXG4gICAgICAgIHByb3ZpZGVDb25maWcoY29uZmlnKSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBwcm92aWRlOiBDb25maWcsXHJcbiAgICAgICAgICB1c2VGYWN0b3J5OiBjb25maWd1cmF0aW9uRmFjdG9yeSxcclxuICAgICAgICAgIGRlcHM6IFtcclxuICAgICAgICAgICAgW25ldyBPcHRpb25hbCgpLCBDb25maWdDaHVua10sXHJcbiAgICAgICAgICAgIFtuZXcgT3B0aW9uYWwoKSwgRGVmYXVsdENvbmZpZ0NodW5rXSxcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdfQ==