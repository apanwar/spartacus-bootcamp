import { __assign, __decorate, __read } from "tslib";
import { Injectable } from '@angular/core';
import { map, shareReplay } from 'rxjs/operators';
import { extractFields } from '../utils/occ-fields';
import { OccFieldsModel, OccFieldsService, ScopedDataWithUrl, } from './occ-fields.service';
import { HttpClient } from '@angular/common/http';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common/http";
import * as i2 from "./occ-fields.service";
var OccRequestsOptimizerService = /** @class */ (function () {
    function OccRequestsOptimizerService(http, occFields) {
        this.http = http;
        this.occFields = occFields;
    }
    /**
     * Optimize occ endpoint calls merging requests to the same url by merging field parameters
     *
     * @param scopedDataWithUrls
     * @param dataFactory
     */
    OccRequestsOptimizerService.prototype.scopedDataLoad = function (scopedDataWithUrls, dataFactory) {
        var _this = this;
        var result = [];
        if (!dataFactory) {
            dataFactory = function (url) { return _this.http.get(url); };
        }
        var mergedUrls = this.occFields.getOptimalUrlGroups(scopedDataWithUrls);
        Object.entries(mergedUrls).forEach(function (_a) {
            var _b = __read(_a, 2), url = _b[0], groupedModelsSet = _b[1];
            var groupedModels = Object.values(groupedModelsSet);
            if (groupedModels.length === 1) {
                // only one scope for url, we can pass the data straightaway
                result.push(__assign(__assign({}, groupedModels[0].scopedData), { data$: dataFactory(url) }));
            }
            else {
                // multiple scopes per url
                // we have to split the model per each scope
                var data$_1 = dataFactory(url).pipe(shareReplay(1));
                groupedModels.forEach(function (modelData) {
                    result.push(__assign(__assign({}, modelData.scopedData), { data$: data$_1.pipe(map(function (data) { return extractFields(data, modelData.fields); })) }));
                });
            }
        });
        return result;
    };
    OccRequestsOptimizerService.ctorParameters = function () { return [
        { type: HttpClient },
        { type: OccFieldsService }
    ]; };
    OccRequestsOptimizerService.ɵprov = i0.ɵɵdefineInjectable({ factory: function OccRequestsOptimizerService_Factory() { return new OccRequestsOptimizerService(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.OccFieldsService)); }, token: OccRequestsOptimizerService, providedIn: "root" });
    OccRequestsOptimizerService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], OccRequestsOptimizerService);
    return OccRequestsOptimizerService;
}());
export { OccRequestsOptimizerService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLXJlcXVlc3RzLW9wdGltaXplci5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL29jYy9zZXJ2aWNlcy9vY2MtcmVxdWVzdHMtb3B0aW1pemVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFHM0MsT0FBTyxFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFDcEQsT0FBTyxFQUNMLGNBQWMsRUFDZCxnQkFBZ0IsRUFDaEIsaUJBQWlCLEdBQ2xCLE1BQU0sc0JBQXNCLENBQUM7QUFDOUIsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHNCQUFzQixDQUFDOzs7O0FBS2xEO0lBQ0UscUNBQ1ksSUFBZ0IsRUFDaEIsU0FBMkI7UUFEM0IsU0FBSSxHQUFKLElBQUksQ0FBWTtRQUNoQixjQUFTLEdBQVQsU0FBUyxDQUFrQjtJQUNwQyxDQUFDO0lBRUo7Ozs7O09BS0c7SUFDSCxvREFBYyxHQUFkLFVBQ0Usa0JBQXVDLEVBQ3ZDLFdBQTRDO1FBRjlDLGlCQTZDQztRQXpDQyxJQUFNLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFFbEIsSUFBSSxDQUFDLFdBQVcsRUFBRTtZQUNoQixXQUFXLEdBQUcsVUFBQyxHQUFHLElBQUssT0FBQSxLQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBTSxHQUFHLENBQUMsRUFBdkIsQ0FBdUIsQ0FBQztTQUNoRDtRQUVELElBQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsQ0FBQztRQUUxRSxNQUFNLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FDaEMsVUFBQyxFQUtBO2dCQUxBLGtCQUtBLEVBTEMsV0FBRyxFQUFFLHdCQUFnQjtZQU1yQixJQUFNLGFBQWEsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFFdEQsSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDOUIsNERBQTREO2dCQUM1RCxNQUFNLENBQUMsSUFBSSx1QkFDTixhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsVUFBVSxLQUM5QixLQUFLLEVBQUUsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUN2QixDQUFDO2FBQ0o7aUJBQU07Z0JBQ0wsMEJBQTBCO2dCQUMxQiw0Q0FBNEM7Z0JBQzVDLElBQU0sT0FBSyxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRXBELGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBQyxTQUFTO29CQUM5QixNQUFNLENBQUMsSUFBSSx1QkFDTixTQUFTLENBQUMsVUFBVSxLQUN2QixLQUFLLEVBQUUsT0FBSyxDQUFDLElBQUksQ0FDZixHQUFHLENBQUMsVUFBQyxJQUFJLElBQUssT0FBQSxhQUFhLENBQUksSUFBSSxFQUFFLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBeEMsQ0FBd0MsQ0FBQyxDQUN4RCxJQUNELENBQUM7Z0JBQ0wsQ0FBQyxDQUFDLENBQUM7YUFDSjtRQUNILENBQUMsQ0FDRixDQUFDO1FBRUYsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7Z0JBdkRpQixVQUFVO2dCQUNMLGdCQUFnQjs7O0lBSDVCLDJCQUEyQjtRQUh2QyxVQUFVLENBQUM7WUFDVixVQUFVLEVBQUUsTUFBTTtTQUNuQixDQUFDO09BQ1csMkJBQTJCLENBMER2QztzQ0F6RUQ7Q0F5RUMsQUExREQsSUEwREM7U0ExRFksMkJBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7IFNjb3BlZERhdGEgfSBmcm9tICcuLi8uLi9tb2RlbC9zY29wZWQtZGF0YSc7XHJcbmltcG9ydCB7IG1hcCwgc2hhcmVSZXBsYXkgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IGV4dHJhY3RGaWVsZHMgfSBmcm9tICcuLi91dGlscy9vY2MtZmllbGRzJztcclxuaW1wb3J0IHtcclxuICBPY2NGaWVsZHNNb2RlbCxcclxuICBPY2NGaWVsZHNTZXJ2aWNlLFxyXG4gIFNjb3BlZERhdGFXaXRoVXJsLFxyXG59IGZyb20gJy4vb2NjLWZpZWxkcy5zZXJ2aWNlJztcclxuaW1wb3J0IHsgSHR0cENsaWVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcclxuXHJcbkBJbmplY3RhYmxlKHtcclxuICBwcm92aWRlZEluOiAncm9vdCcsXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBPY2NSZXF1ZXN0c09wdGltaXplclNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJvdGVjdGVkIGh0dHA6IEh0dHBDbGllbnQsXHJcbiAgICBwcm90ZWN0ZWQgb2NjRmllbGRzOiBPY2NGaWVsZHNTZXJ2aWNlXHJcbiAgKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBPcHRpbWl6ZSBvY2MgZW5kcG9pbnQgY2FsbHMgbWVyZ2luZyByZXF1ZXN0cyB0byB0aGUgc2FtZSB1cmwgYnkgbWVyZ2luZyBmaWVsZCBwYXJhbWV0ZXJzXHJcbiAgICpcclxuICAgKiBAcGFyYW0gc2NvcGVkRGF0YVdpdGhVcmxzXHJcbiAgICogQHBhcmFtIGRhdGFGYWN0b3J5XHJcbiAgICovXHJcbiAgc2NvcGVkRGF0YUxvYWQ8VD4oXHJcbiAgICBzY29wZWREYXRhV2l0aFVybHM6IFNjb3BlZERhdGFXaXRoVXJsW10sXHJcbiAgICBkYXRhRmFjdG9yeT86ICh1cmw6IHN0cmluZykgPT4gT2JzZXJ2YWJsZTxUPlxyXG4gICk6IFNjb3BlZERhdGE8VD5bXSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuXHJcbiAgICBpZiAoIWRhdGFGYWN0b3J5KSB7XHJcbiAgICAgIGRhdGFGYWN0b3J5ID0gKHVybCkgPT4gdGhpcy5odHRwLmdldDxhbnk+KHVybCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWVyZ2VkVXJscyA9IHRoaXMub2NjRmllbGRzLmdldE9wdGltYWxVcmxHcm91cHMoc2NvcGVkRGF0YVdpdGhVcmxzKTtcclxuXHJcbiAgICBPYmplY3QuZW50cmllcyhtZXJnZWRVcmxzKS5mb3JFYWNoKFxyXG4gICAgICAoW3VybCwgZ3JvdXBlZE1vZGVsc1NldF06IFtcclxuICAgICAgICBzdHJpbmcsXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgW3Njb3BlOiBzdHJpbmddOiBPY2NGaWVsZHNNb2RlbDtcclxuICAgICAgICB9XHJcbiAgICAgIF0pID0+IHtcclxuICAgICAgICBjb25zdCBncm91cGVkTW9kZWxzID0gT2JqZWN0LnZhbHVlcyhncm91cGVkTW9kZWxzU2V0KTtcclxuXHJcbiAgICAgICAgaWYgKGdyb3VwZWRNb2RlbHMubGVuZ3RoID09PSAxKSB7XHJcbiAgICAgICAgICAvLyBvbmx5IG9uZSBzY29wZSBmb3IgdXJsLCB3ZSBjYW4gcGFzcyB0aGUgZGF0YSBzdHJhaWdodGF3YXlcclxuICAgICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgICAgLi4uZ3JvdXBlZE1vZGVsc1swXS5zY29wZWREYXRhLFxyXG4gICAgICAgICAgICBkYXRhJDogZGF0YUZhY3RvcnkodXJsKSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBtdWx0aXBsZSBzY29wZXMgcGVyIHVybFxyXG4gICAgICAgICAgLy8gd2UgaGF2ZSB0byBzcGxpdCB0aGUgbW9kZWwgcGVyIGVhY2ggc2NvcGVcclxuICAgICAgICAgIGNvbnN0IGRhdGEkID0gZGF0YUZhY3RvcnkodXJsKS5waXBlKHNoYXJlUmVwbGF5KDEpKTtcclxuXHJcbiAgICAgICAgICBncm91cGVkTW9kZWxzLmZvckVhY2goKG1vZGVsRGF0YSkgPT4ge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaCh7XHJcbiAgICAgICAgICAgICAgLi4ubW9kZWxEYXRhLnNjb3BlZERhdGEsXHJcbiAgICAgICAgICAgICAgZGF0YSQ6IGRhdGEkLnBpcGUoXHJcbiAgICAgICAgICAgICAgICBtYXAoKGRhdGEpID0+IGV4dHJhY3RGaWVsZHM8VD4oZGF0YSwgbW9kZWxEYXRhLmZpZWxkcykpXHJcbiAgICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuIl19