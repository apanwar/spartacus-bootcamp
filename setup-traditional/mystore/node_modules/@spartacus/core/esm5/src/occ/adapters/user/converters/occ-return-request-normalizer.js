import { __assign, __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { Converter, ConverterService, } from '../../../../util/converter.service';
import { PRODUCT_NORMALIZER } from '../../../../product/connectors/product/converters';
import * as i0 from "@angular/core";
import * as i1 from "../../../../util/converter.service";
var OccReturnRequestNormalizer = /** @class */ (function () {
    function OccReturnRequestNormalizer(converter) {
        this.converter = converter;
    }
    OccReturnRequestNormalizer.prototype.convert = function (source, target) {
        var _this = this;
        if (target === undefined) {
            target = __assign({}, source);
        }
        if (source.returnEntries) {
            target.returnEntries = source.returnEntries.map(function (entry) { return (__assign(__assign({}, entry), { orderEntry: _this.convertOrderEntry(entry.orderEntry) })); });
        }
        return target;
    };
    OccReturnRequestNormalizer.prototype.convertOrderEntry = function (source) {
        return __assign(__assign({}, source), { product: this.converter.convert(source.product, PRODUCT_NORMALIZER) });
    };
    OccReturnRequestNormalizer.ctorParameters = function () { return [
        { type: ConverterService }
    ]; };
    OccReturnRequestNormalizer.ɵprov = i0.ɵɵdefineInjectable({ factory: function OccReturnRequestNormalizer_Factory() { return new OccReturnRequestNormalizer(i0.ɵɵinject(i1.ConverterService)); }, token: OccReturnRequestNormalizer, providedIn: "root" });
    OccReturnRequestNormalizer = __decorate([
        Injectable({ providedIn: 'root' })
    ], OccReturnRequestNormalizer);
    return OccReturnRequestNormalizer;
}());
export { OccReturnRequestNormalizer };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2NjLXJldHVybi1yZXF1ZXN0LW5vcm1hbGl6ZXIuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Ac3BhcnRhY3VzL2NvcmUvIiwic291cmNlcyI6WyJzcmMvb2NjL2FkYXB0ZXJzL3VzZXIvY29udmVydGVycy9vY2MtcmV0dXJuLXJlcXVlc3Qtbm9ybWFsaXplci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUzQyxPQUFPLEVBQ0wsU0FBUyxFQUNULGdCQUFnQixHQUNqQixNQUFNLG9DQUFvQyxDQUFDO0FBRTVDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLG1EQUFtRCxDQUFDOzs7QUFHdkY7SUFFRSxvQ0FBb0IsU0FBMkI7UUFBM0IsY0FBUyxHQUFULFNBQVMsQ0FBa0I7SUFBRyxDQUFDO0lBRW5ELDRDQUFPLEdBQVAsVUFBUSxNQUF5QixFQUFFLE1BQXNCO1FBQXpELGlCQWFDO1FBWkMsSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFO1lBQ3hCLE1BQU0sZ0JBQVMsTUFBYyxDQUFFLENBQUM7U0FDakM7UUFFRCxJQUFJLE1BQU0sQ0FBQyxhQUFhLEVBQUU7WUFDeEIsTUFBTSxDQUFDLGFBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxVQUFDLEtBQUssSUFBSyxPQUFBLHVCQUN0RCxLQUFLLEtBQ1IsVUFBVSxFQUFFLEtBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLElBQ3BELEVBSHlELENBR3pELENBQUMsQ0FBQztTQUNMO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVPLHNEQUFpQixHQUF6QixVQUEwQixNQUFzQjtRQUM5Qyw2QkFDSyxNQUFNLEtBQ1QsT0FBTyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsa0JBQWtCLENBQUMsSUFDbkU7SUFDSixDQUFDOztnQkF0QjhCLGdCQUFnQjs7O0lBRnBDLDBCQUEwQjtRQUR0QyxVQUFVLENBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUM7T0FDdEIsMEJBQTBCLENBeUJ0QztxQ0FuQ0Q7Q0FtQ0MsQUF6QkQsSUF5QkM7U0F6QlksMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBPY2MgfSBmcm9tICcuLi8uLi8uLi9vY2MtbW9kZWxzL29jYy5tb2RlbHMnO1xyXG5pbXBvcnQge1xyXG4gIENvbnZlcnRlcixcclxuICBDb252ZXJ0ZXJTZXJ2aWNlLFxyXG59IGZyb20gJy4uLy4uLy4uLy4uL3V0aWwvY29udmVydGVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBPcmRlckVudHJ5LCBSZXR1cm5SZXF1ZXN0IH0gZnJvbSAnLi4vLi4vLi4vLi4vbW9kZWwvb3JkZXIubW9kZWwnO1xyXG5pbXBvcnQgeyBQUk9EVUNUX05PUk1BTElaRVIgfSBmcm9tICcuLi8uLi8uLi8uLi9wcm9kdWN0L2Nvbm5lY3RvcnMvcHJvZHVjdC9jb252ZXJ0ZXJzJztcclxuXHJcbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXHJcbmV4cG9ydCBjbGFzcyBPY2NSZXR1cm5SZXF1ZXN0Tm9ybWFsaXplclxyXG4gIGltcGxlbWVudHMgQ29udmVydGVyPE9jYy5SZXR1cm5SZXF1ZXN0LCBSZXR1cm5SZXF1ZXN0PiB7XHJcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb252ZXJ0ZXI6IENvbnZlcnRlclNlcnZpY2UpIHt9XHJcblxyXG4gIGNvbnZlcnQoc291cmNlOiBPY2MuUmV0dXJuUmVxdWVzdCwgdGFyZ2V0PzogUmV0dXJuUmVxdWVzdCk6IFJldHVyblJlcXVlc3Qge1xyXG4gICAgaWYgKHRhcmdldCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRhcmdldCA9IHsgLi4uKHNvdXJjZSBhcyBhbnkpIH07XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNvdXJjZS5yZXR1cm5FbnRyaWVzKSB7XHJcbiAgICAgIHRhcmdldC5yZXR1cm5FbnRyaWVzID0gc291cmNlLnJldHVybkVudHJpZXMubWFwKChlbnRyeSkgPT4gKHtcclxuICAgICAgICAuLi5lbnRyeSxcclxuICAgICAgICBvcmRlckVudHJ5OiB0aGlzLmNvbnZlcnRPcmRlckVudHJ5KGVudHJ5Lm9yZGVyRW50cnkpLFxyXG4gICAgICB9KSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY29udmVydE9yZGVyRW50cnkoc291cmNlOiBPY2MuT3JkZXJFbnRyeSk6IE9yZGVyRW50cnkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4uc291cmNlLFxyXG4gICAgICBwcm9kdWN0OiB0aGlzLmNvbnZlcnRlci5jb252ZXJ0KHNvdXJjZS5wcm9kdWN0LCBQUk9EVUNUX05PUk1BTElaRVIpLFxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl19