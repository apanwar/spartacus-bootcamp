import { __decorate } from "tslib";
import { Injectable, isDevMode } from '@angular/core';
import { Subject } from 'rxjs';
import { tap } from 'rxjs/operators';
import { MergingSubject } from './utils/merging-subject';
import * as i0 from "@angular/core";
/**
 * A service to register and observe event sources. Events are driven by event types, which are class signatures
 * for the given event.
 *
 * It is possible to register multiple sources to a single event, even without
 * knowing as multiple decoupled features can attach sources to the same
 * event type.
 */
var EventService = /** @class */ (function () {
    function EventService() {
        /**
         * The various events meta are collected in a map, stored by the event type class
         */
        this.eventsMeta = new Map();
    }
    /**
     * Register an event source for the given event type.
     *
     * CAUTION: To avoid memory leaks, the returned teardown function should be called
     *  when the event source is no longer maintained by its creator
     * (i.e. in `ngOnDestroy` if the event source was registered in the component).
     *
     * @param eventType the event type
     * @param source$ an observable that represents the source
     *
     * @returns a teardown function which unregisters the given event source
     */
    EventService.prototype.register = function (eventType, source$) {
        var eventMeta = this.getEventMeta(eventType);
        if (eventMeta.mergingSubject.has(source$)) {
            if (isDevMode()) {
                console.warn("EventService: the event source", source$, "has been already registered for the type", eventType);
            }
        }
        else {
            eventMeta.mergingSubject.add(source$);
        }
        return function () { return eventMeta.mergingSubject.remove(source$); };
    };
    /**
     * Returns a stream of events for the given event type
     * @param eventTypes event type
     */
    EventService.prototype.get = function (eventType) {
        var output$ = this.getEventMeta(eventType).mergingSubject.output$;
        if (isDevMode()) {
            output$ = this.getValidatedEventStream(output$, eventType);
        }
        return output$;
    };
    /**
     * Dispatches an instance of an individual event.
     */
    EventService.prototype.dispatch = function (event) {
        var eventType = event.constructor;
        var inputSubject$ = this.getInputSubject(eventType);
        inputSubject$.next(event);
    };
    /**
     * Returns the input subject used to dispatch a single event.
     * The subject is created on demand, when it's needed for the first time.
     * @param eventType type of event
     */
    EventService.prototype.getInputSubject = function (eventType) {
        var eventMeta = this.getEventMeta(eventType);
        if (!eventMeta.inputSubject$) {
            eventMeta.inputSubject$ = new Subject();
            this.register(eventType, eventMeta.inputSubject$);
        }
        return eventMeta.inputSubject$;
    };
    /**
     * Returns the event meta object for the given event type
     */
    EventService.prototype.getEventMeta = function (eventType) {
        if (isDevMode()) {
            this.validateEventType(eventType);
        }
        if (!this.eventsMeta.get(eventType)) {
            this.createEventMeta(eventType);
        }
        return this.eventsMeta.get(eventType);
    };
    /**
     * Creates the event meta object for the given event type
     */
    EventService.prototype.createEventMeta = function (eventType) {
        this.eventsMeta.set(eventType, {
            inputSubject$: null,
            mergingSubject: new MergingSubject(),
        });
    };
    /**
     * Checks if the event type is a valid type (is a class with constructor).
     *
     * Should be used only in dev mode.
     */
    EventService.prototype.validateEventType = function (eventType) {
        if (!(eventType === null || eventType === void 0 ? void 0 : eventType.constructor)) {
            throw new Error("EventService:  " + eventType + " is not a valid event type. Please provide a class reference.");
        }
    };
    /**
     * Returns the given event source with runtime validation whether the emitted values are instances of given event type.
     *
     * Should be used only in dev mode.
     */
    EventService.prototype.getValidatedEventStream = function (source$, eventType) {
        return source$.pipe(tap(function (event) {
            if (!(event instanceof eventType)) {
                console.warn("EventService: The stream", source$, "emitted the event", event, "that is not an instance of the declared type", eventType.name);
            }
        }));
    };
    EventService.ɵprov = i0.ɵɵdefineInjectable({ factory: function EventService_Factory() { return new EventService(); }, token: EventService, providedIn: "root" });
    EventService = __decorate([
        Injectable({
            providedIn: 'root',
        })
    ], EventService);
    return EventService;
}());
export { EventService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXZlbnQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9ldmVudC9ldmVudC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBUSxNQUFNLGVBQWUsQ0FBQztBQUM1RCxPQUFPLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0seUJBQXlCLENBQUM7O0FBaUJ6RDs7Ozs7OztHQU9HO0FBSUg7SUFBQTtRQUNFOztXQUVHO1FBQ0ssZUFBVSxHQUFHLElBQUksR0FBRyxFQUE2QixDQUFDO0tBaUkzRDtJQS9IQzs7Ozs7Ozs7Ozs7T0FXRztJQUNILCtCQUFRLEdBQVIsVUFBWSxTQUFrQixFQUFFLE9BQXNCO1FBQ3BELElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0MsSUFBSSxTQUFTLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN6QyxJQUFJLFNBQVMsRUFBRSxFQUFFO2dCQUNmLE9BQU8sQ0FBQyxJQUFJLENBQ1YsZ0NBQWdDLEVBQ2hDLE9BQU8sRUFDUCwwQ0FBMEMsRUFDMUMsU0FBUyxDQUNWLENBQUM7YUFDSDtTQUNGO2FBQU07WUFDTCxTQUFTLENBQUMsY0FBYyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUN2QztRQUVELE9BQU8sY0FBTSxPQUFBLFNBQVMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxFQUF4QyxDQUF3QyxDQUFDO0lBQ3hELENBQUM7SUFFRDs7O09BR0c7SUFDSCwwQkFBRyxHQUFILFVBQU8sU0FBa0I7UUFDdkIsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDO1FBQ2xFLElBQUksU0FBUyxFQUFFLEVBQUU7WUFDZixPQUFPLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztTQUM1RDtRQUNELE9BQU8sT0FBTyxDQUFDO0lBQ2pCLENBQUM7SUFFRDs7T0FFRztJQUNILCtCQUFRLEdBQVIsVUFBUyxLQUFhO1FBQ3BCLElBQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxXQUF3QixDQUFDO1FBQ2pELElBQU0sYUFBYSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDdEQsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLHNDQUFlLEdBQXZCLFVBQTJCLFNBQWtCO1FBQzNDLElBQU0sU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFL0MsSUFBSSxDQUFDLFNBQVMsQ0FBQyxhQUFhLEVBQUU7WUFDNUIsU0FBUyxDQUFDLGFBQWEsR0FBRyxJQUFJLE9BQU8sRUFBTyxDQUFDO1lBQzdDLElBQUksQ0FBQyxRQUFRLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUNuRDtRQUNELE9BQU8sU0FBUyxDQUFDLGFBQWEsQ0FBQztJQUNqQyxDQUFDO0lBRUQ7O09BRUc7SUFDSyxtQ0FBWSxHQUFwQixVQUF3QixTQUFrQjtRQUN4QyxJQUFJLFNBQVMsRUFBRSxFQUFFO1lBQ2YsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ25DO1FBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ25DLElBQUksQ0FBQyxlQUFlLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDakM7UUFDRCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3hDLENBQUM7SUFFRDs7T0FFRztJQUNLLHNDQUFlLEdBQXZCLFVBQTJCLFNBQWtCO1FBQzNDLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLFNBQVMsRUFBRTtZQUM3QixhQUFhLEVBQUUsSUFBSTtZQUNuQixjQUFjLEVBQUUsSUFBSSxjQUFjLEVBQUU7U0FDckMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7SUFDSyx3Q0FBaUIsR0FBekIsVUFBNkIsU0FBa0I7UUFDN0MsSUFBSSxFQUFDLFNBQVMsYUFBVCxTQUFTLHVCQUFULFNBQVMsQ0FBRSxXQUFXLENBQUEsRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUNiLG9CQUFrQixTQUFTLGtFQUErRCxDQUMzRixDQUFDO1NBQ0g7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNLLDhDQUF1QixHQUEvQixVQUNFLE9BQXNCLEVBQ3RCLFNBQWtCO1FBRWxCLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FDakIsR0FBRyxDQUFDLFVBQUMsS0FBSztZQUNSLElBQUksQ0FBQyxDQUFDLEtBQUssWUFBWSxTQUFTLENBQUMsRUFBRTtnQkFDakMsT0FBTyxDQUFDLElBQUksQ0FDViwwQkFBMEIsRUFDMUIsT0FBTyxFQUNQLG1CQUFtQixFQUNuQixLQUFLLEVBQ0wsOENBQThDLEVBQzlDLFNBQVMsQ0FBQyxJQUFJLENBQ2YsQ0FBQzthQUNIO1FBQ0gsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7O0lBcElVLFlBQVk7UUFIeEIsVUFBVSxDQUFDO1lBQ1YsVUFBVSxFQUFFLE1BQU07U0FDbkIsQ0FBQztPQUNXLFlBQVksQ0FxSXhCO3VCQXBLRDtDQW9LQyxBQXJJRCxJQXFJQztTQXJJWSxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgaXNEZXZNb2RlLCBUeXBlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QgfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgdGFwIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xyXG5pbXBvcnQgeyBNZXJnaW5nU3ViamVjdCB9IGZyb20gJy4vdXRpbHMvbWVyZ2luZy1zdWJqZWN0JztcclxuXHJcbi8qKlxyXG4gKiBUaGUgb2JqZWN0IGhvbGRzIHJlZ2lzdGVyZWQgc291cmNlIG9ic2VydmFibGVzIGFzIHdlbGwgYXMgdGhlIG1lcmdlZCByZXN1bHQgb2JzZXJ2YWJsZS5cclxuICovXHJcbmludGVyZmFjZSBFdmVudE1ldGE8VD4ge1xyXG4gIC8qKlxyXG4gICAqIElucHV0IHN1YmplY3QgdXNlZCBmb3IgZGlzcGF0Y2hpbmcgb2NjYXNpb25hbCBldmVudCAod2l0aG91dCByZWdpc3RlcmluZyBhIHNvdXJjZSlcclxuICAgKi9cclxuICBpbnB1dFN1YmplY3QkOiBTdWJqZWN0PFQ+O1xyXG5cclxuICAvKipcclxuICAgKiBBIGN1c3RvbSBzdWJqZWN0IHRoYXQgYWxsb3dzIGZvciBkeW5hbWljIGFkZGluZyBhbmQgcmVtb3Zpbmcgc291cmNlcyB0byBiZSBtZXJnZWQgYXMgYW4gb3V0cHV0XHJcbiAgICovXHJcbiAgbWVyZ2luZ1N1YmplY3Q6IE1lcmdpbmdTdWJqZWN0PFQ+O1xyXG59XHJcblxyXG4vKipcclxuICogQSBzZXJ2aWNlIHRvIHJlZ2lzdGVyIGFuZCBvYnNlcnZlIGV2ZW50IHNvdXJjZXMuIEV2ZW50cyBhcmUgZHJpdmVuIGJ5IGV2ZW50IHR5cGVzLCB3aGljaCBhcmUgY2xhc3Mgc2lnbmF0dXJlc1xyXG4gKiBmb3IgdGhlIGdpdmVuIGV2ZW50LlxyXG4gKlxyXG4gKiBJdCBpcyBwb3NzaWJsZSB0byByZWdpc3RlciBtdWx0aXBsZSBzb3VyY2VzIHRvIGEgc2luZ2xlIGV2ZW50LCBldmVuIHdpdGhvdXRcclxuICoga25vd2luZyBhcyBtdWx0aXBsZSBkZWNvdXBsZWQgZmVhdHVyZXMgY2FuIGF0dGFjaCBzb3VyY2VzIHRvIHRoZSBzYW1lXHJcbiAqIGV2ZW50IHR5cGUuXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSh7XHJcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxyXG59KVxyXG5leHBvcnQgY2xhc3MgRXZlbnRTZXJ2aWNlIHtcclxuICAvKipcclxuICAgKiBUaGUgdmFyaW91cyBldmVudHMgbWV0YSBhcmUgY29sbGVjdGVkIGluIGEgbWFwLCBzdG9yZWQgYnkgdGhlIGV2ZW50IHR5cGUgY2xhc3NcclxuICAgKi9cclxuICBwcml2YXRlIGV2ZW50c01ldGEgPSBuZXcgTWFwPFR5cGU8YW55PiwgRXZlbnRNZXRhPGFueT4+KCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IHNvdXJjZSBmb3IgdGhlIGdpdmVuIGV2ZW50IHR5cGUuXHJcbiAgICpcclxuICAgKiBDQVVUSU9OOiBUbyBhdm9pZCBtZW1vcnkgbGVha3MsIHRoZSByZXR1cm5lZCB0ZWFyZG93biBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkXHJcbiAgICogIHdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBubyBsb25nZXIgbWFpbnRhaW5lZCBieSBpdHMgY3JlYXRvclxyXG4gICAqIChpLmUuIGluIGBuZ09uRGVzdHJveWAgaWYgdGhlIGV2ZW50IHNvdXJjZSB3YXMgcmVnaXN0ZXJlZCBpbiB0aGUgY29tcG9uZW50KS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudFR5cGUgdGhlIGV2ZW50IHR5cGVcclxuICAgKiBAcGFyYW0gc291cmNlJCBhbiBvYnNlcnZhYmxlIHRoYXQgcmVwcmVzZW50cyB0aGUgc291cmNlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBhIHRlYXJkb3duIGZ1bmN0aW9uIHdoaWNoIHVucmVnaXN0ZXJzIHRoZSBnaXZlbiBldmVudCBzb3VyY2VcclxuICAgKi9cclxuICByZWdpc3RlcjxUPihldmVudFR5cGU6IFR5cGU8VD4sIHNvdXJjZSQ6IE9ic2VydmFibGU8VD4pOiAoKSA9PiB2b2lkIHtcclxuICAgIGNvbnN0IGV2ZW50TWV0YSA9IHRoaXMuZ2V0RXZlbnRNZXRhKGV2ZW50VHlwZSk7XHJcbiAgICBpZiAoZXZlbnRNZXRhLm1lcmdpbmdTdWJqZWN0Lmhhcyhzb3VyY2UkKSkge1xyXG4gICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICBgRXZlbnRTZXJ2aWNlOiB0aGUgZXZlbnQgc291cmNlYCxcclxuICAgICAgICAgIHNvdXJjZSQsXHJcbiAgICAgICAgICBgaGFzIGJlZW4gYWxyZWFkeSByZWdpc3RlcmVkIGZvciB0aGUgdHlwZWAsXHJcbiAgICAgICAgICBldmVudFR5cGVcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBldmVudE1ldGEubWVyZ2luZ1N1YmplY3QuYWRkKHNvdXJjZSQpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoKSA9PiBldmVudE1ldGEubWVyZ2luZ1N1YmplY3QucmVtb3ZlKHNvdXJjZSQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIHN0cmVhbSBvZiBldmVudHMgZm9yIHRoZSBnaXZlbiBldmVudCB0eXBlXHJcbiAgICogQHBhcmFtIGV2ZW50VHlwZXMgZXZlbnQgdHlwZVxyXG4gICAqL1xyXG4gIGdldDxUPihldmVudFR5cGU6IFR5cGU8VD4pOiBPYnNlcnZhYmxlPFQ+IHtcclxuICAgIGxldCBvdXRwdXQkID0gdGhpcy5nZXRFdmVudE1ldGEoZXZlbnRUeXBlKS5tZXJnaW5nU3ViamVjdC5vdXRwdXQkO1xyXG4gICAgaWYgKGlzRGV2TW9kZSgpKSB7XHJcbiAgICAgIG91dHB1dCQgPSB0aGlzLmdldFZhbGlkYXRlZEV2ZW50U3RyZWFtKG91dHB1dCQsIGV2ZW50VHlwZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0JDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc3BhdGNoZXMgYW4gaW5zdGFuY2Ugb2YgYW4gaW5kaXZpZHVhbCBldmVudC5cclxuICAgKi9cclxuICBkaXNwYXRjaChldmVudDogT2JqZWN0KTogdm9pZCB7XHJcbiAgICBjb25zdCBldmVudFR5cGUgPSBldmVudC5jb25zdHJ1Y3RvciBhcyBUeXBlPGFueT47XHJcbiAgICBjb25zdCBpbnB1dFN1YmplY3QkID0gdGhpcy5nZXRJbnB1dFN1YmplY3QoZXZlbnRUeXBlKTtcclxuICAgIGlucHV0U3ViamVjdCQubmV4dChldmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBpbnB1dCBzdWJqZWN0IHVzZWQgdG8gZGlzcGF0Y2ggYSBzaW5nbGUgZXZlbnQuXHJcbiAgICogVGhlIHN1YmplY3QgaXMgY3JlYXRlZCBvbiBkZW1hbmQsIHdoZW4gaXQncyBuZWVkZWQgZm9yIHRoZSBmaXJzdCB0aW1lLlxyXG4gICAqIEBwYXJhbSBldmVudFR5cGUgdHlwZSBvZiBldmVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgZ2V0SW5wdXRTdWJqZWN0PFQ+KGV2ZW50VHlwZTogVHlwZTxUPik6IFN1YmplY3Q8VD4ge1xyXG4gICAgY29uc3QgZXZlbnRNZXRhID0gdGhpcy5nZXRFdmVudE1ldGEoZXZlbnRUeXBlKTtcclxuXHJcbiAgICBpZiAoIWV2ZW50TWV0YS5pbnB1dFN1YmplY3QkKSB7XHJcbiAgICAgIGV2ZW50TWV0YS5pbnB1dFN1YmplY3QkID0gbmV3IFN1YmplY3Q8YW55PigpO1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyKGV2ZW50VHlwZSwgZXZlbnRNZXRhLmlucHV0U3ViamVjdCQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50TWV0YS5pbnB1dFN1YmplY3QkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgZXZlbnQgbWV0YSBvYmplY3QgZm9yIHRoZSBnaXZlbiBldmVudCB0eXBlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBnZXRFdmVudE1ldGE8VD4oZXZlbnRUeXBlOiBUeXBlPFQ+KTogRXZlbnRNZXRhPFQ+IHtcclxuICAgIGlmIChpc0Rldk1vZGUoKSkge1xyXG4gICAgICB0aGlzLnZhbGlkYXRlRXZlbnRUeXBlKGV2ZW50VHlwZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCF0aGlzLmV2ZW50c01ldGEuZ2V0KGV2ZW50VHlwZSkpIHtcclxuICAgICAgdGhpcy5jcmVhdGVFdmVudE1ldGEoZXZlbnRUeXBlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzLmV2ZW50c01ldGEuZ2V0KGV2ZW50VHlwZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIHRoZSBldmVudCBtZXRhIG9iamVjdCBmb3IgdGhlIGdpdmVuIGV2ZW50IHR5cGVcclxuICAgKi9cclxuICBwcml2YXRlIGNyZWF0ZUV2ZW50TWV0YTxUPihldmVudFR5cGU6IFR5cGU8VD4pOiB2b2lkIHtcclxuICAgIHRoaXMuZXZlbnRzTWV0YS5zZXQoZXZlbnRUeXBlLCB7XHJcbiAgICAgIGlucHV0U3ViamVjdCQ6IG51bGwsIC8vIHdpbGwgYmUgY3JlYXRlZCBsYXppbHkgYnkgdGhlIGBkaXNwYXRjaGAgbWV0aG9kXHJcbiAgICAgIG1lcmdpbmdTdWJqZWN0OiBuZXcgTWVyZ2luZ1N1YmplY3QoKSxcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIHRoZSBldmVudCB0eXBlIGlzIGEgdmFsaWQgdHlwZSAoaXMgYSBjbGFzcyB3aXRoIGNvbnN0cnVjdG9yKS5cclxuICAgKlxyXG4gICAqIFNob3VsZCBiZSB1c2VkIG9ubHkgaW4gZGV2IG1vZGUuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB2YWxpZGF0ZUV2ZW50VHlwZTxUPihldmVudFR5cGU6IFR5cGU8VD4pOiB2b2lkIHtcclxuICAgIGlmICghZXZlbnRUeXBlPy5jb25zdHJ1Y3Rvcikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYEV2ZW50U2VydmljZTogICR7ZXZlbnRUeXBlfSBpcyBub3QgYSB2YWxpZCBldmVudCB0eXBlLiBQbGVhc2UgcHJvdmlkZSBhIGNsYXNzIHJlZmVyZW5jZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBldmVudCBzb3VyY2Ugd2l0aCBydW50aW1lIHZhbGlkYXRpb24gd2hldGhlciB0aGUgZW1pdHRlZCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiBnaXZlbiBldmVudCB0eXBlLlxyXG4gICAqXHJcbiAgICogU2hvdWxkIGJlIHVzZWQgb25seSBpbiBkZXYgbW9kZS5cclxuICAgKi9cclxuICBwcml2YXRlIGdldFZhbGlkYXRlZEV2ZW50U3RyZWFtPFQ+KFxyXG4gICAgc291cmNlJDogT2JzZXJ2YWJsZTxUPixcclxuICAgIGV2ZW50VHlwZTogVHlwZTxUPlxyXG4gICk6IE9ic2VydmFibGU8VD4ge1xyXG4gICAgcmV0dXJuIHNvdXJjZSQucGlwZShcclxuICAgICAgdGFwKChldmVudCkgPT4ge1xyXG4gICAgICAgIGlmICghKGV2ZW50IGluc3RhbmNlb2YgZXZlbnRUeXBlKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICBgRXZlbnRTZXJ2aWNlOiBUaGUgc3RyZWFtYCxcclxuICAgICAgICAgICAgc291cmNlJCxcclxuICAgICAgICAgICAgYGVtaXR0ZWQgdGhlIGV2ZW50YCxcclxuICAgICAgICAgICAgZXZlbnQsXHJcbiAgICAgICAgICAgIGB0aGF0IGlzIG5vdCBhbiBpbnN0YW5jZSBvZiB0aGUgZGVjbGFyZWQgdHlwZWAsXHJcbiAgICAgICAgICAgIGV2ZW50VHlwZS5uYW1lXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICk7XHJcbiAgfVxyXG59XHJcbiJdfQ==