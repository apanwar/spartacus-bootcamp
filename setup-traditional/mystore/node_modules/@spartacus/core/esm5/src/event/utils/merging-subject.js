import { Observable } from 'rxjs';
import { share } from 'rxjs/operators';
// PRIVATE API
/**
 * Allows for dynamic adding and removing source observables
 * and exposes them as one merged observable at a property `output$`.
 *
 * Thanks to the `share()` operator used inside, it subscribes to source observables
 * only when someone subscribes to it. And it unsubscribes from source observables
 * when the counter of consumers drops to 0.
 *
 * **To avoid memory leaks**, all manually added sources should be manually removed
 * when not plan to emit values anymore. In particular closed event sources won't be
 * automatically removed.
 */
var MergingSubject = /** @class */ (function () {
    function MergingSubject() {
        var _this = this;
        /**
         * List of already added sources (but not removed yet)
         */
        this.sources = [];
        /**
         * For each source: it stores a subscription responsible for
         * passing all values from source to the consumer
         */
        this.subscriptionsToSources = new Map();
        /**
         * Observable with all sources merged.
         *
         * Only after subscribing to it, under the hood it subscribes to the source observables.
         * When the number of subscribers drops to 0, it unsubscribes from all source observables.
         * But if later on something subscribes to it again, it subscribes to the source observables again.
         *
         * It multicasts the emissions for each subscriber.
         */
        this.output$ = new Observable(function (consumer) {
            // There can be only 0 or 1 consumer of this observable coming from the `share()` operator
            // that is piped right after this observable.
            // `share()` not only multicasts the results but also  When all end-subscribers unsubscribe from `share()` operator, it will unsubscribe
            // from this observable (by the nature `refCount`-nature of the `share()` operator).
            _this.consumer = consumer;
            _this.bindAllSourcesToConsumer(consumer);
            return function () {
                _this.consumer = null;
                _this.unbindAllSourcesFromConsumer();
            };
        }).pipe(share());
        /**
         * Reference to the subscriber coming from the `share()` operator piped to the `output$` observable.
         * For more, see docs of the `output$` observable;
         */
        this.consumer = null;
    }
    /**
     * Registers the given source to pass its values to the `output$` observable.
     *
     * It does nothing, when the source has been already added (but not removed yet).
     */
    MergingSubject.prototype.add = function (source) {
        if (this.has(source)) {
            return;
        }
        if (this.consumer) {
            this.bindSourceToConsumer(source, this.consumer);
        }
        this.sources.push(source);
    };
    /**
     * Starts passing all values from already added sources to consumer
     */
    MergingSubject.prototype.bindAllSourcesToConsumer = function (consumer) {
        var _this = this;
        this.sources.forEach(function (source) {
            return _this.bindSourceToConsumer(source, consumer);
        });
    };
    /**
     * Stops passing all values from already added sources to consumer
     * (if any consumer is active at the moment)
     */
    MergingSubject.prototype.unbindAllSourcesFromConsumer = function () {
        var _this = this;
        this.sources.forEach(function (source) { return _this.unbindSourceFromConsumer(source); });
    };
    /**
     * Starts passing all values from a single source to consumer
     */
    MergingSubject.prototype.bindSourceToConsumer = function (source, consumer) {
        var subscriptionToSource = source.subscribe(function (val) { return consumer.next(val); }); // passes all emissions from source to consumer
        this.subscriptionsToSources.set(source, subscriptionToSource);
    };
    /**
     * Stops passing all values from a single source to consumer
     * (if any consumer is active at the moment)
     */
    MergingSubject.prototype.unbindSourceFromConsumer = function (source) {
        var subscriptionToSource = this.subscriptionsToSources.get(source);
        if (subscriptionToSource !== undefined) {
            subscriptionToSource.unsubscribe();
            this.subscriptionsToSources.delete(source);
        }
    };
    /**
     * Unregisters the given source so it stops passing its values to `output$` observable.
     *
     * Should be used when a source is no longer maintained **to avoid memory leaks**.
     */
    MergingSubject.prototype.remove = function (source) {
        // clear binding from source to consumer (if any consumer exists at the moment)
        this.unbindSourceFromConsumer(source);
        // remove source from array
        var i;
        if ((i = this.sources.findIndex(function (s) { return s === source; })) !== -1) {
            this.sources.splice(i, 1);
        }
    };
    /**
     * Returns whether the given source has been already addded
     */
    MergingSubject.prototype.has = function (source) {
        return this.sources.includes(source);
    };
    return MergingSubject;
}());
export { MergingSubject };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVyZ2luZy1zdWJqZWN0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2V2ZW50L3V0aWxzL21lcmdpbmctc3ViamVjdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUE0QixNQUFNLE1BQU0sQ0FBQztBQUM1RCxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFdkMsY0FBYztBQUVkOzs7Ozs7Ozs7OztHQVdHO0FBQ0g7SUFBQTtRQUFBLGlCQXFIQztRQXBIQzs7V0FFRztRQUNLLFlBQU8sR0FBb0IsRUFBRSxDQUFDO1FBRXRDOzs7V0FHRztRQUNLLDJCQUFzQixHQUFHLElBQUksR0FBRyxFQUErQixDQUFDO1FBRXhFOzs7Ozs7OztXQVFHO1FBQ00sWUFBTyxHQUFrQixJQUFJLFVBQVUsQ0FBSSxVQUFDLFFBQVE7WUFDM0QsMEZBQTBGO1lBQzFGLDZDQUE2QztZQUM3Qyx3SUFBd0k7WUFDeEksb0ZBQW9GO1lBRXBGLEtBQUksQ0FBQyxRQUFRLEdBQUcsUUFBUSxDQUFDO1lBQ3pCLEtBQUksQ0FBQyx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUV4QyxPQUFPO2dCQUNMLEtBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO2dCQUNyQixLQUFJLENBQUMsNEJBQTRCLEVBQUUsQ0FBQztZQUN0QyxDQUFDLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUVqQjs7O1dBR0c7UUFDSyxhQUFRLEdBQW9CLElBQUksQ0FBQztJQTZFM0MsQ0FBQztJQTNFQzs7OztPQUlHO0lBQ0gsNEJBQUcsR0FBSCxVQUFJLE1BQXFCO1FBQ3ZCLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNwQixPQUFPO1NBQ1I7UUFFRCxJQUFJLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDbEQ7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQ7O09BRUc7SUFDSyxpREFBd0IsR0FBaEMsVUFBaUMsUUFBdUI7UUFBeEQsaUJBSUM7UUFIQyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxVQUFDLE1BQU07WUFDMUIsT0FBQSxLQUFJLENBQUMsb0JBQW9CLENBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQztRQUEzQyxDQUEyQyxDQUM1QyxDQUFDO0lBQ0osQ0FBQztJQUVEOzs7T0FHRztJQUNLLHFEQUE0QixHQUFwQztRQUFBLGlCQUVDO1FBREMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxNQUFNLElBQUssT0FBQSxLQUFJLENBQUMsd0JBQXdCLENBQUMsTUFBTSxDQUFDLEVBQXJDLENBQXFDLENBQUMsQ0FBQztJQUMxRSxDQUFDO0lBRUQ7O09BRUc7SUFDSyw2Q0FBb0IsR0FBNUIsVUFBNkIsTUFBcUIsRUFBRSxRQUF1QjtRQUN6RSxJQUFNLG9CQUFvQixHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsVUFBQyxHQUFHLElBQUssT0FBQSxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFsQixDQUFrQixDQUFDLENBQUMsQ0FBQywrQ0FBK0M7UUFDM0gsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssaURBQXdCLEdBQWhDLFVBQWlDLE1BQXFCO1FBQ3BELElBQU0sb0JBQW9CLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNyRSxJQUFJLG9CQUFvQixLQUFLLFNBQVMsRUFBRTtZQUN0QyxvQkFBb0IsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNuQyxJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQzVDO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwrQkFBTSxHQUFOLFVBQU8sTUFBcUI7UUFDMUIsK0VBQStFO1FBQy9FLElBQUksQ0FBQyx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUV0QywyQkFBMkI7UUFDM0IsSUFBSSxDQUFTLENBQUM7UUFDZCxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLFVBQUMsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxLQUFLLE1BQU0sRUFBWixDQUFZLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO1lBQzVELElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUMzQjtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNILDRCQUFHLEdBQUgsVUFBSSxNQUFxQjtRQUN2QixPQUFPLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3ZDLENBQUM7SUFDSCxxQkFBQztBQUFELENBQUMsQUFySEQsSUFxSEMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJzY3JpYmVyLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcclxuaW1wb3J0IHsgc2hhcmUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcblxyXG4vLyBQUklWQVRFIEFQSVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBmb3IgZHluYW1pYyBhZGRpbmcgYW5kIHJlbW92aW5nIHNvdXJjZSBvYnNlcnZhYmxlc1xyXG4gKiBhbmQgZXhwb3NlcyB0aGVtIGFzIG9uZSBtZXJnZWQgb2JzZXJ2YWJsZSBhdCBhIHByb3BlcnR5IGBvdXRwdXQkYC5cclxuICpcclxuICogVGhhbmtzIHRvIHRoZSBgc2hhcmUoKWAgb3BlcmF0b3IgdXNlZCBpbnNpZGUsIGl0IHN1YnNjcmliZXMgdG8gc291cmNlIG9ic2VydmFibGVzXHJcbiAqIG9ubHkgd2hlbiBzb21lb25lIHN1YnNjcmliZXMgdG8gaXQuIEFuZCBpdCB1bnN1YnNjcmliZXMgZnJvbSBzb3VyY2Ugb2JzZXJ2YWJsZXNcclxuICogd2hlbiB0aGUgY291bnRlciBvZiBjb25zdW1lcnMgZHJvcHMgdG8gMC5cclxuICpcclxuICogKipUbyBhdm9pZCBtZW1vcnkgbGVha3MqKiwgYWxsIG1hbnVhbGx5IGFkZGVkIHNvdXJjZXMgc2hvdWxkIGJlIG1hbnVhbGx5IHJlbW92ZWRcclxuICogd2hlbiBub3QgcGxhbiB0byBlbWl0IHZhbHVlcyBhbnltb3JlLiBJbiBwYXJ0aWN1bGFyIGNsb3NlZCBldmVudCBzb3VyY2VzIHdvbid0IGJlXHJcbiAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICovXHJcbmV4cG9ydCBjbGFzcyBNZXJnaW5nU3ViamVjdDxUPiB7XHJcbiAgLyoqXHJcbiAgICogTGlzdCBvZiBhbHJlYWR5IGFkZGVkIHNvdXJjZXMgKGJ1dCBub3QgcmVtb3ZlZCB5ZXQpXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzb3VyY2VzOiBPYnNlcnZhYmxlPFQ+W10gPSBbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogRm9yIGVhY2ggc291cmNlOiBpdCBzdG9yZXMgYSBzdWJzY3JpcHRpb24gcmVzcG9uc2libGUgZm9yXHJcbiAgICogcGFzc2luZyBhbGwgdmFsdWVzIGZyb20gc291cmNlIHRvIHRoZSBjb25zdW1lclxyXG4gICAqL1xyXG4gIHByaXZhdGUgc3Vic2NyaXB0aW9uc1RvU291cmNlcyA9IG5ldyBNYXA8T2JzZXJ2YWJsZTxUPiwgU3Vic2NyaXB0aW9uPigpO1xyXG5cclxuICAvKipcclxuICAgKiBPYnNlcnZhYmxlIHdpdGggYWxsIHNvdXJjZXMgbWVyZ2VkLlxyXG4gICAqXHJcbiAgICogT25seSBhZnRlciBzdWJzY3JpYmluZyB0byBpdCwgdW5kZXIgdGhlIGhvb2QgaXQgc3Vic2NyaWJlcyB0byB0aGUgc291cmNlIG9ic2VydmFibGVzLlxyXG4gICAqIFdoZW4gdGhlIG51bWJlciBvZiBzdWJzY3JpYmVycyBkcm9wcyB0byAwLCBpdCB1bnN1YnNjcmliZXMgZnJvbSBhbGwgc291cmNlIG9ic2VydmFibGVzLlxyXG4gICAqIEJ1dCBpZiBsYXRlciBvbiBzb21ldGhpbmcgc3Vic2NyaWJlcyB0byBpdCBhZ2FpbiwgaXQgc3Vic2NyaWJlcyB0byB0aGUgc291cmNlIG9ic2VydmFibGVzIGFnYWluLlxyXG4gICAqXHJcbiAgICogSXQgbXVsdGljYXN0cyB0aGUgZW1pc3Npb25zIGZvciBlYWNoIHN1YnNjcmliZXIuXHJcbiAgICovXHJcbiAgcmVhZG9ubHkgb3V0cHV0JDogT2JzZXJ2YWJsZTxUPiA9IG5ldyBPYnNlcnZhYmxlPFQ+KChjb25zdW1lcikgPT4ge1xyXG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgMCBvciAxIGNvbnN1bWVyIG9mIHRoaXMgb2JzZXJ2YWJsZSBjb21pbmcgZnJvbSB0aGUgYHNoYXJlKClgIG9wZXJhdG9yXHJcbiAgICAvLyB0aGF0IGlzIHBpcGVkIHJpZ2h0IGFmdGVyIHRoaXMgb2JzZXJ2YWJsZS5cclxuICAgIC8vIGBzaGFyZSgpYCBub3Qgb25seSBtdWx0aWNhc3RzIHRoZSByZXN1bHRzIGJ1dCBhbHNvICBXaGVuIGFsbCBlbmQtc3Vic2NyaWJlcnMgdW5zdWJzY3JpYmUgZnJvbSBgc2hhcmUoKWAgb3BlcmF0b3IsIGl0IHdpbGwgdW5zdWJzY3JpYmVcclxuICAgIC8vIGZyb20gdGhpcyBvYnNlcnZhYmxlIChieSB0aGUgbmF0dXJlIGByZWZDb3VudGAtbmF0dXJlIG9mIHRoZSBgc2hhcmUoKWAgb3BlcmF0b3IpLlxyXG5cclxuICAgIHRoaXMuY29uc3VtZXIgPSBjb25zdW1lcjtcclxuICAgIHRoaXMuYmluZEFsbFNvdXJjZXNUb0NvbnN1bWVyKGNvbnN1bWVyKTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICB0aGlzLmNvbnN1bWVyID0gbnVsbDtcclxuICAgICAgdGhpcy51bmJpbmRBbGxTb3VyY2VzRnJvbUNvbnN1bWVyKCk7XHJcbiAgICB9O1xyXG4gIH0pLnBpcGUoc2hhcmUoKSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgc3Vic2NyaWJlciBjb21pbmcgZnJvbSB0aGUgYHNoYXJlKClgIG9wZXJhdG9yIHBpcGVkIHRvIHRoZSBgb3V0cHV0JGAgb2JzZXJ2YWJsZS5cclxuICAgKiBGb3IgbW9yZSwgc2VlIGRvY3Mgb2YgdGhlIGBvdXRwdXQkYCBvYnNlcnZhYmxlO1xyXG4gICAqL1xyXG4gIHByaXZhdGUgY29uc3VtZXI6IFN1YnNjcmliZXI8YW55PiA9IG51bGw7XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gc291cmNlIHRvIHBhc3MgaXRzIHZhbHVlcyB0byB0aGUgYG91dHB1dCRgIG9ic2VydmFibGUuXHJcbiAgICpcclxuICAgKiBJdCBkb2VzIG5vdGhpbmcsIHdoZW4gdGhlIHNvdXJjZSBoYXMgYmVlbiBhbHJlYWR5IGFkZGVkIChidXQgbm90IHJlbW92ZWQgeWV0KS5cclxuICAgKi9cclxuICBhZGQoc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogdm9pZCB7XHJcbiAgICBpZiAodGhpcy5oYXMoc291cmNlKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHRoaXMuY29uc3VtZXIpIHtcclxuICAgICAgdGhpcy5iaW5kU291cmNlVG9Db25zdW1lcihzb3VyY2UsIHRoaXMuY29uc3VtZXIpO1xyXG4gICAgfVxyXG4gICAgdGhpcy5zb3VyY2VzLnB1c2goc291cmNlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0cyBwYXNzaW5nIGFsbCB2YWx1ZXMgZnJvbSBhbHJlYWR5IGFkZGVkIHNvdXJjZXMgdG8gY29uc3VtZXJcclxuICAgKi9cclxuICBwcml2YXRlIGJpbmRBbGxTb3VyY2VzVG9Db25zdW1lcihjb25zdW1lcjogU3Vic2NyaWJlcjxUPikge1xyXG4gICAgdGhpcy5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT5cclxuICAgICAgdGhpcy5iaW5kU291cmNlVG9Db25zdW1lcihzb3VyY2UsIGNvbnN1bWVyKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3BzIHBhc3NpbmcgYWxsIHZhbHVlcyBmcm9tIGFscmVhZHkgYWRkZWQgc291cmNlcyB0byBjb25zdW1lclxyXG4gICAqIChpZiBhbnkgY29uc3VtZXIgaXMgYWN0aXZlIGF0IHRoZSBtb21lbnQpXHJcbiAgICovXHJcbiAgcHJpdmF0ZSB1bmJpbmRBbGxTb3VyY2VzRnJvbUNvbnN1bWVyKCkge1xyXG4gICAgdGhpcy5zb3VyY2VzLmZvckVhY2goKHNvdXJjZSkgPT4gdGhpcy51bmJpbmRTb3VyY2VGcm9tQ29uc3VtZXIoc291cmNlKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydHMgcGFzc2luZyBhbGwgdmFsdWVzIGZyb20gYSBzaW5nbGUgc291cmNlIHRvIGNvbnN1bWVyXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBiaW5kU291cmNlVG9Db25zdW1lcihzb3VyY2U6IE9ic2VydmFibGU8VD4sIGNvbnN1bWVyOiBTdWJzY3JpYmVyPFQ+KSB7XHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb25Ub1NvdXJjZSA9IHNvdXJjZS5zdWJzY3JpYmUoKHZhbCkgPT4gY29uc3VtZXIubmV4dCh2YWwpKTsgLy8gcGFzc2VzIGFsbCBlbWlzc2lvbnMgZnJvbSBzb3VyY2UgdG8gY29uc3VtZXJcclxuICAgIHRoaXMuc3Vic2NyaXB0aW9uc1RvU291cmNlcy5zZXQoc291cmNlLCBzdWJzY3JpcHRpb25Ub1NvdXJjZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wcyBwYXNzaW5nIGFsbCB2YWx1ZXMgZnJvbSBhIHNpbmdsZSBzb3VyY2UgdG8gY29uc3VtZXJcclxuICAgKiAoaWYgYW55IGNvbnN1bWVyIGlzIGFjdGl2ZSBhdCB0aGUgbW9tZW50KVxyXG4gICAqL1xyXG4gIHByaXZhdGUgdW5iaW5kU291cmNlRnJvbUNvbnN1bWVyKHNvdXJjZTogT2JzZXJ2YWJsZTxUPikge1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uVG9Tb3VyY2UgPSB0aGlzLnN1YnNjcmlwdGlvbnNUb1NvdXJjZXMuZ2V0KHNvdXJjZSk7XHJcbiAgICBpZiAoc3Vic2NyaXB0aW9uVG9Tb3VyY2UgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBzdWJzY3JpcHRpb25Ub1NvdXJjZS51bnN1YnNjcmliZSgpO1xyXG4gICAgICB0aGlzLnN1YnNjcmlwdGlvbnNUb1NvdXJjZXMuZGVsZXRlKHNvdXJjZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVbnJlZ2lzdGVycyB0aGUgZ2l2ZW4gc291cmNlIHNvIGl0IHN0b3BzIHBhc3NpbmcgaXRzIHZhbHVlcyB0byBgb3V0cHV0JGAgb2JzZXJ2YWJsZS5cclxuICAgKlxyXG4gICAqIFNob3VsZCBiZSB1c2VkIHdoZW4gYSBzb3VyY2UgaXMgbm8gbG9uZ2VyIG1haW50YWluZWQgKip0byBhdm9pZCBtZW1vcnkgbGVha3MqKi5cclxuICAgKi9cclxuICByZW1vdmUoc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogdm9pZCB7XHJcbiAgICAvLyBjbGVhciBiaW5kaW5nIGZyb20gc291cmNlIHRvIGNvbnN1bWVyIChpZiBhbnkgY29uc3VtZXIgZXhpc3RzIGF0IHRoZSBtb21lbnQpXHJcbiAgICB0aGlzLnVuYmluZFNvdXJjZUZyb21Db25zdW1lcihzb3VyY2UpO1xyXG5cclxuICAgIC8vIHJlbW92ZSBzb3VyY2UgZnJvbSBhcnJheVxyXG4gICAgbGV0IGk6IG51bWJlcjtcclxuICAgIGlmICgoaSA9IHRoaXMuc291cmNlcy5maW5kSW5kZXgoKHMpID0+IHMgPT09IHNvdXJjZSkpICE9PSAtMSkge1xyXG4gICAgICB0aGlzLnNvdXJjZXMuc3BsaWNlKGksIDEpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBzb3VyY2UgaGFzIGJlZW4gYWxyZWFkeSBhZGRkZWRcclxuICAgKi9cclxuICBoYXMoc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzLmluY2x1ZGVzKHNvdXJjZSk7XHJcbiAgfVxyXG59XHJcbiJdfQ==