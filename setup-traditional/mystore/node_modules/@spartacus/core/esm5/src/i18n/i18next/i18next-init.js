import { __assign } from "tslib";
import i18next from 'i18next';
import i18nextXhrBackend from 'i18next-xhr-backend';
export function i18nextInit(configInit, languageService, httpClient, serverRequestOrigin) {
    return function () {
        return configInit.getStableConfig('i18n').then(function (config) {
            var i18nextConfig = {
                ns: [],
                fallbackLng: config.i18n.fallbackLang,
                debug: config.i18n.debug,
                interpolation: {
                    escapeValue: false,
                },
            };
            if (config.i18n.backend) {
                i18next.use(i18nextXhrBackend);
                var loadPath = getLoadPath(config.i18n.backend.loadPath, serverRequestOrigin);
                var backend = {
                    loadPath: loadPath,
                    ajax: i18nextGetHttpClient(httpClient),
                };
                i18nextConfig = __assign(__assign({}, i18nextConfig), { backend: backend });
            }
            return i18next.init(i18nextConfig, function () {
                // Don't use i18next's 'resources' config key for adding static translations,
                // because it will disable loading chunks from backend. We add resources here, in the init's callback.
                i18nextAddTranslations(config.i18n.resources);
                syncI18nextWithSiteContext(languageService);
            });
        });
    };
}
export function i18nextAddTranslations(resources) {
    if (resources === void 0) { resources = {}; }
    Object.keys(resources).forEach(function (lang) {
        Object.keys(resources[lang]).forEach(function (chunkName) {
            i18next.addResourceBundle(lang, chunkName, resources[lang][chunkName], true, true);
        });
    });
}
export function syncI18nextWithSiteContext(language) {
    // always update language of i18next on site context (language) change
    language.getActive().subscribe(function (lang) { return i18next.changeLanguage(lang); });
}
/**
 * Returns a function appropriate for i18next to make http calls for JSON files.
 * See docs for `i18next-xhr-backend`: https://github.com/i18next/i18next-xhr-backend#backend-options
 *
 * It uses Angular HttpClient under the hood, so it works in SSR.
 * @param httpClient Angular http client
 */
export function i18nextGetHttpClient(httpClient) {
    return function (url, _options, callback, _data) {
        httpClient.get(url, { responseType: 'text' }).subscribe(function (data) { return callback(data, { status: 200 }); }, function (error) { return callback(null, { status: error.status }); });
    };
}
/**
 * Resolves the relative path to the absolute one in SSR, using the server request's origin.
 * It's needed, because Angular Universal doesn't support relative URLs in HttpClient. See Angular issues:
 * - https://github.com/angular/angular/issues/19224
 * - https://github.com/angular/universal/issues/858
 */
export function getLoadPath(path, serverRequestOrigin) {
    if (!path) {
        return undefined;
    }
    if (serverRequestOrigin && !path.match(/^http(s)?:\/\//)) {
        if (path.startsWith('/')) {
            path = path.slice(1);
        }
        if (path.startsWith('./')) {
            path = path.slice(2);
        }
        var result = serverRequestOrigin + "/" + path;
        return result;
    }
    return path;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaTE4bmV4dC1pbml0LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL2kxOG4vaTE4bmV4dC9pMThuZXh0LWluaXQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUNBLE9BQU8sT0FBd0IsTUFBTSxTQUFTLENBQUM7QUFDL0MsT0FBTyxpQkFBaUIsTUFBTSxxQkFBcUIsQ0FBQztBQUtwRCxNQUFNLFVBQVUsV0FBVyxDQUN6QixVQUFvQyxFQUNwQyxlQUFnQyxFQUNoQyxVQUFzQixFQUN0QixtQkFBMkI7SUFFM0IsT0FBTztRQUNMLE9BQUEsVUFBVSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBQyxNQUFNO1lBQzdDLElBQUksYUFBYSxHQUFnQjtnQkFDL0IsRUFBRSxFQUFFLEVBQUU7Z0JBQ04sV0FBVyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWTtnQkFDckMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSztnQkFDeEIsYUFBYSxFQUFFO29CQUNiLFdBQVcsRUFBRSxLQUFLO2lCQUNuQjthQUNGLENBQUM7WUFDRixJQUFJLE1BQU0sQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO2dCQUN2QixPQUFPLENBQUMsR0FBRyxDQUFDLGlCQUFpQixDQUFDLENBQUM7Z0JBQy9CLElBQU0sUUFBUSxHQUFHLFdBQVcsQ0FDMUIsTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxFQUM1QixtQkFBbUIsQ0FDcEIsQ0FBQztnQkFDRixJQUFNLE9BQU8sR0FBRztvQkFDZCxRQUFRLFVBQUE7b0JBQ1IsSUFBSSxFQUFFLG9CQUFvQixDQUFDLFVBQVUsQ0FBQztpQkFDdkMsQ0FBQztnQkFDRixhQUFhLHlCQUFRLGFBQWEsS0FBRSxPQUFPLFNBQUEsR0FBRSxDQUFDO2FBQy9DO1lBRUQsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtnQkFDakMsNkVBQTZFO2dCQUM3RSxzR0FBc0c7Z0JBQ3RHLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQzlDLDBCQUEwQixDQUFDLGVBQWUsQ0FBQyxDQUFDO1lBQzlDLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDO0lBNUJGLENBNEJFLENBQUM7QUFDUCxDQUFDO0FBRUQsTUFBTSxVQUFVLHNCQUFzQixDQUFDLFNBQW9DO0lBQXBDLDBCQUFBLEVBQUEsY0FBb0M7SUFDekUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxJQUFJO1FBQ2xDLE1BQU0sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQUMsU0FBUztZQUM3QyxPQUFPLENBQUMsaUJBQWlCLENBQ3ZCLElBQUksRUFDSixTQUFTLEVBQ1QsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLFNBQVMsQ0FBQyxFQUMxQixJQUFJLEVBQ0osSUFBSSxDQUNMLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVELE1BQU0sVUFBVSwwQkFBMEIsQ0FBQyxRQUF5QjtJQUNsRSxzRUFBc0U7SUFDdEUsUUFBUSxDQUFDLFNBQVMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxVQUFDLElBQUksSUFBSyxPQUFBLE9BQU8sQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLEVBQTVCLENBQTRCLENBQUMsQ0FBQztBQUN6RSxDQUFDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLG9CQUFvQixDQUNsQyxVQUFzQjtJQUV0QixPQUFPLFVBQUMsR0FBVyxFQUFFLFFBQWdCLEVBQUUsUUFBa0IsRUFBRSxLQUFhO1FBQ3RFLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsU0FBUyxDQUNyRCxVQUFDLElBQUksSUFBSyxPQUFBLFFBQVEsQ0FBQyxJQUFJLEVBQUUsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBL0IsQ0FBK0IsRUFDekMsVUFBQyxLQUFLLElBQUssT0FBQSxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUF4QyxDQUF3QyxDQUNwRCxDQUFDO0lBQ0osQ0FBQyxDQUFDO0FBQ0osQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLFdBQVcsQ0FBQyxJQUFZLEVBQUUsbUJBQTJCO0lBQ25FLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDVCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtJQUNELElBQUksbUJBQW1CLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLEVBQUU7UUFDeEQsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1lBQ3hCLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RCO1FBQ0QsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ3pCLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3RCO1FBQ0QsSUFBTSxNQUFNLEdBQU0sbUJBQW1CLFNBQUksSUFBTSxDQUFDO1FBQ2hELE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFDRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwQ2xpZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xyXG5pbXBvcnQgaTE4bmV4dCwgeyBJbml0T3B0aW9ucyB9IGZyb20gJ2kxOG5leHQnO1xyXG5pbXBvcnQgaTE4bmV4dFhockJhY2tlbmQgZnJvbSAnaTE4bmV4dC14aHItYmFja2VuZCc7XHJcbmltcG9ydCB7IENvbmZpZ0luaXRpYWxpemVyU2VydmljZSB9IGZyb20gJy4uLy4uL2NvbmZpZy9jb25maWctaW5pdGlhbGl6ZXIvY29uZmlnLWluaXRpYWxpemVyLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBMYW5ndWFnZVNlcnZpY2UgfSBmcm9tICcuLi8uLi9zaXRlLWNvbnRleHQvZmFjYWRlL2xhbmd1YWdlLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBUcmFuc2xhdGlvblJlc291cmNlcyB9IGZyb20gJy4uL3RyYW5zbGF0aW9uLXJlc291cmNlcyc7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaTE4bmV4dEluaXQoXHJcbiAgY29uZmlnSW5pdDogQ29uZmlnSW5pdGlhbGl6ZXJTZXJ2aWNlLFxyXG4gIGxhbmd1YWdlU2VydmljZTogTGFuZ3VhZ2VTZXJ2aWNlLFxyXG4gIGh0dHBDbGllbnQ6IEh0dHBDbGllbnQsXHJcbiAgc2VydmVyUmVxdWVzdE9yaWdpbjogc3RyaW5nXHJcbik6ICgpID0+IFByb21pc2U8YW55PiB7XHJcbiAgcmV0dXJuICgpID0+XHJcbiAgICBjb25maWdJbml0LmdldFN0YWJsZUNvbmZpZygnaTE4bicpLnRoZW4oKGNvbmZpZykgPT4ge1xyXG4gICAgICBsZXQgaTE4bmV4dENvbmZpZzogSW5pdE9wdGlvbnMgPSB7XHJcbiAgICAgICAgbnM6IFtdLCAvLyBkb24ndCBwcmVsb2FkIGFueSBuYW1lc3BhY2VzXHJcbiAgICAgICAgZmFsbGJhY2tMbmc6IGNvbmZpZy5pMThuLmZhbGxiYWNrTGFuZyxcclxuICAgICAgICBkZWJ1ZzogY29uZmlnLmkxOG4uZGVidWcsXHJcbiAgICAgICAgaW50ZXJwb2xhdGlvbjoge1xyXG4gICAgICAgICAgZXNjYXBlVmFsdWU6IGZhbHNlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH07XHJcbiAgICAgIGlmIChjb25maWcuaTE4bi5iYWNrZW5kKSB7XHJcbiAgICAgICAgaTE4bmV4dC51c2UoaTE4bmV4dFhockJhY2tlbmQpO1xyXG4gICAgICAgIGNvbnN0IGxvYWRQYXRoID0gZ2V0TG9hZFBhdGgoXHJcbiAgICAgICAgICBjb25maWcuaTE4bi5iYWNrZW5kLmxvYWRQYXRoLFxyXG4gICAgICAgICAgc2VydmVyUmVxdWVzdE9yaWdpblxyXG4gICAgICAgICk7XHJcbiAgICAgICAgY29uc3QgYmFja2VuZCA9IHtcclxuICAgICAgICAgIGxvYWRQYXRoLFxyXG4gICAgICAgICAgYWpheDogaTE4bmV4dEdldEh0dHBDbGllbnQoaHR0cENsaWVudCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICBpMThuZXh0Q29uZmlnID0geyAuLi5pMThuZXh0Q29uZmlnLCBiYWNrZW5kIH07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBpMThuZXh0LmluaXQoaTE4bmV4dENvbmZpZywgKCkgPT4ge1xyXG4gICAgICAgIC8vIERvbid0IHVzZSBpMThuZXh0J3MgJ3Jlc291cmNlcycgY29uZmlnIGtleSBmb3IgYWRkaW5nIHN0YXRpYyB0cmFuc2xhdGlvbnMsXHJcbiAgICAgICAgLy8gYmVjYXVzZSBpdCB3aWxsIGRpc2FibGUgbG9hZGluZyBjaHVua3MgZnJvbSBiYWNrZW5kLiBXZSBhZGQgcmVzb3VyY2VzIGhlcmUsIGluIHRoZSBpbml0J3MgY2FsbGJhY2suXHJcbiAgICAgICAgaTE4bmV4dEFkZFRyYW5zbGF0aW9ucyhjb25maWcuaTE4bi5yZXNvdXJjZXMpO1xyXG4gICAgICAgIHN5bmNJMThuZXh0V2l0aFNpdGVDb250ZXh0KGxhbmd1YWdlU2VydmljZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpMThuZXh0QWRkVHJhbnNsYXRpb25zKHJlc291cmNlczogVHJhbnNsYXRpb25SZXNvdXJjZXMgPSB7fSkge1xyXG4gIE9iamVjdC5rZXlzKHJlc291cmNlcykuZm9yRWFjaCgobGFuZykgPT4ge1xyXG4gICAgT2JqZWN0LmtleXMocmVzb3VyY2VzW2xhbmddKS5mb3JFYWNoKChjaHVua05hbWUpID0+IHtcclxuICAgICAgaTE4bmV4dC5hZGRSZXNvdXJjZUJ1bmRsZShcclxuICAgICAgICBsYW5nLFxyXG4gICAgICAgIGNodW5rTmFtZSxcclxuICAgICAgICByZXNvdXJjZXNbbGFuZ11bY2h1bmtOYW1lXSxcclxuICAgICAgICB0cnVlLFxyXG4gICAgICAgIHRydWVcclxuICAgICAgKTtcclxuICAgIH0pO1xyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc3luY0kxOG5leHRXaXRoU2l0ZUNvbnRleHQobGFuZ3VhZ2U6IExhbmd1YWdlU2VydmljZSkge1xyXG4gIC8vIGFsd2F5cyB1cGRhdGUgbGFuZ3VhZ2Ugb2YgaTE4bmV4dCBvbiBzaXRlIGNvbnRleHQgKGxhbmd1YWdlKSBjaGFuZ2VcclxuICBsYW5ndWFnZS5nZXRBY3RpdmUoKS5zdWJzY3JpYmUoKGxhbmcpID0+IGkxOG5leHQuY2hhbmdlTGFuZ3VhZ2UobGFuZykpO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGFwcHJvcHJpYXRlIGZvciBpMThuZXh0IHRvIG1ha2UgaHR0cCBjYWxscyBmb3IgSlNPTiBmaWxlcy5cclxuICogU2VlIGRvY3MgZm9yIGBpMThuZXh0LXhoci1iYWNrZW5kYDogaHR0cHM6Ly9naXRodWIuY29tL2kxOG5leHQvaTE4bmV4dC14aHItYmFja2VuZCNiYWNrZW5kLW9wdGlvbnNcclxuICpcclxuICogSXQgdXNlcyBBbmd1bGFyIEh0dHBDbGllbnQgdW5kZXIgdGhlIGhvb2QsIHNvIGl0IHdvcmtzIGluIFNTUi5cclxuICogQHBhcmFtIGh0dHBDbGllbnQgQW5ndWxhciBodHRwIGNsaWVudFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGkxOG5leHRHZXRIdHRwQ2xpZW50KFxyXG4gIGh0dHBDbGllbnQ6IEh0dHBDbGllbnRcclxuKTogKHVybDogc3RyaW5nLCBvcHRpb25zOiBvYmplY3QsIGNhbGxiYWNrOiBGdW5jdGlvbiwgZGF0YTogb2JqZWN0KSA9PiB2b2lkIHtcclxuICByZXR1cm4gKHVybDogc3RyaW5nLCBfb3B0aW9uczogb2JqZWN0LCBjYWxsYmFjazogRnVuY3Rpb24sIF9kYXRhOiBvYmplY3QpID0+IHtcclxuICAgIGh0dHBDbGllbnQuZ2V0KHVybCwgeyByZXNwb25zZVR5cGU6ICd0ZXh0JyB9KS5zdWJzY3JpYmUoXHJcbiAgICAgIChkYXRhKSA9PiBjYWxsYmFjayhkYXRhLCB7IHN0YXR1czogMjAwIH0pLFxyXG4gICAgICAoZXJyb3IpID0+IGNhbGxiYWNrKG51bGwsIHsgc3RhdHVzOiBlcnJvci5zdGF0dXMgfSlcclxuICAgICk7XHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJlc29sdmVzIHRoZSByZWxhdGl2ZSBwYXRoIHRvIHRoZSBhYnNvbHV0ZSBvbmUgaW4gU1NSLCB1c2luZyB0aGUgc2VydmVyIHJlcXVlc3QncyBvcmlnaW4uXHJcbiAqIEl0J3MgbmVlZGVkLCBiZWNhdXNlIEFuZ3VsYXIgVW5pdmVyc2FsIGRvZXNuJ3Qgc3VwcG9ydCByZWxhdGl2ZSBVUkxzIGluIEh0dHBDbGllbnQuIFNlZSBBbmd1bGFyIGlzc3VlczpcclxuICogLSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xOTIyNFxyXG4gKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3VuaXZlcnNhbC9pc3N1ZXMvODU4XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9hZFBhdGgocGF0aDogc3RyaW5nLCBzZXJ2ZXJSZXF1ZXN0T3JpZ2luOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGlmICghcGF0aCkge1xyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICB9XHJcbiAgaWYgKHNlcnZlclJlcXVlc3RPcmlnaW4gJiYgIXBhdGgubWF0Y2goL15odHRwKHMpPzpcXC9cXC8vKSkge1xyXG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICAgIHBhdGggPSBwYXRoLnNsaWNlKDEpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLi8nKSkge1xyXG4gICAgICBwYXRoID0gcGF0aC5zbGljZSgyKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJlc3VsdCA9IGAke3NlcnZlclJlcXVlc3RPcmlnaW59LyR7cGF0aH1gO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbiAgcmV0dXJuIHBhdGg7XHJcbn1cclxuIl19