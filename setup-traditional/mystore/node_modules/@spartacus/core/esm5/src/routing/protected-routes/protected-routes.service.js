import { __decorate } from "tslib";
import { Injectable } from '@angular/core';
import { RoutingConfig } from '../configurable-routes/config/routing-config';
import * as i0 from "@angular/core";
import * as i1 from "../configurable-routes/config/routing-config";
var ProtectedRoutesService = /** @class */ (function () {
    function ProtectedRoutesService(config) {
        var _this = this;
        this.config = config;
        this.nonProtectedPaths = []; // arrays of paths' segments list
        if (this.shouldProtect) {
            // pre-process config for performance:
            this.nonProtectedPaths = this.getNonProtectedPaths().map(function (path) {
                return _this.getSegments(path);
            });
        }
    }
    Object.defineProperty(ProtectedRoutesService.prototype, "routingConfig", {
        get: function () {
            return this.config && this.config.routing;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProtectedRoutesService.prototype, "shouldProtect", {
        /**
         * Returns 'protected' property (boolean) from routing config
         *
         * @returns boolean
         */
        get: function () {
            return this.routingConfig.protected;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Tells if the url is protected
     */
    ProtectedRoutesService.prototype.isUrlProtected = function (urlSegments) {
        return (this.shouldProtect &&
            !this.matchAnyPath(urlSegments, this.nonProtectedPaths));
    };
    /**
     * Tells whether the url matches at least one of the paths
     */
    ProtectedRoutesService.prototype.matchAnyPath = function (urlSegments, pathsSegments) {
        var _this = this;
        return pathsSegments.some(function (pathSegments) {
            return _this.matchPath(urlSegments, pathSegments);
        });
    };
    /**
     * Tells whether the url matches the path
     */
    ProtectedRoutesService.prototype.matchPath = function (urlSegments, pathSegments) {
        if (urlSegments.length !== pathSegments.length) {
            return false;
        }
        for (var i = 0; i < pathSegments.length; i++) {
            var pathSeg = pathSegments[i];
            var urlSeg = urlSegments[i];
            // compare only static segments:
            if (!pathSeg.startsWith(':') && pathSeg !== urlSeg) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns a list of paths that are not protected
     */
    ProtectedRoutesService.prototype.getNonProtectedPaths = function () {
        return Object.values(this.routingConfig.routes).reduce(function (acc, routeConfig) {
            return routeConfig.protected === false && // must be explicitly false, ignore undefined
                routeConfig.paths &&
                routeConfig.paths.length
                ? acc.concat(routeConfig.paths)
                : acc;
        }, []);
    };
    /**
     * Splits the url by slashes
     */
    ProtectedRoutesService.prototype.getSegments = function (url) {
        return (url || '').split('/');
    };
    ProtectedRoutesService.ctorParameters = function () { return [
        { type: RoutingConfig }
    ]; };
    ProtectedRoutesService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProtectedRoutesService_Factory() { return new ProtectedRoutesService(i0.ɵɵinject(i1.RoutingConfig)); }, token: ProtectedRoutesService, providedIn: "root" });
    ProtectedRoutesService = __decorate([
        Injectable({ providedIn: 'root' })
    ], ProtectedRoutesService);
    return ProtectedRoutesService;
}());
export { ProtectedRoutesService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvdGVjdGVkLXJvdXRlcy5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL3JvdXRpbmcvcHJvdGVjdGVkLXJvdXRlcy9wcm90ZWN0ZWQtcm91dGVzLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLDhDQUE4QyxDQUFDOzs7QUFHN0U7SUFnQkUsZ0NBQXNCLE1BQXFCO1FBQTNDLGlCQU9DO1FBUHFCLFdBQU0sR0FBTixNQUFNLENBQWU7UUFmbkMsc0JBQWlCLEdBQWUsRUFBRSxDQUFDLENBQUMsaUNBQWlDO1FBZ0IzRSxJQUFJLElBQUksQ0FBQyxhQUFhLEVBQUU7WUFDdEIsc0NBQXNDO1lBQ3RDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxHQUFHLENBQUMsVUFBQyxJQUFJO2dCQUM1RCxPQUFBLEtBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDO1lBQXRCLENBQXNCLENBQ3ZCLENBQUM7U0FDSDtJQUNILENBQUM7SUFwQkQsc0JBQWMsaURBQWE7YUFBM0I7WUFDRSxPQUFPLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUM7UUFDNUMsQ0FBQzs7O09BQUE7SUFPRCxzQkFBVyxpREFBYTtRQUx4Qjs7OztXQUlHO2FBQ0g7WUFDRSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDO1FBQ3RDLENBQUM7OztPQUFBO0lBV0Q7O09BRUc7SUFDSCwrQ0FBYyxHQUFkLFVBQWUsV0FBcUI7UUFDbEMsT0FBTyxDQUNMLElBQUksQ0FBQyxhQUFhO1lBQ2xCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQ3hELENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDTyw2Q0FBWSxHQUF0QixVQUNFLFdBQXFCLEVBQ3JCLGFBQXlCO1FBRjNCLGlCQU9DO1FBSEMsT0FBTyxhQUFhLENBQUMsSUFBSSxDQUFDLFVBQUMsWUFBWTtZQUNyQyxPQUFBLEtBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLFlBQVksQ0FBQztRQUF6QyxDQUF5QyxDQUMxQyxDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ08sMENBQVMsR0FBbkIsVUFBb0IsV0FBcUIsRUFBRSxZQUFzQjtRQUMvRCxJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssWUFBWSxDQUFDLE1BQU0sRUFBRTtZQUM5QyxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDNUMsSUFBTSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2hDLElBQU0sTUFBTSxHQUFHLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUU5QixnQ0FBZ0M7WUFDaEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtnQkFDbEQsT0FBTyxLQUFLLENBQUM7YUFDZDtTQUNGO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7O09BRUc7SUFDTyxxREFBb0IsR0FBOUI7UUFDRSxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxNQUFNLENBQ3BELFVBQUMsR0FBRyxFQUFFLFdBQVc7WUFDZixPQUFBLFdBQVcsQ0FBQyxTQUFTLEtBQUssS0FBSyxJQUFJLDZDQUE2QztnQkFDaEYsV0FBVyxDQUFDLEtBQUs7Z0JBQ2pCLFdBQVcsQ0FBQyxLQUFLLENBQUMsTUFBTTtnQkFDdEIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztnQkFDL0IsQ0FBQyxDQUFDLEdBQUc7UUFKUCxDQUlPLEVBQ1QsRUFBRSxDQUNILENBQUM7SUFDSixDQUFDO0lBRUQ7O09BRUc7SUFDTyw0Q0FBVyxHQUFyQixVQUFzQixHQUFXO1FBQy9CLE9BQU8sQ0FBQyxHQUFHLElBQUksRUFBRSxDQUFDLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ2hDLENBQUM7O2dCQXZFNkIsYUFBYTs7O0lBaEJoQyxzQkFBc0I7UUFEbEMsVUFBVSxDQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxDQUFDO09BQ3RCLHNCQUFzQixDQXdGbEM7aUNBNUZEO0NBNEZDLEFBeEZELElBd0ZDO1NBeEZZLHNCQUFzQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUm91dGluZ0NvbmZpZyB9IGZyb20gJy4uL2NvbmZpZ3VyYWJsZS1yb3V0ZXMvY29uZmlnL3JvdXRpbmctY29uZmlnJztcclxuXHJcbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXHJcbmV4cG9ydCBjbGFzcyBQcm90ZWN0ZWRSb3V0ZXNTZXJ2aWNlIHtcclxuICBwcml2YXRlIG5vblByb3RlY3RlZFBhdGhzOiBzdHJpbmdbXVtdID0gW107IC8vIGFycmF5cyBvZiBwYXRocycgc2VnbWVudHMgbGlzdFxyXG5cclxuICBwcm90ZWN0ZWQgZ2V0IHJvdXRpbmdDb25maWcoKTogUm91dGluZ0NvbmZpZ1sncm91dGluZyddIHtcclxuICAgIHJldHVybiB0aGlzLmNvbmZpZyAmJiB0aGlzLmNvbmZpZy5yb3V0aW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyAncHJvdGVjdGVkJyBwcm9wZXJ0eSAoYm9vbGVhbikgZnJvbSByb3V0aW5nIGNvbmZpZ1xyXG4gICAqXHJcbiAgICogQHJldHVybnMgYm9vbGVhblxyXG4gICAqL1xyXG4gIHB1YmxpYyBnZXQgc2hvdWxkUHJvdGVjdCgpOiBib29sZWFuIHtcclxuICAgIHJldHVybiB0aGlzLnJvdXRpbmdDb25maWcucHJvdGVjdGVkO1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIGNvbmZpZzogUm91dGluZ0NvbmZpZykge1xyXG4gICAgaWYgKHRoaXMuc2hvdWxkUHJvdGVjdCkge1xyXG4gICAgICAvLyBwcmUtcHJvY2VzcyBjb25maWcgZm9yIHBlcmZvcm1hbmNlOlxyXG4gICAgICB0aGlzLm5vblByb3RlY3RlZFBhdGhzID0gdGhpcy5nZXROb25Qcm90ZWN0ZWRQYXRocygpLm1hcCgocGF0aCkgPT5cclxuICAgICAgICB0aGlzLmdldFNlZ21lbnRzKHBhdGgpXHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZWxscyBpZiB0aGUgdXJsIGlzIHByb3RlY3RlZFxyXG4gICAqL1xyXG4gIGlzVXJsUHJvdGVjdGVkKHVybFNlZ21lbnRzOiBzdHJpbmdbXSk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5zaG91bGRQcm90ZWN0ICYmXHJcbiAgICAgICF0aGlzLm1hdGNoQW55UGF0aCh1cmxTZWdtZW50cywgdGhpcy5ub25Qcm90ZWN0ZWRQYXRocylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZWxscyB3aGV0aGVyIHRoZSB1cmwgbWF0Y2hlcyBhdCBsZWFzdCBvbmUgb2YgdGhlIHBhdGhzXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIG1hdGNoQW55UGF0aChcclxuICAgIHVybFNlZ21lbnRzOiBzdHJpbmdbXSxcclxuICAgIHBhdGhzU2VnbWVudHM6IHN0cmluZ1tdW11cclxuICApOiBib29sZWFuIHtcclxuICAgIHJldHVybiBwYXRoc1NlZ21lbnRzLnNvbWUoKHBhdGhTZWdtZW50cykgPT5cclxuICAgICAgdGhpcy5tYXRjaFBhdGgodXJsU2VnbWVudHMsIHBhdGhTZWdtZW50cylcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZWxscyB3aGV0aGVyIHRoZSB1cmwgbWF0Y2hlcyB0aGUgcGF0aFxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBtYXRjaFBhdGgodXJsU2VnbWVudHM6IHN0cmluZ1tdLCBwYXRoU2VnbWVudHM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XHJcbiAgICBpZiAodXJsU2VnbWVudHMubGVuZ3RoICE9PSBwYXRoU2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhTZWdtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBwYXRoU2VnID0gcGF0aFNlZ21lbnRzW2ldO1xyXG4gICAgICBjb25zdCB1cmxTZWcgPSB1cmxTZWdtZW50c1tpXTtcclxuXHJcbiAgICAgIC8vIGNvbXBhcmUgb25seSBzdGF0aWMgc2VnbWVudHM6XHJcbiAgICAgIGlmICghcGF0aFNlZy5zdGFydHNXaXRoKCc6JykgJiYgcGF0aFNlZyAhPT0gdXJsU2VnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIHBhdGhzIHRoYXQgYXJlIG5vdCBwcm90ZWN0ZWRcclxuICAgKi9cclxuICBwcm90ZWN0ZWQgZ2V0Tm9uUHJvdGVjdGVkUGF0aHMoKTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5yb3V0aW5nQ29uZmlnLnJvdXRlcykucmVkdWNlKFxyXG4gICAgICAoYWNjLCByb3V0ZUNvbmZpZykgPT5cclxuICAgICAgICByb3V0ZUNvbmZpZy5wcm90ZWN0ZWQgPT09IGZhbHNlICYmIC8vIG11c3QgYmUgZXhwbGljaXRseSBmYWxzZSwgaWdub3JlIHVuZGVmaW5lZFxyXG4gICAgICAgIHJvdXRlQ29uZmlnLnBhdGhzICYmXHJcbiAgICAgICAgcm91dGVDb25maWcucGF0aHMubGVuZ3RoXHJcbiAgICAgICAgICA/IGFjYy5jb25jYXQocm91dGVDb25maWcucGF0aHMpXHJcbiAgICAgICAgICA6IGFjYyxcclxuICAgICAgW11cclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTcGxpdHMgdGhlIHVybCBieSBzbGFzaGVzXHJcbiAgICovXHJcbiAgcHJvdGVjdGVkIGdldFNlZ21lbnRzKHVybDogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuICh1cmwgfHwgJycpLnNwbGl0KCcvJyk7XHJcbiAgfVxyXG59XHJcbiJdfQ==