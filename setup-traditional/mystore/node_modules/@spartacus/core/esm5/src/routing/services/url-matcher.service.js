import { __decorate } from "tslib";
import { Injectable, isDevMode } from '@angular/core';
import { GlobService } from '../../util/glob.service';
import * as i0 from "@angular/core";
import * as i1 from "../../util/glob.service";
var UrlMatcherService = /** @class */ (function () {
    function UrlMatcherService(globService) {
        this.globService = globService;
    }
    /**
     * Returns a matcher that is always fails
     */
    UrlMatcherService.prototype.getFalsy = function () {
        return function falsyUrlMatcher() {
            return null;
        };
    };
    /**
     * Returns a matcher for given list of paths
     */
    UrlMatcherService.prototype.getFromPaths = function (paths) {
        var _this = this;
        var matchers = paths.map(function (path) { return _this.getFromPath(path); });
        var matcher = this.getCombined(matchers);
        if (isDevMode()) {
            matcher['_paths'] = paths; // property added for easier debugging of routes
        }
        return matcher;
    };
    /**
     * Returns a matcher that combines the given matchers
     * */
    UrlMatcherService.prototype.getCombined = function (matchers) {
        var matcher = function combinedUrlMatchers(segments, segmentGroup, route) {
            for (var i = 0; i < matchers.length; i++) {
                var result = matchers[i](segments, segmentGroup, route);
                if (result) {
                    return result;
                }
            }
            return null;
        };
        if (isDevMode()) {
            matcher['_matchers'] = matchers; // property added for easier debugging of routes
        }
        return matcher;
    };
    /**
     * Similar to Angular's defaultUrlMatcher. Differences:
     * - the `path` comes from function's argument, not from `route.path`
     * - the empty path `''` is handled here, but in Angular is handled one level higher in the match() function
     */
    UrlMatcherService.prototype.getFromPath = function (path) {
        if (path === void 0) { path = ''; }
        var matcher = function pathUrlMatcher(segments, segmentGroup, route) {
            /**
             * @license
             * The MIT License
             * Copyright (c) 2010-2019 Google LLC. http://angular.io/license
             *
             * See:
             * - https://github.com/angular/angular/blob/6f5f481fdae03f1d8db36284b64c7b82d9519d85/packages/router/src/shared.ts#L121
             */
            // use function's argument, not the `route.path`
            if (path === '') {
                if (route.pathMatch === 'full' &&
                    (segmentGroup.hasChildren() || segments.length > 0)) {
                    return null;
                }
                return { consumed: [], posParams: {} };
            }
            var parts = path.split('/'); // use function's argument, not the `route.path`
            if (parts.length > segments.length) {
                // The actual URL is shorter than the config, no match
                return null;
            }
            if (route.pathMatch === 'full' &&
                (segmentGroup.hasChildren() || parts.length < segments.length)) {
                // The config is longer than the actual URL but we are looking for a full match, return null
                return null;
            }
            var posParams = {};
            // Check each config part against the actual URL
            for (var index = 0; index < parts.length; index++) {
                var part = parts[index];
                var segment = segments[index];
                var isParameter = part.startsWith(':');
                if (isParameter) {
                    posParams[part.substring(1)] = segment;
                }
                else if (part !== segment.path) {
                    // The actual URL part does not match the config, no match
                    return null;
                }
            }
            return { consumed: segments.slice(0, parts.length), posParams: posParams };
        };
        if (isDevMode()) {
            matcher['_path'] = path; // property added for easier debugging of routes
        }
        return matcher;
    };
    /**
     * Returns URL matcher that accepts almost everything (like `**` route), but not paths accepted by the given matcher
     */
    UrlMatcherService.prototype.getOpposite = function (originalMatcher) {
        var matcher = function oppositeUrlMatcher(segments, group, route) {
            return originalMatcher(segments, group, route)
                ? null
                : { consumed: segments, posParams: {} };
        };
        if (isDevMode()) {
            matcher['_originalMatcher'] = originalMatcher; // property added for easier debugging of routes
        }
        return matcher;
    };
    /**
     * Returns URL matcher for the given list of glob-like patterns. Each pattern must start with `/` or `!/`.
     */
    UrlMatcherService.prototype.getFromGlob = function (globPatterns) {
        var globValidator = this.globService.getValidator(globPatterns);
        var matcher = function globUrlMatcher(segments) {
            var fullPath = "/" + segments.map(function (s) { return s.path; }).join('/');
            return globValidator(fullPath)
                ? { consumed: segments, posParams: {} }
                : null;
        };
        if (isDevMode()) {
            matcher['_globPatterns'] = globPatterns; // property added for easier debugging of routes
        }
        return matcher;
    };
    UrlMatcherService.ctorParameters = function () { return [
        { type: GlobService }
    ]; };
    UrlMatcherService.ɵprov = i0.ɵɵdefineInjectable({ factory: function UrlMatcherService_Factory() { return new UrlMatcherService(i0.ɵɵinject(i1.GlobService)); }, token: UrlMatcherService, providedIn: "root" });
    UrlMatcherService = __decorate([
        Injectable({ providedIn: 'root' })
    ], UrlMatcherService);
    return UrlMatcherService;
}());
export { UrlMatcherService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXJsLW1hdGNoZXIuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BzcGFydGFjdXMvY29yZS8iLCJzb3VyY2VzIjpbInNyYy9yb3V0aW5nL3NlcnZpY2VzL3VybC1tYXRjaGVyLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBUXRELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQzs7O0FBR3REO0lBQ0UsMkJBQXNCLFdBQXdCO1FBQXhCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO0lBQUcsQ0FBQztJQUVsRDs7T0FFRztJQUNILG9DQUFRLEdBQVI7UUFDRSxPQUFPLFNBQVMsZUFBZTtZQUM3QixPQUFPLElBQUksQ0FBQztRQUNkLENBQUMsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILHdDQUFZLEdBQVosVUFBYSxLQUFlO1FBQTVCLGlCQU9DO1FBTkMsSUFBTSxRQUFRLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFDLElBQUksSUFBSyxPQUFBLEtBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQXRCLENBQXNCLENBQUMsQ0FBQztRQUM3RCxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzNDLElBQUksU0FBUyxFQUFFLEVBQUU7WUFDZixPQUFPLENBQUMsUUFBUSxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsZ0RBQWdEO1NBQzVFO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUVEOztTQUVLO0lBQ0wsdUNBQVcsR0FBWCxVQUFZLFFBQXNCO1FBQ2hDLElBQU0sT0FBTyxHQUFHLFNBQVMsbUJBQW1CLENBQzFDLFFBQXNCLEVBQ3RCLFlBQTZCLEVBQzdCLEtBQVk7WUFFWixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFB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QixDQTJKN0I7NEJBdEtEO0NBc0tDLEFBM0pELElBMkpDO1NBM0pZLGlCQUFpQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIGlzRGV2TW9kZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQge1xyXG4gIFJvdXRlLFxyXG4gIFVybE1hdGNoZXIsXHJcbiAgVXJsTWF0Y2hSZXN1bHQsXHJcbiAgVXJsU2VnbWVudCxcclxuICBVcmxTZWdtZW50R3JvdXAsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcclxuaW1wb3J0IHsgR2xvYlNlcnZpY2UgfSBmcm9tICcuLi8uLi91dGlsL2dsb2Iuc2VydmljZSc7XHJcblxyXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxyXG5leHBvcnQgY2xhc3MgVXJsTWF0Y2hlclNlcnZpY2Uge1xyXG4gIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBnbG9iU2VydmljZTogR2xvYlNlcnZpY2UpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgYSBtYXRjaGVyIHRoYXQgaXMgYWx3YXlzIGZhaWxzXHJcbiAgICovXHJcbiAgZ2V0RmFsc3koKTogVXJsTWF0Y2hlciB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gZmFsc3lVcmxNYXRjaGVyKCk6IG51bGwge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbWF0Y2hlciBmb3IgZ2l2ZW4gbGlzdCBvZiBwYXRoc1xyXG4gICAqL1xyXG4gIGdldEZyb21QYXRocyhwYXRoczogc3RyaW5nW10pOiBVcmxNYXRjaGVyIHtcclxuICAgIGNvbnN0IG1hdGNoZXJzID0gcGF0aHMubWFwKChwYXRoKSA9PiB0aGlzLmdldEZyb21QYXRoKHBhdGgpKTtcclxuICAgIGNvbnN0IG1hdGNoZXIgPSB0aGlzLmdldENvbWJpbmVkKG1hdGNoZXJzKTtcclxuICAgIGlmIChpc0Rldk1vZGUoKSkge1xyXG4gICAgICBtYXRjaGVyWydfcGF0aHMnXSA9IHBhdGhzOyAvLyBwcm9wZXJ0eSBhZGRlZCBmb3IgZWFzaWVyIGRlYnVnZ2luZyBvZiByb3V0ZXNcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG1hdGNoZXIgdGhhdCBjb21iaW5lcyB0aGUgZ2l2ZW4gbWF0Y2hlcnNcclxuICAgKiAqL1xyXG4gIGdldENvbWJpbmVkKG1hdGNoZXJzOiBVcmxNYXRjaGVyW10pOiBVcmxNYXRjaGVyIHtcclxuICAgIGNvbnN0IG1hdGNoZXIgPSBmdW5jdGlvbiBjb21iaW5lZFVybE1hdGNoZXJzKFxyXG4gICAgICBzZWdtZW50czogVXJsU2VnbWVudFtdLFxyXG4gICAgICBzZWdtZW50R3JvdXA6IFVybFNlZ21lbnRHcm91cCxcclxuICAgICAgcm91dGU6IFJvdXRlXHJcbiAgICApOiBVcmxNYXRjaFJlc3VsdCB8IG51bGwge1xyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbWF0Y2hlcnNbaV0oc2VnbWVudHMsIHNlZ21lbnRHcm91cCwgcm91dGUpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIGlmIChpc0Rldk1vZGUoKSkge1xyXG4gICAgICBtYXRjaGVyWydfbWF0Y2hlcnMnXSA9IG1hdGNoZXJzOyAvLyBwcm9wZXJ0eSBhZGRlZCBmb3IgZWFzaWVyIGRlYnVnZ2luZyBvZiByb3V0ZXNcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2ltaWxhciB0byBBbmd1bGFyJ3MgZGVmYXVsdFVybE1hdGNoZXIuIERpZmZlcmVuY2VzOlxyXG4gICAqIC0gdGhlIGBwYXRoYCBjb21lcyBmcm9tIGZ1bmN0aW9uJ3MgYXJndW1lbnQsIG5vdCBmcm9tIGByb3V0ZS5wYXRoYFxyXG4gICAqIC0gdGhlIGVtcHR5IHBhdGggYCcnYCBpcyBoYW5kbGVkIGhlcmUsIGJ1dCBpbiBBbmd1bGFyIGlzIGhhbmRsZWQgb25lIGxldmVsIGhpZ2hlciBpbiB0aGUgbWF0Y2goKSBmdW5jdGlvblxyXG4gICAqL1xyXG4gIHByb3RlY3RlZCBnZXRGcm9tUGF0aChwYXRoOiBzdHJpbmcgPSAnJyk6IFVybE1hdGNoZXIge1xyXG4gICAgY29uc3QgbWF0Y2hlciA9IGZ1bmN0aW9uIHBhdGhVcmxNYXRjaGVyKFxyXG4gICAgICBzZWdtZW50czogVXJsU2VnbWVudFtdLFxyXG4gICAgICBzZWdtZW50R3JvdXA6IFVybFNlZ21lbnRHcm91cCxcclxuICAgICAgcm91dGU6IFJvdXRlXHJcbiAgICApOiBVcmxNYXRjaFJlc3VsdCB8IG51bGwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQGxpY2Vuc2VcclxuICAgICAgICogVGhlIE1JVCBMaWNlbnNlXHJcbiAgICAgICAqIENvcHlyaWdodCAoYykgMjAxMC0yMDE5IEdvb2dsZSBMTEMuIGh0dHA6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcclxuICAgICAgICpcclxuICAgICAgICogU2VlOlxyXG4gICAgICAgKiAtIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvYmxvYi82ZjVmNDgxZmRhZTAzZjFkOGRiMzYyODRiNjRjN2I4MmQ5NTE5ZDg1L3BhY2thZ2VzL3JvdXRlci9zcmMvc2hhcmVkLnRzI0wxMjFcclxuICAgICAgICovXHJcblxyXG4gICAgICAvLyB1c2UgZnVuY3Rpb24ncyBhcmd1bWVudCwgbm90IHRoZSBgcm91dGUucGF0aGBcclxuICAgICAgaWYgKHBhdGggPT09ICcnKSB7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgcm91dGUucGF0aE1hdGNoID09PSAnZnVsbCcgJiZcclxuICAgICAgICAgIChzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSB8fCBzZWdtZW50cy5sZW5ndGggPiAwKVxyXG4gICAgICAgICkge1xyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiBbXSwgcG9zUGFyYW1zOiB7fSB9O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBwYXJ0cyA9IHBhdGguc3BsaXQoJy8nKTsgLy8gdXNlIGZ1bmN0aW9uJ3MgYXJndW1lbnQsIG5vdCB0aGUgYHJvdXRlLnBhdGhgXHJcblxyXG4gICAgICBpZiAocGFydHMubGVuZ3RoID4gc2VnbWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gVGhlIGFjdHVhbCBVUkwgaXMgc2hvcnRlciB0aGFuIHRoZSBjb25maWcsIG5vIG1hdGNoXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChcclxuICAgICAgICByb3V0ZS5wYXRoTWF0Y2ggPT09ICdmdWxsJyAmJlxyXG4gICAgICAgIChzZWdtZW50R3JvdXAuaGFzQ2hpbGRyZW4oKSB8fCBwYXJ0cy5sZW5ndGggPCBzZWdtZW50cy5sZW5ndGgpXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIFRoZSBjb25maWcgaXMgbG9uZ2VyIHRoYW4gdGhlIGFjdHVhbCBVUkwgYnV0IHdlIGFyZSBsb29raW5nIGZvciBhIGZ1bGwgbWF0Y2gsIHJldHVybiBudWxsXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHBvc1BhcmFtczogeyBba2V5OiBzdHJpbmddOiBVcmxTZWdtZW50IH0gPSB7fTtcclxuXHJcbiAgICAgIC8vIENoZWNrIGVhY2ggY29uZmlnIHBhcnQgYWdhaW5zdCB0aGUgYWN0dWFsIFVSTFxyXG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGFydHMubGVuZ3RoOyBpbmRleCsrKSB7XHJcbiAgICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2luZGV4XTtcclxuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xyXG4gICAgICAgIGNvbnN0IGlzUGFyYW1ldGVyID0gcGFydC5zdGFydHNXaXRoKCc6Jyk7XHJcbiAgICAgICAgaWYgKGlzUGFyYW1ldGVyKSB7XHJcbiAgICAgICAgICBwb3NQYXJhbXNbcGFydC5zdWJzdHJpbmcoMSldID0gc2VnbWVudDtcclxuICAgICAgICB9IGVsc2UgaWYgKHBhcnQgIT09IHNlZ21lbnQucGF0aCkge1xyXG4gICAgICAgICAgLy8gVGhlIGFjdHVhbCBVUkwgcGFydCBkb2VzIG5vdCBtYXRjaCB0aGUgY29uZmlnLCBubyBtYXRjaFxyXG4gICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geyBjb25zdW1lZDogc2VnbWVudHMuc2xpY2UoMCwgcGFydHMubGVuZ3RoKSwgcG9zUGFyYW1zIH07XHJcbiAgICB9O1xyXG4gICAgaWYgKGlzRGV2TW9kZSgpKSB7XHJcbiAgICAgIG1hdGNoZXJbJ19wYXRoJ10gPSBwYXRoOyAvLyBwcm9wZXJ0eSBhZGRlZCBmb3IgZWFzaWVyIGRlYnVnZ2luZyBvZiByb3V0ZXNcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBVUkwgbWF0Y2hlciB0aGF0IGFjY2VwdHMgYWxtb3N0IGV2ZXJ5dGhpbmcgKGxpa2UgYCoqYCByb3V0ZSksIGJ1dCBub3QgcGF0aHMgYWNjZXB0ZWQgYnkgdGhlIGdpdmVuIG1hdGNoZXJcclxuICAgKi9cclxuICBnZXRPcHBvc2l0ZShvcmlnaW5hbE1hdGNoZXI6IFVybE1hdGNoZXIpOiBVcmxNYXRjaGVyIHtcclxuICAgIGNvbnN0IG1hdGNoZXIgPSBmdW5jdGlvbiBvcHBvc2l0ZVVybE1hdGNoZXIoXHJcbiAgICAgIHNlZ21lbnRzOiBVcmxTZWdtZW50W10sXHJcbiAgICAgIGdyb3VwOiBVcmxTZWdtZW50R3JvdXAsXHJcbiAgICAgIHJvdXRlOiBSb3V0ZVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBvcmlnaW5hbE1hdGNoZXIoc2VnbWVudHMsIGdyb3VwLCByb3V0ZSlcclxuICAgICAgICA/IG51bGxcclxuICAgICAgICA6IHsgY29uc3VtZWQ6IHNlZ21lbnRzLCBwb3NQYXJhbXM6IHt9IH07XHJcbiAgICB9O1xyXG4gICAgaWYgKGlzRGV2TW9kZSgpKSB7XHJcbiAgICAgIG1hdGNoZXJbJ19vcmlnaW5hbE1hdGNoZXInXSA9IG9yaWdpbmFsTWF0Y2hlcjsgLy8gcHJvcGVydHkgYWRkZWQgZm9yIGVhc2llciBkZWJ1Z2dpbmcgb2Ygcm91dGVzXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWF0Y2hlcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgVVJMIG1hdGNoZXIgZm9yIHRoZSBnaXZlbiBsaXN0IG9mIGdsb2ItbGlrZSBwYXR0ZXJucy4gRWFjaCBwYXR0ZXJuIG11c3Qgc3RhcnQgd2l0aCBgL2Agb3IgYCEvYC5cclxuICAgKi9cclxuICBnZXRGcm9tR2xvYihnbG9iUGF0dGVybnM6IHN0cmluZ1tdKTogVXJsTWF0Y2hlciB7XHJcbiAgICBjb25zdCBnbG9iVmFsaWRhdG9yID0gdGhpcy5nbG9iU2VydmljZS5nZXRWYWxpZGF0b3IoZ2xvYlBhdHRlcm5zKTtcclxuXHJcbiAgICBjb25zdCBtYXRjaGVyID0gZnVuY3Rpb24gZ2xvYlVybE1hdGNoZXIoXHJcbiAgICAgIHNlZ21lbnRzOiBVcmxTZWdtZW50W11cclxuICAgICk6IFVybE1hdGNoUmVzdWx0IHwgbnVsbCB7XHJcbiAgICAgIGNvbnN0IGZ1bGxQYXRoID0gYC8ke3NlZ21lbnRzLm1hcCgocykgPT4gcy5wYXRoKS5qb2luKCcvJyl9YDtcclxuXHJcbiAgICAgIHJldHVybiBnbG9iVmFsaWRhdG9yKGZ1bGxQYXRoKVxyXG4gICAgICAgID8geyBjb25zdW1lZDogc2VnbWVudHMsIHBvc1BhcmFtczoge30gfVxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIH07XHJcbiAgICBpZiAoaXNEZXZNb2RlKCkpIHtcclxuICAgICAgbWF0Y2hlclsnX2dsb2JQYXR0ZXJucyddID0gZ2xvYlBhdHRlcm5zOyAvLyBwcm9wZXJ0eSBhZGRlZCBmb3IgZWFzaWVyIGRlYnVnZ2luZyBvZiByb3V0ZXNcclxuICAgIH1cclxuICAgIHJldHVybiBtYXRjaGVyO1xyXG4gIH1cclxufVxyXG4iXX0=