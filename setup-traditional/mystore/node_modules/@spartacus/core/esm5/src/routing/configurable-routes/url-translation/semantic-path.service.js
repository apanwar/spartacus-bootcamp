import { __decorate, __read, __spread, __values } from "tslib";
import { Injectable, isDevMode } from '@angular/core';
import { UrlParsingService } from './url-parsing.service';
import { getParamName, isParam } from './path-utils';
import { RoutingConfigService } from '../routing-config.service';
import * as i0 from "@angular/core";
import * as i1 from "../routing-config.service";
import * as i2 from "./url-parsing.service";
var SemanticPathService = /** @class */ (function () {
    function SemanticPathService(routingConfigService, urlParser) {
        this.routingConfigService = routingConfigService;
        this.urlParser = urlParser;
        this.ROOT_URL = ['/'];
    }
    /**
     * Returns the first path alias configured for a given route name. It adds `/` at the beginning.
     */
    SemanticPathService.prototype.get = function (routeName) {
        var routeConfig = this.routingConfigService.getRouteConfig(routeName);
        return routeConfig && Array.isArray(routeConfig.paths)
            ? '/' + routeConfig.paths[0]
            : undefined;
    };
    /**
     * Transforms the array of url commands. Each command can be:
     * a) string - will be left untouched
     * b) object { cxRoute: <route name> } - will be replaced with semantic path
     * c) object { cxRoute: <route name>, params: { ... } } - same as above, but with passed params
     *
     * If the first command is the object with the `cxRoute` property, returns an absolute url (with the first element of the array `'/'`)
     */
    SemanticPathService.prototype.transform = function (commands) {
        var e_1, _a;
        if (!Array.isArray(commands)) {
            commands = [commands];
        }
        var result = [];
        try {
            for (var commands_1 = __values(commands), commands_1_1 = commands_1.next(); !commands_1_1.done; commands_1_1 = commands_1.next()) {
                var command = commands_1_1.value;
                if (!this.isRouteCommand(command)) {
                    // don't modify segment that is not route command:
                    result.push(command);
                }
                else {
                    // generate array with url segments for given route command:
                    var partialResult = this.generateUrlPart(command);
                    if (partialResult === null) {
                        return this.ROOT_URL;
                    }
                    result.push.apply(result, __spread(partialResult));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (commands_1_1 && !commands_1_1.done && (_a = commands_1.return)) _a.call(commands_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (this.shouldOutputAbsolute(commands)) {
            result.unshift('/');
        }
        return result;
    };
    SemanticPathService.prototype.isRouteCommand = function (command) {
        return command && Boolean(command.cxRoute);
    };
    SemanticPathService.prototype.shouldOutputAbsolute = function (commands) {
        return this.isRouteCommand(commands[0]);
    };
    SemanticPathService.prototype.generateUrlPart = function (command) {
        this.standarizeRouteCommand(command);
        if (!command.cxRoute) {
            return null;
        }
        var routeConfig = this.routingConfigService.getRouteConfig(command.cxRoute);
        // if no route translation was configured, return null:
        if (!routeConfig || !routeConfig.paths) {
            return null;
        }
        // find first path that can satisfy it's parameters with given parameters
        var path = this.findPathWithFillableParams(routeConfig, command.params);
        // if there is no configured path that can be satisfied with given params, return null
        if (!path) {
            return null;
        }
        var result = this.provideParamsValues(path, command.params, routeConfig.paramsMapping);
        return result;
    };
    SemanticPathService.prototype.standarizeRouteCommand = function (command) {
        command.params = command.params || {};
    };
    SemanticPathService.prototype.provideParamsValues = function (path, params, paramsMapping) {
        var _this = this;
        return this.urlParser.getPrimarySegments(path).map(function (segment) {
            if (isParam(segment)) {
                var paramName = getParamName(segment);
                var mappedParamName = _this.getMappedParamName(paramName, paramsMapping);
                return params[mappedParamName];
            }
            return segment;
        });
    };
    SemanticPathService.prototype.findPathWithFillableParams = function (routeConfig, params) {
        var _this = this;
        var foundPath = routeConfig.paths.find(function (path) {
            return _this.getParams(path).every(function (paramName) {
                var mappedParamName = _this.getMappedParamName(paramName, routeConfig.paramsMapping);
                return params[mappedParamName] !== undefined;
            });
        });
        if (foundPath === undefined || foundPath === null) {
            this.warn("No configured path matches all its params to given object. ", "Route config: ", routeConfig, "Params object: ", params);
            return null;
        }
        return foundPath;
    };
    SemanticPathService.prototype.getParams = function (path) {
        return this.urlParser
            .getPrimarySegments(path)
            .filter(isParam)
            .map(getParamName);
    };
    SemanticPathService.prototype.getMappedParamName = function (paramName, paramsMapping) {
        if (paramsMapping) {
            return paramsMapping[paramName] || paramName;
        }
        return paramName;
    };
    SemanticPathService.prototype.warn = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (isDevMode()) {
            console.warn.apply(console, __spread(args));
        }
    };
    SemanticPathService.ctorParameters = function () { return [
        { type: RoutingConfigService },
        { type: UrlParsingService }
    ]; };
    SemanticPathService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SemanticPathService_Factory() { return new SemanticPathService(i0.ɵɵinject(i1.RoutingConfigService), i0.ɵɵinject(i2.UrlParsingService)); }, token: SemanticPathService, providedIn: "root" });
    SemanticPathService = __decorate([
        Injectable({ providedIn: 'root' })
    ], SemanticPathService);
    return SemanticPathService;
}());
export { SemanticPathService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VtYW50aWMtcGF0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHNwYXJ0YWN1cy9jb3JlLyIsInNvdXJjZXMiOlsic3JjL3JvdXRpbmcvY29uZmlndXJhYmxlLXJvdXRlcy91cmwtdHJhbnNsYXRpb24vc2VtYW50aWMtcGF0aC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRCxPQUFPLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxNQUFNLGNBQWMsQ0FBQztBQUVyRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQzs7OztBQUdqRTtJQUdFLDZCQUNZLG9CQUEwQyxFQUMxQyxTQUE0QjtRQUQ1Qix5QkFBb0IsR0FBcEIsb0JBQW9CLENBQXNCO1FBQzFDLGNBQVMsR0FBVCxTQUFTLENBQW1CO1FBSi9CLGFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBS3ZCLENBQUM7SUFFSjs7T0FFRztJQUNILGlDQUFHLEdBQUgsVUFBSSxTQUFpQjtRQUNuQixJQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3hFLE9BQU8sV0FBVyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQztZQUNwRCxDQUFDLENBQUMsR0FBRyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzVCLENBQUMsQ0FBQyxTQUFTLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCx1Q0FBUyxHQUFULFVBQVUsUUFBcUI7O1FBQzdCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBQzVCLFFBQVEsR0FB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QUFhLGNBQU87YUFBUCxVQUFPLEVBQVAscUJBQU8sRUFBUCxJQUFPO1lBQVAseUJBQU87O1FBQ2xCLElBQUksU0FBUyxFQUFFLEVBQUU7WUFDZixPQUFPLENBQUMsSUFBSSxPQUFaLE9BQU8sV0FBUyxJQUFJLEdBQUU7U0FDdkI7SUFDSCxDQUFDOztnQkFoS2lDLG9CQUFvQjtnQkFDL0IsaUJBQWlCOzs7SUFMN0IsbUJBQW1CO1FBRC9CLFVBQVUsQ0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQztPQUN0QixtQkFBbUIsQ0FxSy9COzhCQTdLRDtDQTZLQyxBQXJLRCxJQXFLQztTQXJLWSxtQkFBbUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBpc0Rldk1vZGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgVXJsUGFyc2luZ1NlcnZpY2UgfSBmcm9tICcuL3VybC1wYXJzaW5nLnNlcnZpY2UnO1xyXG5pbXBvcnQgeyBSb3V0ZUNvbmZpZywgUGFyYW1zTWFwcGluZyB9IGZyb20gJy4uL3JvdXRlcy1jb25maWcnO1xyXG5pbXBvcnQgeyBnZXRQYXJhbU5hbWUsIGlzUGFyYW0gfSBmcm9tICcuL3BhdGgtdXRpbHMnO1xyXG5pbXBvcnQgeyBVcmxDb21tYW5kUm91dGUsIFVybENvbW1hbmRzLCBVcmxDb21tYW5kIH0gZnJvbSAnLi91cmwtY29tbWFuZCc7XHJcbmltcG9ydCB7IFJvdXRpbmdDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi4vcm91dGluZy1jb25maWcuc2VydmljZSc7XHJcblxyXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxyXG5leHBvcnQgY2xhc3MgU2VtYW50aWNQYXRoU2VydmljZSB7XHJcbiAgcmVhZG9ubHkgUk9PVF9VUkwgPSBbJy8nXTtcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcm90ZWN0ZWQgcm91dGluZ0NvbmZpZ1NlcnZpY2U6IFJvdXRpbmdDb25maWdTZXJ2aWNlLFxyXG4gICAgcHJvdGVjdGVkIHVybFBhcnNlcjogVXJsUGFyc2luZ1NlcnZpY2VcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IHBhdGggYWxpYXMgY29uZmlndXJlZCBmb3IgYSBnaXZlbiByb3V0ZSBuYW1lLiBJdCBhZGRzIGAvYCBhdCB0aGUgYmVnaW5uaW5nLlxyXG4gICAqL1xyXG4gIGdldChyb3V0ZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgICBjb25zdCByb3V0ZUNvbmZpZyA9IHRoaXMucm91dGluZ0NvbmZpZ1NlcnZpY2UuZ2V0Um91dGVDb25maWcocm91dGVOYW1lKTtcclxuICAgIHJldHVybiByb3V0ZUNvbmZpZyAmJiBBcnJheS5pc0FycmF5KHJvdXRlQ29uZmlnLnBhdGhzKVxyXG4gICAgICA/ICcvJyArIHJvdXRlQ29uZmlnLnBhdGhzWzBdXHJcbiAgICAgIDogdW5kZWZpbmVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtcyB0aGUgYXJyYXkgb2YgdXJsIGNvbW1hbmRzLiBFYWNoIGNvbW1hbmQgY2FuIGJlOlxyXG4gICAqIGEpIHN0cmluZyAtIHdpbGwgYmUgbGVmdCB1bnRvdWNoZWRcclxuICAgKiBiKSBvYmplY3QgeyBjeFJvdXRlOiA8cm91dGUgbmFtZT4gfSAtIHdpbGwgYmUgcmVwbGFjZWQgd2l0aCBzZW1hbnRpYyBwYXRoXHJcbiAgICogYykgb2JqZWN0IHsgY3hSb3V0ZTogPHJvdXRlIG5hbWU+LCBwYXJhbXM6IHsgLi4uIH0gfSAtIHNhbWUgYXMgYWJvdmUsIGJ1dCB3aXRoIHBhc3NlZCBwYXJhbXNcclxuICAgKlxyXG4gICAqIElmIHRoZSBmaXJzdCBjb21tYW5kIGlzIHRoZSBvYmplY3Qgd2l0aCB0aGUgYGN4Um91dGVgIHByb3BlcnR5LCByZXR1cm5zIGFuIGFic29sdXRlIHVybCAod2l0aCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkgYCcvJ2ApXHJcbiAgICovXHJcbiAgdHJhbnNmb3JtKGNvbW1hbmRzOiBVcmxDb21tYW5kcyk6IGFueVtdIHtcclxuICAgIGlmICghQXJyYXkuaXNBcnJheShjb21tYW5kcykpIHtcclxuICAgICAgY29tbWFuZHMgPSBbY29tbWFuZHNdO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlc3VsdDogc3RyaW5nW10gPSBbXTtcclxuICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBjb21tYW5kcykge1xyXG4gICAgICBpZiAoIXRoaXMuaXNSb3V0ZUNvbW1hbmQoY29tbWFuZCkpIHtcclxuICAgICAgICAvLyBkb24ndCBtb2RpZnkgc2VnbWVudCB0aGF0IGlzIG5vdCByb3V0ZSBjb21tYW5kOlxyXG4gICAgICAgIHJlc3VsdC5wdXNoKGNvbW1hbmQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vIGdlbmVyYXRlIGFycmF5IHdpdGggdXJsIHNlZ21lbnRzIGZvciBnaXZlbiByb3V0ZSBjb21tYW5kOlxyXG4gICAgICAgIGNvbnN0IHBhcnRpYWxSZXN1bHQgPSB0aGlzLmdlbmVyYXRlVXJsUGFydChjb21tYW5kKTtcclxuXHJcbiAgICAgICAgaWYgKHBhcnRpYWxSZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLlJPT1RfVVJMO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmVzdWx0LnB1c2goLi4ucGFydGlhbFJlc3VsdCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAodGhpcy5zaG91bGRPdXRwdXRBYnNvbHV0ZShjb21tYW5kcykpIHtcclxuICAgICAgcmVzdWx0LnVuc2hpZnQoJy8nKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpc1JvdXRlQ29tbWFuZChjb21tYW5kOiBVcmxDb21tYW5kKTogYm9vbGVhbiB7XHJcbiAgICByZXR1cm4gY29tbWFuZCAmJiBCb29sZWFuKGNvbW1hbmQuY3hSb3V0ZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNob3VsZE91dHB1dEFic29sdXRlKGNvbW1hbmRzOiBVcmxDb21tYW5kcyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuaXNSb3V0ZUNvbW1hbmQoY29tbWFuZHNbMF0pO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZW5lcmF0ZVVybFBhcnQoY29tbWFuZDogVXJsQ29tbWFuZFJvdXRlKTogc3RyaW5nW10gfCBudWxsIHtcclxuICAgIHRoaXMuc3RhbmRhcml6ZVJvdXRlQ29tbWFuZChjb21tYW5kKTtcclxuXHJcbiAgICBpZiAoIWNvbW1hbmQuY3hSb3V0ZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByb3V0ZUNvbmZpZyA9IHRoaXMucm91dGluZ0NvbmZpZ1NlcnZpY2UuZ2V0Um91dGVDb25maWcoXHJcbiAgICAgIGNvbW1hbmQuY3hSb3V0ZVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBpZiBubyByb3V0ZSB0cmFuc2xhdGlvbiB3YXMgY29uZmlndXJlZCwgcmV0dXJuIG51bGw6XHJcbiAgICBpZiAoIXJvdXRlQ29uZmlnIHx8ICFyb3V0ZUNvbmZpZy5wYXRocykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBmaW5kIGZpcnN0IHBhdGggdGhhdCBjYW4gc2F0aXNmeSBpdCdzIHBhcmFtZXRlcnMgd2l0aCBnaXZlbiBwYXJhbWV0ZXJzXHJcbiAgICBjb25zdCBwYXRoID0gdGhpcy5maW5kUGF0aFdpdGhGaWxsYWJsZVBhcmFtcyhyb3V0ZUNvbmZpZywgY29tbWFuZC5wYXJhbXMpO1xyXG5cclxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGNvbmZpZ3VyZWQgcGF0aCB0aGF0IGNhbiBiZSBzYXRpc2ZpZWQgd2l0aCBnaXZlbiBwYXJhbXMsIHJldHVybiBudWxsXHJcbiAgICBpZiAoIXBhdGgpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5wcm92aWRlUGFyYW1zVmFsdWVzKFxyXG4gICAgICBwYXRoLFxyXG4gICAgICBjb21tYW5kLnBhcmFtcyxcclxuICAgICAgcm91dGVDb25maWcucGFyYW1zTWFwcGluZ1xyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBzdGFuZGFyaXplUm91dGVDb21tYW5kKGNvbW1hbmQ6IFVybENvbW1hbmRSb3V0ZSk6IHZvaWQge1xyXG4gICAgY29tbWFuZC5wYXJhbXMgPSBjb21tYW5kLnBhcmFtcyB8fCB7fTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgcHJvdmlkZVBhcmFtc1ZhbHVlcyhcclxuICAgIHBhdGg6IHN0cmluZyxcclxuICAgIHBhcmFtczogb2JqZWN0LFxyXG4gICAgcGFyYW1zTWFwcGluZzogUGFyYW1zTWFwcGluZ1xyXG4gICk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiB0aGlzLnVybFBhcnNlci5nZXRQcmltYXJ5U2VnbWVudHMocGF0aCkubWFwKChzZWdtZW50KSA9PiB7XHJcbiAgICAgIGlmIChpc1BhcmFtKHNlZ21lbnQpKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYW1OYW1lID0gZ2V0UGFyYW1OYW1lKHNlZ21lbnQpO1xyXG4gICAgICAgIGNvbnN0IG1hcHBlZFBhcmFtTmFtZSA9IHRoaXMuZ2V0TWFwcGVkUGFyYW1OYW1lKFxyXG4gICAgICAgICAgcGFyYW1OYW1lLFxyXG4gICAgICAgICAgcGFyYW1zTWFwcGluZ1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtc1ttYXBwZWRQYXJhbU5hbWVdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzZWdtZW50O1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZpbmRQYXRoV2l0aEZpbGxhYmxlUGFyYW1zKFxyXG4gICAgcm91dGVDb25maWc6IFJvdXRlQ29uZmlnLFxyXG4gICAgcGFyYW1zOiBvYmplY3RcclxuICApOiBzdHJpbmcge1xyXG4gICAgY29uc3QgZm91bmRQYXRoID0gcm91dGVDb25maWcucGF0aHMuZmluZCgocGF0aCkgPT5cclxuICAgICAgdGhpcy5nZXRQYXJhbXMocGF0aCkuZXZlcnkoKHBhcmFtTmFtZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1hcHBlZFBhcmFtTmFtZSA9IHRoaXMuZ2V0TWFwcGVkUGFyYW1OYW1lKFxyXG4gICAgICAgICAgcGFyYW1OYW1lLFxyXG4gICAgICAgICAgcm91dGVDb25maWcucGFyYW1zTWFwcGluZ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJhbXNbbWFwcGVkUGFyYW1OYW1lXSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICB9KVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAoZm91bmRQYXRoID09PSB1bmRlZmluZWQgfHwgZm91bmRQYXRoID09PSBudWxsKSB7XHJcbiAgICAgIHRoaXMud2FybihcclxuICAgICAgICBgTm8gY29uZmlndXJlZCBwYXRoIG1hdGNoZXMgYWxsIGl0cyBwYXJhbXMgdG8gZ2l2ZW4gb2JqZWN0LiBgLFxyXG4gICAgICAgIGBSb3V0ZSBjb25maWc6IGAsXHJcbiAgICAgICAgcm91dGVDb25maWcsXHJcbiAgICAgICAgYFBhcmFtcyBvYmplY3Q6IGAsXHJcbiAgICAgICAgcGFyYW1zXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvdW5kUGF0aDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0UGFyYW1zKHBhdGg6IHN0cmluZykge1xyXG4gICAgcmV0dXJuIHRoaXMudXJsUGFyc2VyXHJcbiAgICAgIC5nZXRQcmltYXJ5U2VnbWVudHMocGF0aClcclxuICAgICAgLmZpbHRlcihpc1BhcmFtKVxyXG4gICAgICAubWFwKGdldFBhcmFtTmFtZSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdldE1hcHBlZFBhcmFtTmFtZShwYXJhbU5hbWU6IHN0cmluZywgcGFyYW1zTWFwcGluZzogb2JqZWN0KTogc3RyaW5nIHtcclxuICAgIGlmIChwYXJhbXNNYXBwaW5nKSB7XHJcbiAgICAgIHJldHVybiBwYXJhbXNNYXBwaW5nW3BhcmFtTmFtZV0gfHwgcGFyYW1OYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcmFtTmFtZTtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgd2FybiguLi5hcmdzKSB7XHJcbiAgICBpZiAoaXNEZXZNb2RlKCkpIHtcclxuICAgICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXX0=